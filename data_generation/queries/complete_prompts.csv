ID,initial_query,sql_query,prompt_tokens,output_tokens,total_tokens,tables,prompt_tokens_tables,output_tokens_tables,total_tokens_tables
0,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_name, ' - ', c.customer_id) AS customer_info,
    COUNT(o.order_id) AS total_orders
  FROM 
    energy_company.customers c
  INNER JOIN 
    energy_company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
  GROUP BY 
    c.customer_name, c.customer_id
  HAVING 
    total_orders > 5
),
cte2 AS (
  SELECT 
    p.product_name,
    SUM(od.quantity * od.unit_price) AS total_revenue
  FROM 
    energy_company.products p
  INNER JOIN 
    energy_company.order_details od ON p.product_id = od.product_id
  INNER JOIN 
    energy_company.orders o ON od.order_id = o.order_id
  WHERE 
    o.order_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
  GROUP BY 
    p.product_name
  HAVING 
    total_revenue > 10000
)
SELECT 
  cte1.customer_info,
  cte2.product_name,
  cte2.total_revenue
FROM 
  cte1
INNER JOIN 
  cte2 ON cte1.total_orders = cte2.total_revenue
ORDER BY 
  cte2.total_revenue DESC;",321,291,612,"['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_details']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_details']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_details']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_details']"
1,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(n.title, ' - ', n.author) AS article_title,
    n.published_date AS article_date,
    c.category_name AS article_category,
    COUNT(DISTINCT c.comment_id) AS total_comments,
    AVG(r.rating_value) AS average_rating,
    CONCAT(u.first_name, ' ', u.last_name) AS user_full_name,
    DATE_FORMAT(u.birthdate, '%Y-%m-%d') AS formatted_birthdate,
    UPPER(u.email) AS uppercase_email
FROM
    news_database.news_articles n
JOIN
    news_database.news_categories c ON n.category_id = c.category_id
JOIN
    news_database.news_comments c ON n.article_id = c.article_id
JOIN
    news_database.news_ratings r ON n.article_id = r.article_id
JOIN
    user_database.users u ON c.user_id = u.user_id
WHERE
    n.published_date >= '2021-01-01'
    AND c.comment_date >= '2021-01-01'
    AND r.rating_date >= '2021-01-01'
    AND u.birthdate <= '2000-01-01'
GROUP BY
    n.title,
    n.author,
    n.published_date,
    c.category_name,
    u.first_name,
    u.last_name,
    u.birthdate,
    u.email
HAVING
    total_comments > 10
ORDER BY
    average_rating DESC,
    article_date DESC
LIMIT 100;",328,301,629,"['news_database.news_articles', 'news_database.news_categories', 'news_database.news_comments', 'news_database.news_ratings', 'user_database.users']","['news_database.news_articles', 'news_database.news_categories', 'news_database.news_comments', 'news_database.news_ratings', 'user_database.users']","['news_database.news_articles', 'news_database.news_categories', 'news_database.news_comments', 'news_database.news_ratings', 'user_database.users']","['news_database.news_articles', 'news_database.news_categories', 'news_database.news_comments', 'news_database.news_ratings', 'user_database.users']"
2,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.product_name, ' - ', p.product_code) AS product_info,
    c.category_name AS product_category,
    s.supplier_name AS supplier,
    SUM(o.quantity) AS total_quantity_sold,
    SUM(o.quantity * o.unit_price) AS total_revenue,
    AVG(o.unit_price) AS average_price,
    COUNT(DISTINCT o.customer_id) AS unique_customers,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date
FROM
    pharmaceuticals.products p
        INNER JOIN
    pharmaceuticals.categories c ON p.category_id = c.category_id
        INNER JOIN
    pharmaceuticals.suppliers s ON p.supplier_id = s.supplier_id
        INNER JOIN
    (SELECT 
        od.product_id, od.order_id, od.quantity, od.unit_price, o.customer_id, o.order_date
    FROM
        pharmaceuticals.order_details od
    INNER JOIN pharmaceuticals.orders o ON od.order_id = o.order_id
    WHERE
        o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
            AND o.status = 'completed') o ON p.product_id = o.product_id
GROUP BY p.product_name , p.product_code , c.category_name , s.supplier_name , DATE_FORMAT(o.order_date, '%Y-%m-%d')
HAVING total_quantity_sold > 100
ORDER BY total_revenue DESC;",316,298,614,"['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']"
3,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an entertainment company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(p.price) AS total_revenue,
    AVG(DATEDIFF(o.order_date, c.date_of_birth)) AS avg_age_at_purchase,
    DATE_FORMAT(o.order_date, '%Y-%m') AS order_month,
    UPPER(p.product_name) AS product_name,
    CONCAT(e.first_name, ' ', e.last_name) AS employee_name
FROM
    entertainment.orders o
JOIN
    entertainment.customers c ON o.customer_id = c.customer_id
JOIN
    entertainment.products p ON o.product_id = p.product_id
JOIN
    entertainment.employees e ON o.employee_id = e.employee_id
JOIN
    entertainment.categories cat ON p.category_id = cat.category_id
JOIN
    (SELECT 
        o.customer_id,
            COUNT(DISTINCT o.order_id) AS total_orders
    FROM
        entertainment.orders o
    WHERE
        o.order_date >= '2021-01-01'
    GROUP BY o.customer_id
    HAVING total_orders > 5) AS frequent_customers ON c.customer_id = frequent_customers.customer_id
WHERE
    cat.category_name = 'Movies'
        AND e.department = 'Sales'
        AND p.price > 10
GROUP BY c.customer_id , order_month , product_name , employee_name
HAVING total_revenue > 1000
CROSS JOIN
    (SELECT 
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM
        entertainment.orders o
    WHERE
        o.order_date >= '2021-01-01') AS total_orders_summary;",319,352,671,"['entertainment.orders', 'entertainment.customers', 'entertainment.products', 'entertainment.employees', 'entertainment.categories']","['entertainment.orders', 'entertainment.customers', 'entertainment.products', 'entertainment.employees', 'entertainment.categories']","['entertainment.orders', 'entertainment.customers', 'entertainment.products', 'entertainment.employees', 'entertainment.categories']","['entertainment.orders', 'entertainment.customers', 'entertainment.products', 'entertainment.employees', 'entertainment.categories']"
4,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH sales AS (
  SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.product_id,
    o.quantity,
    o.unit_price,
    o.total_price
  FROM
    orders o
  JOIN
    customers c ON o.customer_id = c.customer_id
  JOIN
    products p ON o.product_id = p.product_id
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

monthly_sales AS (
  SELECT
    DATE_FORMAT(s.order_date, '%Y-%m') AS month,
    COUNT(DISTINCT s.order_id) AS total_orders,
    SUM(s.quantity) AS total_quantity,
    SUM(s.total_price) AS total_sales
  FROM
    sales s
  GROUP BY
    DATE_FORMAT(s.order_date, '%Y-%m')
),

top_customers AS (
  SELECT
    s.customer_id,
    c.customer_name,
    COUNT(DISTINCT s.order_id) AS total_orders,
    SUM(s.total_price) AS total_sales
  FROM
    sales s
  JOIN
    customers c ON s.customer_id = c.customer_id
  GROUP BY
    s.customer_id,
    c.customer_name
  HAVING
    COUNT(DISTINCT s.order_id) > 5
  ORDER BY
    SUM(s.total_price) DESC
  LIMIT
    10
),

product_sales AS (
  SELECT
    p.product_id,
    p.product_name,
    SUM(s.quantity) AS total_quantity,
    SUM(s.total_price) AS total_sales
  FROM
    sales s
  JOIN
    products p ON s.product_id = p.product_id
  GROUP BY
    p.product_id,
    p.product_name
  ORDER BY
    SUM(s.total_price) DESC
  LIMIT
    5
)

SELECT
  mc.month,
  mc.total_orders,
  mc.total_quantity,
  mc.total_sales,
  tc.customer_id,
  tc.customer_name,
  tc.total_orders,
  tc.total_sales,
  ps.product_id,
  ps.product_name,
  ps.total_quantity,
  ps.total_sales
FROM
  monthly_sales mc
JOIN
  top_customers tc ON mc.month = tc.month
JOIN
  product_sales ps ON mc.month = ps.month
ORDER BY
  mc.month,
  tc.total_sales DESC,
  ps.total_sales DESC;",320,507,827,"['orders', 'customers', 'products']","['orders', 'customers', 'products']","['orders', 'customers', 'products']","['orders', 'customers', 'products']"
5,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a logistics company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    o.order_id,
    o.order_date,
    o.order_status,
    o.total_price
  FROM 
    kusto['logistics'].orders o
  JOIN 
    kusto['logistics'].customers c ON o.customer_id = c.customer_id
  WHERE 
    o.order_status = 'Delivered'
),

cte2 AS (
  SELECT 
    p.product_name,
    p.product_category,
    p.product_price,
    oi.order_id,
    oi.quantity
  FROM 
    kusto['logistics'].order_items oi
  JOIN 
    kusto['logistics'].products p ON oi.product_id = p.product_id
),

cte3 AS (
  SELECT 
    cte1.customer_name,
    cte1.order_id,
    cte1.order_date,
    cte1.total_price,
    cte2.product_name,
    cte2.product_category,
    cte2.product_price,
    cte2.quantity,
    cte2.product_price * cte2.quantity AS total_product_price
  FROM 
    cte1
  JOIN 
    cte2 ON cte1.order_id = cte2.order_id
),

cte4 AS (
  SELECT 
    cte3.customer_name,
    cte3.order_id,
    cte3.order_date,
    cte3.total_price,
    cte3.product_category,
    SUM(cte3.total_product_price) AS total_category_price
  FROM 
    cte3
  GROUP BY 
    cte3.customer_name,
    cte3.order_id,
    cte3.order_date,
    cte3.total_price,
    cte3.product_category
),

cte5 AS (
  SELECT 
    cte4.customer_name,
    cte4.order_id,
    cte4.order_date,
    cte4.total_price,
    cte4.product_category,
    cte4.total_category_price,
    MAX(cte4.total_category_price) OVER (PARTITION BY cte4.customer_name) AS max_category_price
  FROM 
    cte4
),

cte6 AS (
  SELECT 
    cte5.customer_name,
    cte5.order_id,
    cte5.order_date,
    cte5.total_price,
    cte5.product_category,
    cte5.total_category_price,
    cte5.max_category_price,
    CASE 
      WHEN cte5.total_category_price = cte5.max_category_price THEN 'Highest'
      ELSE 'Not Highest'
    END AS category_status
  FROM 
    cte5
),

cte7 AS (
  SELECT 
    cte6.customer_name,
    cte6.order_id,
    cte6.order_date,
    cte6.total_price,
    cte6.product_category,
    cte6.total_category_price,
    cte6.max_category_price,
    cte6.category_status,
    ROW_NUMBER() OVER (PARTITION BY cte6.customer_name ORDER BY cte6.total_category_price DESC) AS category_rank
  FROM 
    cte6
),

cte8 AS (
  SELECT 
    cte7.customer_name,
    cte7.order_id,
    cte7.order_date,
    cte7.total_price,
    cte7.product_category,
    cte7.total_category_price,
    cte7.max_category_price,
    cte7.category_status,
    cte7.category_rank
  FROM 
    cte7
  WHERE 
    cte7.category_rank <= 3
),

cte9 AS (
  SELECT 
    cte8.customer_name,
    cte8.order_id,
    cte8.order_date,
    cte8.total_price,
    cte8.product_category,
    cte8.total_category_price,
    cte8.max_category_price,
    cte8.category_status,
    cte8.category_rank,
    COUNT(*) OVER (PARTITION BY cte8.customer_name) AS total_orders
  FROM 
    cte8
),

cte10 AS (
  SELECT 
    cte9.customer_name,
    cte9.order_id,
    cte9.order_date,
    cte9.total_price,
    cte9.product_category,
    cte9.total_category_price,
    cte9.max_category_price,
    cte9.category_status,
    cte9.category_rank,
    cte9.total_orders,
    CASE 
      WHEN cte9.total_orders > 5 THEN 'Loyal Customer'
      ELSE 'Regular Customer'
    END AS customer_type
  FROM 
    cte9
),

cte11 AS (
  SELECT 
    cte10.customer_name,
    cte10.order_id,
    cte10.order_date,
    cte10.total_price,
    cte10.product_category,
    cte10.total_category_price,
    cte10.max_category_price,
    cte10.category_status,
    cte10.category_rank,
    cte10.total_orders,
    cte10.customer_type,
    ROW_NUMBER() OVER (PARTITION BY cte10.customer_name ORDER BY cte10.order_date DESC) AS order_rank
  FROM 
    cte10
),

cte12 AS (
  SELECT 
    cte11.customer_name,
    cte11.order_id,
    cte11.order_date,
    cte11.total_price,
    cte11.product_category,
    cte11.total_category_price,
    cte11.max_category_price,
    cte11.category_status,
    cte11.category_rank,
    cte11.total_orders,
    cte11.customer_type,
    cte11.order_rank
  FROM 
    cte11
  WHERE 
    cte11.order_rank <= 5
)

SELECT 
  cte12.customer_name,
  cte12.order_id,
  cte12.order_date,
  cte12.total_price,
  cte12.product_category,
  cte12.total_category_price,
  cte12.max_category_price,
  cte12.category_status,
  cte12.category_rank,
  cte12.total_orders,
  cte12.customer_type,
  cte12.order_rank
FROM 
  cte12
CROSS JOIN 
  kusto['logistics'].employees e
WHERE 
  e.employee_id = 1
ORDER BY 
  cte12.order_date DESC;",321,1349,1670,"['kusto.logistics.orders', 'kusto.logistics.customers', 'kusto.logistics.order_items', 'kusto.logistics.products', 'cte1', 'cte2', 'cte3', 'cte4', 'cte5', 'cte6', 'cte7', 'cte8', 'cte9', 'cte10', 'cte11', 'cte12', 'kusto.logistics.employees']","['kusto.logistics.orders', 'kusto.logistics.customers', 'kusto.logistics.order_items', 'kusto.logistics.products', 'cte1', 'cte2', 'cte3', 'cte4', 'cte5', 'cte6', 'cte7', 'cte8', 'cte9', 'cte10', 'cte11', 'cte12', 'kusto.logistics.employees']","['kusto.logistics.orders', 'kusto.logistics.customers', 'kusto.logistics.order_items', 'kusto.logistics.products', 'cte1', 'cte2', 'cte3', 'cte4', 'cte5', 'cte6', 'cte7', 'cte8', 'cte9', 'cte10', 'cte11', 'cte12', 'kusto.logistics.employees']","['kusto.logistics.orders', 'kusto.logistics.customers', 'kusto.logistics.order_items', 'kusto.logistics.products', 'cte1', 'cte2', 'cte3', 'cte4', 'cte5', 'cte6', 'cte7', 'cte8', 'cte9', 'cte10', 'cte11', 'cte12', 'kusto.logistics.employees']"
6,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT p.product_id, p.product_name, p.unit_price, c.category_name
    FROM products p
    JOIN categories c ON p.category_id = c.category_id
    WHERE p.unit_price > 100
),
cte2 AS (
    SELECT o.order_id, o.order_date, o.customer_id, c.customer_name, c.city
    FROM orders o
    JOIN customers c ON o.customer_id = c.customer_id
    WHERE o.order_date >= '2021-01-01'
),
cte3 AS (
    SELECT o.order_id, SUM(od.quantity * od.unit_price) AS total_amount
    FROM order_details od
    JOIN orders o ON od.order_id = o.order_id
    GROUP BY o.order_id
    HAVING total_amount > 5000
),
cte4 AS (
    SELECT p.product_id, p.product_name, COUNT(*) AS total_orders
    FROM products p
    JOIN order_details od ON p.product_id = od.product_id
    GROUP BY p.product_id
    HAVING total_orders > 10
),
cte5 AS (
    SELECT c.customer_id, c.customer_name, COUNT(*) AS total_orders
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    GROUP BY c.customer_id
    HAVING total_orders > 5
),
cte6 AS (
    SELECT c.customer_id, c.customer_name, SUM(o.total_amount) AS total_spent
    FROM customers c
    JOIN cte3 o ON c.customer_id = o.customer_id
    GROUP BY c.customer_id
    HAVING total_spent > 10000
)
SELECT cte1.product_name, cte1.unit_price, cte1.category_name, cte2.order_date, cte2.customer_name, cte2.city,
    cte3.total_amount, cte4.total_orders, cte5.total_orders, cte6.total_spent
FROM cte1
JOIN cte2 ON cte1.product_id = cte2.product_id
JOIN cte3 ON cte2.order_id = cte3.order_id
JOIN cte4 ON cte1.product_id = cte4.product_id
JOIN cte5 ON cte2.customer_id = cte5.customer_id
JOIN cte6 ON cte2.customer_id = cte6.customer_id
ORDER BY cte1.product_name ASC, cte2.order_date DESC;",318,516,834,"['products', 'categories', 'orders', 'customers', 'order_details']","['products', 'categories', 'orders', 'customers', 'order_details']","['products', 'categories', 'orders', 'customers', 'order_details']","['products', 'categories', 'orders', 'customers', 'order_details']"
7,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a retail company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_sales AS (
  SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    p.product_name,
    p.category,
    p.unit_price,
    p.quantity
  FROM
    sales.orders o
  JOIN
    sales.customers c ON o.customer_id = c.customer_id
  JOIN
    sales.order_items oi ON o.order_id = oi.order_id
  JOIN
    sales.products p ON oi.product_id = p.product_id
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
    AND p.category IN ('Electronics', 'Clothing')
),
cte_category_sales AS (
  SELECT
    category,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    category
),
cte_top_customers AS (
  SELECT
    customer_id,
    customer_name,
    SUM(total_price) AS total_spent
  FROM
    cte_sales
  GROUP BY
    customer_id,
    customer_name
  HAVING
    total_spent > (
      SELECT
        AVG(total_spent)
      FROM
        cte_top_customers
    )
),
cte_monthly_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    SUM(total_price) AS monthly_revenue
  FROM
    cte_sales
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m')
),
cte_product_sales AS (
  SELECT
    product_name,
    COUNT(DISTINCT order_id) AS unique_orders,
    SUM(quantity) AS total_quantity
  FROM
    cte_sales
  GROUP BY
    product_name
),
cte_category_summary AS (
  SELECT
    category,
    COUNT(DISTINCT product_name) AS unique_products,
    SUM(total_quantity) AS total_quantity
  FROM
    cte_product_sales
  GROUP BY
    category
)
SELECT
  c.category,
  c.unique_products,
  c.total_quantity,
  cs.total_sales,
  tc.customer_name,
  ms.month,
  ms.monthly_revenue
FROM
  cte_category_summary c
JOIN
  cte_category_sales cs ON c.category = cs.category
JOIN
  cte_top_customers tc ON c.category = tc.customer_id
CROSS JOIN
  cte_monthly_sales ms
ORDER BY
  c.category ASC,
  ms.month ASC;",318,532,850,"['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']"
8,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an entertainment company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(p.price) AS total_revenue,
    AVG(DATEDIFF(o.order_date, c.date_of_birth)) AS avg_age_at_purchase,
    CONCAT(e.first_name, ' ', e.last_name) AS employee_name,
    COUNT(DISTINCT e.employee_id) AS total_employees,
    SUM(DATEDIFF(o.order_date, e.date_of_hire)) AS total_days_worked,
    CONCAT(m.first_name, ' ', m.last_name) AS manager_name,
    COUNT(DISTINCT m.employee_id) AS total_managers,
    SUM(DATEDIFF(o.order_date, m.date_of_hire)) AS total_days_managed
FROM
    entertainment.company.customer AS c
    JOIN entertainment.company.orders AS o ON c.customer_id = o.customer_id
    JOIN entertainment.company.products AS p ON o.product_id = p.product_id
    JOIN entertainment.company.employees AS e ON o.employee_id = e.employee_id
    JOIN entertainment.company.employees AS m ON e.manager_id = m.employee_id
WHERE
    c.date_of_birth <= DATE_SUB(CURDATE(), INTERVAL 18 YEAR)
    AND o.order_date >= '2020-01-01'
    AND p.category IN ('Movies', 'Concerts')
    AND e.date_of_hire >= '2019-01-01'
GROUP BY
    c.customer_id,
    e.employee_id,
    m.employee_id
HAVING
    total_orders > 5
    AND total_revenue > 10000
    AND avg_age_at_purchase < 40
    AND total_days_worked > 365
    AND total_days_managed > 730
ORDER BY
    total_revenue DESC,
    total_orders ASC
LIMIT 10;",316,384,700,"['entertainment.company.customer', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.employees']","['entertainment.company.customer', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.employees']","['entertainment.company.customer', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.employees']","['entertainment.company.customer', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.employees']"
9,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(cust.first_name, ' ', cust.last_name) AS customer_name,
    cust.email AS customer_email,
    orders.order_date AS order_date,
    products.product_name AS product_name,
    SUM(orders.quantity * products.unit_price) AS total_sales
FROM 
    energy_company.customers AS cust
JOIN 
    energy_company.orders AS orders ON cust.customer_id = orders.customer_id
JOIN 
    energy_company.products AS products ON orders.product_id = products.product_id
JOIN 
    energy_company.suppliers AS suppliers ON products.supplier_id = suppliers.supplier_id
JOIN 
    energy_company.locations AS locations ON suppliers.location_id = locations.location_id
WHERE 
    orders.order_date >= DATE_FORMAT(CURRENT_DATE(), '%Y-%m-01')
    AND orders.order_date < DATE_FORMAT(CURRENT_DATE(), '%Y-%m-01') + INTERVAL 1 MONTH
    AND locations.country = 'United States'
GROUP BY 
    customer_name,
    customer_email,
    order_date,
    product_name
HAVING 
    total_sales > 10000
CROSS JOIN 
    (SELECT 
        AVG(total_sales) AS avg_sales
    FROM 
        (SELECT 
            CONCAT(cust.first_name, ' ', cust.last_name) AS customer_name,
            cust.email AS customer_email,
            orders.order_date AS order_date,
            products.product_name AS product_name,
            SUM(orders.quantity * products.unit_price) AS total_sales
        FROM 
            energy_company.customers AS cust
        JOIN 
            energy_company.orders AS orders ON cust.customer_id = orders.customer_id
        JOIN 
            energy_company.products AS products ON orders.product_id = products.product_id
        JOIN 
            energy_company.suppliers AS suppliers ON products.supplier_id = suppliers.supplier_id
        JOIN 
            energy_company.locations AS locations ON suppliers.location_id = locations.location_id
        WHERE 
            orders.order_date >= DATE_FORMAT(CURRENT_DATE(), '%Y-%m-01')
            AND orders.order_date < DATE_FORMAT(CURRENT_DATE(), '%Y-%m-01') + INTERVAL 1 MONTH
            AND locations.country = 'United States'
        GROUP BY 
            customer_name,
            customer_email,
            order_date,
            product_name) AS subquery) AS avg_sales_info;",329,469,798,"['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.suppliers', 'energy_company.locations']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.suppliers', 'energy_company.locations']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.suppliers', 'energy_company.locations']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.suppliers', 'energy_company.locations']"
10,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an entertainment company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    o.order_id,
    o.order_date,
    o.order_total
  FROM
    entertainment.orders o
  JOIN
    entertainment.customers c ON o.customer_id = c.customer_id
  WHERE
    o.order_status = 'completed'
    AND DATE_FORMAT(o.order_date, '%Y-%m') = '2022-01'
),
subquery1 AS (
  SELECT
    cte.customer_name,
    COUNT(DISTINCT cte.order_id) AS total_orders,
    SUM(cte.order_total) AS total_sales
  FROM
    cte
  GROUP BY
    cte.customer_name
  HAVING
    total_orders > 1
),
subquery2 AS (
  SELECT
    cte.customer_name,
    COUNT(DISTINCT cte.order_id) AS total_orders,
    SUM(cte.order_total) AS total_sales
  FROM
    cte
  GROUP BY
    cte.customer_name
  HAVING
    total_orders = 1
)
SELECT
  subquery1.customer_name,
  subquery1.total_orders,
  subquery1.total_sales,
  subquery2.total_orders AS single_orders,
  subquery2.total_sales AS single_sales
FROM
  subquery1
JOIN
  subquery2 ON subquery1.customer_name = subquery2.customer_name
ORDER BY
  subquery1.total_sales DESC
LIMIT
  10;",315,320,635,"['entertainment.orders', 'entertainment.customers']","['entertainment.orders', 'entertainment.customers']","['entertainment.orders', 'entertainment.customers']","['entertainment.orders', 'entertainment.customers']"
11,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.first_name, ' ', p.last_name) AS patient_name,
    CONCAT(d.first_name, ' ', d.last_name) AS doctor_name,
    a.appointment_date,
    a.appointment_time,
    v.visit_date,
    v.visit_time,
    m.medication_name,
    m.dosage,
    m.frequency,
    m.start_date,
    m.end_date,
    CONCAT(ph.first_name, ' ', ph.last_name) AS pharmacist_name,
    CONCAT(n.first_name, ' ', n.last_name) AS nurse_name,
    CONCAT(l.first_name, ' ', l.last_name) AS lab_technician_name,
    CONCAT(r.first_name, ' ', r.last_name) AS radiologist_name,
    CONCAT(s.first_name, ' ', s.last_name) AS surgeon_name,
    CONCAT(an.first_name, ' ', an.last_name) AS anesthesiologist_name,
    CONCAT(pt.first_name, ' ', pt.last_name) AS physical_therapist_name,
    CONCAT(ot.first_name, ' ', ot.last_name) AS occupational_therapist_name,
    CONCAT(st.first_name, ' ', st.last_name) AS speech_therapist_name,
    CONCAT(ps.first_name, ' ', ps.last_name) AS psychiatrist_name,
    CONCAT(c.first_name, ' ', c.last_name) AS counselor_name,
    CONCAT(phd.first_name, ' ', phd.last_name) AS psychologist_name,
    CONCAT(su.first_name, ' ', su.last_name) AS surgeon_assistant_name,
    CONCAT(nu.first_name, ' ', nu.last_name) AS nurse_assistant_name,
    CONCAT(la.first_name, ' ', la.last_name) AS lab_assistant_name,
    CONCAT(ra.first_name, ' ', ra.last_name) AS radiology_assistant_name,
    CONCAT(pa.first_name, ' ', pa.last_name) AS patient_assistant_name,
    CONCAT(pha.first_name, ' ', pha.last_name) AS pharmacist_assistant_name,
    CONCAT(ad.first_name, ' ', ad.last_name) AS admin_name,
    CONCAT(b.first_name, ' ', b.last_name) AS billing_name,
    CONCAT(f.first_name, ' ', f.last_name) AS finance_name,
    CONCAT(h.first_name, ' ', h.last_name) AS hr_name,
    CONCAT(it.first_name, ' ', it.last_name) AS it_name,
    CONCAT(ma.first_name, ' ', ma.last_name) AS marketing_name,
    CONCAT(op.first_name, ' ', op.last_name) AS operations_name,
    CONCAT(pr.first_name, ' ', pr.last_name) AS procurement_name,
    CONCAT(qa.first_name, ' ', qa.last_name) AS quality_assurance_name,
    CONCAT(re.first_name, ' ', re.last_name) AS research_name,
    CONCAT(se.first_name, ' ', se.last_name) AS security_name,
    CONCAT(tr.first_name, ' ', tr.last_name) AS training_name,
    CONCAT(ve.first_name, ' ', ve.last_name) AS vendor_name
FROM
    healthcare.patients AS p
        CROSS JOIN
    healthcare.doctors AS d
        ON p.doctor_id = d.doctor_id
        CROSS JOIN
    healthcare.appointments AS a
        ON p.patient_id = a.patient_id
        CROSS JOIN
    healthcare.visits AS v
        ON p.patient_id = v.patient_id
        CROSS JOIN
    healthcare.medications AS m
        ON p.patient_id = m.patient_id
        CROSS JOIN
    healthcare.pharmacists AS ph
        ON m.pharmacist_id = ph.pharmacist_id
        CROSS JOIN
    healthcare.nurses AS n
        ON v.nurse_id = n.nurse_id
        CROSS JOIN
    healthcare.lab_technicians AS l
        ON v.lab_technician_id = l.lab_technician_id
        CROSS JOIN
    healthcare.radiologists AS r
        ON v.radiologist_id = r.radiologist_id
        CROSS JOIN
    healthcare.surgeons AS s
        ON v.surgeon_id = s.surgeon_id
        CROSS JOIN
    healthcare.anesthesiologists AS an
        ON v.anesthesiologist_id = an.anesthesiologist_id
        CROSS JOIN
    healthcare.physical_therapists AS pt
        ON v.physical_therapist_id = pt.physical_therapist_id
        CROSS JOIN
    healthcare.occupational_therapists AS ot
        ON v.occupational_therapist_id = ot.occupational_therapist_id
        CROSS JOIN
    healthcare.speech_therapists AS st
        ON v.speech_therapist_id = st.speech_therapist_id
        CROSS JOIN
    healthcare.psychiatrists AS ps
        ON v.psychiatrist_id = ps.psychiatrist_id
        CROSS JOIN
    healthcare.counselors AS c
        ON v.counselor_id = c.counselor_id
        CROSS JOIN
    healthcare.psychologists AS phd
        ON v.psychologist_id = phd.psychologist_id
        CROSS JOIN
    healthcare.surgeon_assistants AS su
        ON v.surgeon_assistant_id = su.surgeon_assistant_id
        CROSS JOIN
    healthcare.nurse_assistants AS nu
        ON v.nurse_assistant_id = nu.nurse_assistant_id
        CROSS JOIN
    healthcare.lab_assistants AS la
        ON v.lab_assistant_id = la.lab_assistant_id
        CROSS JOIN
    healthcare.radiology_assistants AS ra
        ON v.radiology_assistant_id = ra.radiology_assistant_id
        CROSS JOIN
    healthcare.patient_assistants AS pa
        ON v.patient_assistant_id = pa.patient_assistant_id
        CROSS JOIN
    healthcare.pharmacist_assistants AS pha
        ON v.pharmacist_assistant_id = pha.pharmacist_assistant_id
        CROSS JOIN
    healthcare.admins AS ad
        ON v.admin_id = ad.admin_id
        CROSS JOIN
    healthcare.billings AS b
        ON v.billing_id = b.billing_id
        CROSS JOIN
    healthcare.finances AS f
        ON v.finance_id = f.finance_id
        CROSS JOIN
    healthcare.hrs AS h
        ON v.hr_id = h.hr_id
        CROSS JOIN
    healthcare.its AS it
        ON v.it_id = it.it_id
        CROSS JOIN
    healthcare.marketings AS ma
        ON v.marketing_id = ma.marketing_id
        CROSS JOIN
    healthcare.operations AS op
        ON v.operations_id = op.operations_id
        CROSS JOIN
    healthcare.procurements AS pr
        ON v.procurement_id = pr.procurement_id
        CROSS JOIN
    healthcare.quality_assurances AS qa
        ON v.quality_assurance_id = qa.quality_assurance_id
        CROSS JOIN
    healthcare.research AS re
        ON v.research_id = re.research_id
        CROSS JOIN
    healthcare.security AS se
        ON v.security_id = se.security_id
        CROSS JOIN
    healthcare.training AS tr
        ON v.training_id = tr.training_id
        CROSS JOIN
    healthcare.vendors AS ve
        ON v.vendor_id = ve.vendor_id
WHERE
    p.age >= 18
        AND v.visit_date >= '2022-01-01'
        AND m.start_date <= '2022-12-31'
GROUP BY p.patient_id , d.doctor_id , a.appointment_id , v.visit_id , m.medication_id , ph.pharmacist_id , n.nurse_id , l.lab_technician_id , r.radiologist_id , s.surgeon_id , an.anesthesiologist_id , pt.physical_therapist_id , ot.occupational_therapist_id , st.speech_therapist_id , ps.psychiatrist_id , c.counselor_id , phd.psychologist_id , su.surgeon_assistant_id , nu.nurse_assistant_id , la.lab_assistant_id , ra.radiology_assistant_id , pa.patient_assistant_id , pha.pharmacist_assistant_id , ad.admin_id , b.billing_id , f.finance_id , h.hr_id , it.it_id , ma.marketing_id , op.operations_id , pr.procurement_id , qa.quality_assurance_id , re.research_id , se.security_id , tr.training_id , ve.vendor_id
HAVING
    COUNT(DISTINCT v.visit_id) > 1
        AND SUM(m.dosage) > 1000
        AND AVG(v.visit_duration) > 30;",322,1811,2133,"['healthcare.patients', 'healthcare.doctors', 'healthcare.appointments', 'healthcare.visits', 'healthcare.medications', 'healthcare.pharmacists', 'healthcare.nurses', 'healthcare.lab_technicians', 'healthcare.radiologists', 'healthcare.surgeons', 'heal... 'healthcare.psychologists', 'healthcare.surgeon_assistants', 'healthcare.nurse_assistants', 'healthcare.lab_assistants', 'healthcare.radiology_assistants', 'healthcare.patient_assistants', 'healthcare.pharmacist_assistants', 'healthcare.admins', ...]","['healthcare.patients', 'healthcare.doctors', 'healthcare.appointments', 'healthcare.visits', 'healthcare.medications', 'healthcare.pharmacists', 'healthcare.nurses', 'healthcare.lab_technicians', 'healthcare.radiologists', 'healthcare.surgeons', 'heal... 'healthcare.psychologists', 'healthcare.surgeon_assistants', 'healthcare.nurse_assistants', 'healthcare.lab_assistants', 'healthcare.radiology_assistants', 'healthcare.patient_assistants', 'healthcare.pharmacist_assistants', 'healthcare.admins', ...]","['healthcare.patients', 'healthcare.doctors', 'healthcare.appointments', 'healthcare.visits', 'healthcare.medications', 'healthcare.pharmacists', 'healthcare.nurses', 'healthcare.lab_technicians', 'healthcare.radiologists', 'healthcare.surgeons', 'heal... 'healthcare.psychologists', 'healthcare.surgeon_assistants', 'healthcare.nurse_assistants', 'healthcare.lab_assistants', 'healthcare.radiology_assistants', 'healthcare.patient_assistants', 'healthcare.pharmacist_assistants', 'healthcare.admins', ...]","['healthcare.patients', 'healthcare.doctors', 'healthcare.appointments', 'healthcare.visits', 'healthcare.medications', 'healthcare.pharmacists', 'healthcare.nurses', 'healthcare.lab_technicians', 'healthcare.radiologists', 'healthcare.surgeons', 'heal... 'healthcare.psychologists', 'healthcare.surgeon_assistants', 'healthcare.nurse_assistants', 'healthcare.lab_assistants', 'healthcare.radiology_assistants', 'healthcare.patient_assistants', 'healthcare.pharmacist_assistants', 'healthcare.admins', ...]"
12,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a marketing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    o.order_id,
    o.order_date,
    o.total_price
  FROM
    marketing.customers c
  JOIN
    sales.orders o ON c.customer_id = o.customer_id
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

cte2 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  GROUP BY
    customer_name
  HAVING
    total_sales > 10000
),

cte3 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS repeat_orders
  FROM
    cte1
  WHERE
    order_date < '2021-06-30'
  GROUP BY
    customer_name
),

cte4 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS new_orders
  FROM
    cte1
  WHERE
    order_date >= '2021-06-30'
  GROUP BY
    customer_name
),

cte5 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-12'
  GROUP BY
    customer_name
),

cte6 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-11'
  GROUP BY
    customer_name
),

cte7 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-10'
  GROUP BY
    customer_name
),

cte8 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-09'
  GROUP BY
    customer_name
),

cte9 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-08'
  GROUP BY
    customer_name
),

cte10 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-07'
  GROUP BY
    customer_name
),

cte11 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-06'
  GROUP BY
    customer_name
),

cte12 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-05'
  GROUP BY
    customer_name
),

cte13 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-04'
  GROUP BY
    customer_name
),

cte14 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-03'
  GROUP BY
    customer_name
),

cte15 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-02'
  GROUP BY
    customer_name
),

cte16 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-01'
  GROUP BY
    customer_name
),

cte17 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  GROUP BY
    customer_name
),

cte18 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%W') = 'Saturday'
  GROUP BY
    customer_name
),

cte19 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%W') = 'Sunday'
  GROUP BY
    customer_name
),

cte20 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%W') = 'Monday'
  GROUP BY
    customer_name
),

cte21 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%W') = 'Tuesday'
  GROUP BY
    customer_name
),

cte22 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%W') = 'Wednesday'
  GROUP BY
    customer_name
),

cte23 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%W') = 'Thursday'
  GROUP BY
    customer_name
),

cte24 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%W') = 'Friday'
  GROUP BY
    customer_name
)

SELECT
  cte1.customer_name,
  cte2.total_orders,
  cte2.total_sales,
  cte3.repeat_orders,
  cte4.new_orders,
  cte5.total_orders AS total_orders_dec,
  cte5.total_sales AS total_sales_dec,
  cte6.total_orders AS total_orders_nov,
  cte6.total_sales AS total_sales_nov,
  cte7.total_orders AS total_orders_oct,
  cte7.total_sales AS total_sales_oct,
  cte8.total_orders AS total_orders_sep,
  cte8.total_sales AS total_sales_sep,
  cte9.total_orders AS total_orders_aug,
  cte9.total_sales AS total_sales_aug,
  cte10.total_orders AS total_orders_jul,
  cte10.total_sales AS total_sales_jul,
  cte11.total_orders AS total_orders_jun,
  cte11.total_sales AS total_sales_jun,
  cte12.total_orders AS total_orders_may,
  cte12.total_sales AS total_sales_may,
  cte13.total_orders AS total_orders_apr,
  cte13.total_sales AS total_sales_apr,
  cte14.total_orders AS total_orders_mar,
  cte14.total_sales AS total_sales_mar,
  cte15.total_orders AS total_orders_feb,
  cte15.total_sales AS total_sales_feb,
  cte16.total_orders AS total_orders_jan,
  cte16.total_sales AS total_sales_jan,
  cte17.total_orders AS total_orders_all,
  cte17.total_sales AS total_sales_all,
  cte18.total_orders AS total_orders_sat,
  cte18.total_sales AS total_sales_sat,
  cte19.total_orders AS total_orders_sun,
  cte19.total_sales AS total_sales_sun,
  cte20.total_orders AS total_orders_mon,
  cte20.total_sales AS total_sales_mon,
  cte21.total_orders AS total_orders_tue,
  cte21.total_sales AS total_sales_tue,
  cte22.total_orders AS total_orders_wed,
  cte22.total_sales AS total_sales_wed,
  cte23.total_orders AS total_orders_thu,
  cte23.total_sales AS total_sales_thu,
  cte24.total_orders AS total_orders_fri,
  cte24.total_sales AS total_sales_fri
FROM
  cte1
LEFT JOIN
  cte2 ON cte1.customer_name = cte2.customer_name
LEFT JOIN
  cte3 ON cte1.customer_name = cte3.customer_name
LEFT JOIN
  cte4 ON cte1.customer_name = cte4.customer_name
LEFT JOIN
  cte5 ON cte1.customer_name = cte5.customer_name
LEFT JOIN
  cte6 ON cte1.customer_name = cte6.customer_name
LEFT JOIN
  cte7 ON cte1.customer_name = cte7.customer_name
LEFT JOIN
  cte8 ON cte1.customer_name = cte8.customer_name
LEFT JOIN
  cte9 ON cte1.customer_name = cte9.customer_name
LEFT JOIN
  cte10 ON cte1.customer_name = cte10.customer_name
LEFT JOIN
  cte11 ON cte1.customer_name = cte11.customer_name
LEFT JOIN
  cte12 ON cte1.customer_name = cte12.customer_name
LEFT JOIN
  cte13 ON cte1.customer_name = cte13.customer_name
LEFT JOIN
  cte14 ON cte1.customer_name = cte14.customer_name
LEFT JOIN
  cte15 ON cte1.customer_name = cte15.customer_name
LEFT JOIN
  cte16 ON cte1.customer_name = cte16.customer_name
LEFT JOIN
  cte17 ON cte1.customer_name = cte17.customer_name
LEFT JOIN
  cte18 ON cte1.customer_name = cte18.customer_name
LEFT JOIN
  cte19 ON cte1.customer_name = cte19.customer_name
LEFT JOIN
  cte20 ON cte1.customer_name = cte20.customer_name
LEFT JOIN
  cte21 ON cte1.customer_name = cte21.customer_name
LEFT JOIN
  cte22 ON cte1.customer_name = cte22.customer_name
LEFT JOIN
  cte23 ON cte1.customer_name = cte23.customer_name
LEFT JOIN
  cte24 ON cte1.customer_name = cte24.customer_name
ORDER BY
  cte1.customer_name;",315,2612,2927,"['marketing.customers', 'sales.orders']","['marketing.customers', 'sales.orders']","['marketing.customers', 'sales.orders']","['marketing.customers', 'sales.orders']"
13,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a retail company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.unit_price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.unit_price) AS total_sales
FROM
    retail_db.customers c
JOIN
    retail_db.orders o ON c.customer_id = o.customer_id
JOIN
    retail_db.order_products op ON o.order_id = op.order_id
JOIN
    retail_db.products p ON op.product_id = p.product_id
JOIN
    retail_db.categories cat ON p.category_id = cat.category_id
JOIN
    retail_db.suppliers s ON p.supplier_id = s.supplier_id
WHERE
    cat.category_name = 'Electronics'
    AND s.country = 'United States'
    AND o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
GROUP BY
    c.customer_id,
    o.order_id,
    p.product_id
HAVING
    total_sales > 1000
ORDER BY
    total_sales DESC;",328,247,575,"['retail_db.customers', 'retail_db.orders', 'retail_db.order_products', 'retail_db.products', 'retail_db.categories', 'retail_db.suppliers']","['retail_db.customers', 'retail_db.orders', 'retail_db.order_products', 'retail_db.products', 'retail_db.categories', 'retail_db.suppliers']","['retail_db.customers', 'retail_db.orders', 'retail_db.order_products', 'retail_db.products', 'retail_db.categories', 'retail_db.suppliers']","['retail_db.customers', 'retail_db.orders', 'retail_db.order_products', 'retail_db.products', 'retail_db.categories', 'retail_db.suppliers']"
14,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a marketing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    o.order_id,
    o.order_date,
    o.total_price
  FROM
    marketing.customers AS c
  JOIN
    marketing.orders AS o ON c.customer_id = o.customer_id
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

cte2 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  GROUP BY
    customer_name
  HAVING
    total_sales > 1000
),

cte3 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS repeat_orders
  FROM
    cte1
  WHERE
    order_date < '2021-06-30'
  GROUP BY
    customer_name
),

cte4 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS new_orders
  FROM
    cte1
  WHERE
    order_date >= '2021-06-30'
  GROUP BY
    customer_name
),

cte5 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  GROUP BY
    customer_name
),

cte6 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-12'
  GROUP BY
    customer_name
),

cte7 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-11'
  GROUP BY
    customer_name
),

cte8 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-10'
  GROUP BY
    customer_name
),

cte9 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-09'
  GROUP BY
    customer_name
),

cte10 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-08'
  GROUP BY
    customer_name
),

cte11 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-07'
  GROUP BY
    customer_name
),

cte12 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-06'
  GROUP BY
    customer_name
),

cte13 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-05'
  GROUP BY
    customer_name
),

cte14 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-04'
  GROUP BY
    customer_name
),

cte15 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-03'
  GROUP BY
    customer_name
),

cte16 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-02'
  GROUP BY
    customer_name
),

cte17 AS (
  SELECT
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte1
  WHERE
    DATE_FORMAT(order_date, '%Y-%m') = '2021-01'
  GROUP BY
    customer_name
)

SELECT
  cte2.customer_name,
  cte2.total_orders,
  cte2.total_sales,
  cte3.repeat_orders,
  cte4.new_orders,
  cte5.total_orders AS overall_total_orders,
  cte5.total_sales AS overall_total_sales,
  cte6.total_orders AS dec_total_orders,
  cte6.total_sales AS dec_total_sales,
  cte7.total_orders AS nov_total_orders,
  cte7.total_sales AS nov_total_sales,
  cte8.total_orders AS oct_total_orders,
  cte8.total_sales AS oct_total_sales,
  cte9.total_orders AS sep_total_orders,
  cte9.total_sales AS sep_total_sales,
  cte10.total_orders AS aug_total_orders,
  cte10.total_sales AS aug_total_sales,
  cte11.total_orders AS jul_total_orders,
  cte11.total_sales AS jul_total_sales,
  cte12.total_orders AS jun_total_orders,
  cte12.total_sales AS jun_total_sales,
  cte13.total_orders AS may_total_orders,
  cte13.total_sales AS may_total_sales,
  cte14.total_orders AS apr_total_orders,
  cte14.total_sales AS apr_total_sales,
  cte15.total_orders AS mar_total_orders,
  cte15.total_sales AS mar_total_sales,
  cte16.total_orders AS feb_total_orders,
  cte16.total_sales AS feb_total_sales,
  cte17.total_orders AS jan_total_orders,
  cte17.total_sales AS jan_total_sales
FROM
  cte2
JOIN
  cte3 ON cte2.customer_name = cte3.customer_name
JOIN
  cte4 ON cte2.customer_name = cte4.customer_name
JOIN
  cte5 ON cte2.customer_name = cte5.customer_name
JOIN
  cte6 ON cte2.customer_name = cte6.customer_name
JOIN
  cte7 ON cte2.customer_name = cte7.customer_name
JOIN
  cte8 ON cte2.customer_name = cte8.customer_name
JOIN
  cte9 ON cte2.customer_name = cte9.customer_name
JOIN
  cte10 ON cte2.customer_name = cte10.customer_name
JOIN
  cte11 ON cte2.customer_name = cte11.customer_name
JOIN
  cte12 ON cte2.customer_name = cte12.customer_name
JOIN
  cte13 ON cte2.customer_name = cte13.customer_name
JOIN
  cte14 ON cte2.customer_name = cte14.customer_name
JOIN
  cte15 ON cte2.customer_name = cte15.customer_name
JOIN
  cte16 ON cte2.customer_name = cte16.customer_name
JOIN
  cte17 ON cte2.customer_name = cte17.customer_name
ORDER BY
  cte2.total_sales DESC;",315,1804,2119,"['marketing.customers', 'marketing.orders']","['marketing.customers', 'marketing.orders']","['marketing.customers', 'marketing.orders']","['marketing.customers', 'marketing.orders']"
15,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT property_id, COUNT(*) AS num_listings
  FROM real_estate.listings
  WHERE status = 'active'
  GROUP BY property_id
  HAVING COUNT(*) > 5
),
cte2 AS (
  SELECT property_id, AVG(price) AS avg_price
  FROM real_estate.listings
  WHERE status = 'active'
  GROUP BY property_id
),
cte3 AS (
  SELECT property_id, MAX(price) AS max_price
  FROM real_estate.listings
  WHERE status = 'active'
  GROUP BY property_id
),
cte4 AS (
  SELECT property_id, MIN(price) AS min_price
  FROM real_estate.listings
  WHERE status = 'active'
  GROUP BY property_id
),
cte5 AS (
  SELECT property_id, COUNT(*) AS num_sales
  FROM real_estate.sales
  WHERE status = 'closed'
  GROUP BY property_id
),
cte6 AS (
  SELECT property_id, SUM(price) AS total_sales
  FROM real_estate.sales
  WHERE status = 'closed'
  GROUP BY property_id
),
cte7 AS (
  SELECT property_id, AVG(price) AS avg_sale_price
  FROM real_estate.sales
  WHERE status = 'closed'
  GROUP BY property_id
),
cte8 AS (
  SELECT property_id, MAX(price) AS max_sale_price
  FROM real_estate.sales
  WHERE status = 'closed'
  GROUP BY property_id
),
cte9 AS (
  SELECT property_id, MIN(price) AS min_sale_price
  FROM real_estate.sales
  WHERE status = 'closed'
  GROUP BY property_id
),
cte10 AS (
  SELECT property_id, COUNT(*) AS num_rentals
  FROM real_estate.rentals
  WHERE status = 'active'
  GROUP BY property_id
),
cte11 AS (
  SELECT property_id, AVG(price) AS avg_rental_price
  FROM real_estate.rentals
  WHERE status = 'active'
  GROUP BY property_id
),
cte12 AS (
  SELECT property_id, MAX(price) AS max_rental_price
  FROM real_estate.rentals
  WHERE status = 'active'
  GROUP BY property_id
),
cte13 AS (
  SELECT property_id, MIN(price) AS min_rental_price
  FROM real_estate.rentals
  WHERE status = 'active'
  GROUP BY property_id
),
cte14 AS (
  SELECT property_id, COUNT(*) AS num_inspections
  FROM real_estate.inspections
  WHERE status = 'completed'
  GROUP BY property_id
),
cte15 AS (
  SELECT property_id, AVG(score) AS avg_inspection_score
  FROM real_estate.inspections
  WHERE status = 'completed'
  GROUP BY property_id
),
cte16 AS (
  SELECT property_id, MAX(score) AS max_inspection_score
  FROM real_estate.inspections
  WHERE status = 'completed'
  GROUP BY property_id
),
cte17 AS (
  SELECT property_id, MIN(score) AS min_inspection_score
  FROM real_estate.inspections
  WHERE status = 'completed'
  GROUP BY property_id
),
cte18 AS (
  SELECT property_id, COUNT(*) AS num_applications
  FROM real_estate.applications
  WHERE status = 'submitted'
  GROUP BY property_id
),
cte19 AS (
  SELECT property_id, COUNT(*) AS num_tenants
  FROM real_estate.tenants
  WHERE status = 'active'
  GROUP BY property_id
),
cte20 AS (
  SELECT property_id, COUNT(*) AS num_vacancies
  FROM real_estate.vacancies
  WHERE status = 'available'
  GROUP BY property_id
),
cte21 AS (
  SELECT property_id, COUNT(*) AS num_contracts
  FROM real_estate.contracts
  WHERE status = 'active'
  GROUP BY property_id
),
cte22 AS (
  SELECT property_id, COUNT(*) AS num_payments
  FROM real_estate.payments
  WHERE status = 'completed'
  GROUP BY property_id
),
cte23 AS (
  SELECT property_id, SUM(amount) AS total_payments
  FROM real_estate.payments
  WHERE status = 'completed'
  GROUP BY property_id
),
cte24 AS (
  SELECT property_id, AVG(amount) AS avg_payment_amount
  FROM real_estate.payments
  WHERE status = 'completed'
  GROUP BY property_id
),
cte25 AS (
  SELECT property_id, MAX(amount) AS max_payment_amount
  FROM real_estate.payments
  WHERE status = 'completed'
  GROUP BY property_id
),
cte26 AS (
  SELECT property_id, MIN(amount) AS min_payment_amount
  FROM real_estate.payments
  WHERE status = 'completed'
  GROUP BY property_id
),
cte27 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_requests
  FROM real_estate.maintenance_requests
  WHERE status = 'open'
  GROUP BY property_id
),
cte28 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed
  FROM real_estate.maintenance_requests
  WHERE status = 'completed'
  GROUP BY property_id
),
cte29 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_in_progress
  FROM real_estate.maintenance_requests
  WHERE status = 'in_progress'
  GROUP BY property_id
),
cte30 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_cancelled
  FROM real_estate.maintenance_requests
  WHERE status = 'cancelled'
  GROUP BY property_id
),
cte31 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_approved
  FROM real_estate.maintenance_requests
  WHERE status = 'approved'
  GROUP BY property_id
),
cte32 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_rejected
  FROM real_estate.maintenance_requests
  WHERE status = 'rejected'
  GROUP BY property_id
),
cte33 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_on_hold
  FROM real_estate.maintenance_requests
  WHERE status = 'on_hold'
  GROUP BY property_id
),
cte34 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_assigned
  FROM real_estate.maintenance_requests
  WHERE status = 'assigned'
  GROUP BY property_id
),
cte35 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_unassigned
  FROM real_estate.maintenance_requests
  WHERE status = 'unassigned'
  GROUP BY property_id
),
cte36 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_scheduled
  FROM real_estate.maintenance_requests
  WHERE status = 'scheduled'
  GROUP BY property_id
),
cte37 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_rescheduled
  FROM real_estate.maintenance_requests
  WHERE status = 'rescheduled'
  GROUP BY property_id
),
cte38 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_late
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND completion_date > due_date
  GROUP BY property_id
),
cte39 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_early
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND completion_date < due_date
  GROUP BY property_id
),
cte40 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_on_time
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND completion_date = due_date
  GROUP BY property_id
),
cte41 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_24h
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(HOUR, request_date, completion_date) <= 24
  GROUP BY property_id
),
cte42 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_48h
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(HOUR, request_date, completion_date) <= 48
  GROUP BY property_id
),
cte43 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_72h
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(HOUR, request_date, completion_date) <= 72
  GROUP BY property_id
),
cte44 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_1w
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(DAY, request_date, completion_date) <= 7
  GROUP BY property_id
),
cte45 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_2w
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(DAY, request_date, completion_date) <= 14
  GROUP BY property_id
),
cte46 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_1m
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(MONTH, request_date, completion_date) <= 1
  GROUP BY property_id
),
cte47 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_3m
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(MONTH, request_date, completion_date) <= 3
  GROUP BY property_id
),
cte48 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_6m
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(MONTH, request_date, completion_date) <= 6
  GROUP BY property_id
),
cte49 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_1y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 1
  GROUP BY property_id
),
cte50 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_2y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 2
  GROUP BY property_id
),
cte51 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_5y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 5
  GROUP BY property_id
),
cte52 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_10y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 10
  GROUP BY property_id
),
cte53 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_20y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 20
  GROUP BY property_id
),
cte54 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_50y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 50
  GROUP BY property_id
),
cte55 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_100y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 100
  GROUP BY property_id
),
cte56 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_200y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 200
  GROUP BY property_id
),
cte57 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_500y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 500
  GROUP BY property_id
),
cte58 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_1000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 1000
  GROUP BY property_id
),
cte59 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_2000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 2000
  GROUP BY property_id
),
cte60 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_5000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 5000
  GROUP BY property_id
),
cte61 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_10000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 10000
  GROUP BY property_id
),
cte62 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_20000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 20000
  GROUP BY property_id
),
cte63 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_50000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 50000
  GROUP BY property_id
),
cte64 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_100000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 100000
  GROUP BY property_id
),
cte65 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_200000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 200000
  GROUP BY property_id
),
cte66 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_500000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 500000
  GROUP BY property_id
),
cte67 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_1000000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 1000000
  GROUP BY property_id
),
cte68 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_2000000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 2000000
  GROUP BY property_id
),
cte69 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_5000000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 5000000
  GROUP BY property_id
),
cte70 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_10000000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 10000000
  GROUP BY property_id
),
cte71 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_20000000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 20000000
  GROUP BY property_id
),
cte72 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_50000000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 50000000
  GROUP BY property_id
),
cte73 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_100000000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 100000000
  GROUP BY property_id
),
cte74 AS (
  SELECT property_id, COUNT(*) AS num_maintenance_completed_within_200000000y
  FROM real_estate.maintenance_requests
  WHERE status = 'completed' AND TIMESTAMPDIFF(YEAR, request_date, completion_date) <= 200",326,3772,4098,"[""real_estate.listings"", ""real_estate.sales"", ""real_estate.rentals"", ""real_estate.inspections"", ""real_estate.applications"", ""real_estate.tenants"", ""real_estate.vacancies"", ""real_estate.contracts"", ""real_estate.payments"", ""real_estate.maintenance_requests""]","[""real_estate.listings"", ""real_estate.sales"", ""real_estate.rentals"", ""real_estate.inspections"", ""real_estate.applications"", ""real_estate.tenants"", ""real_estate.vacancies"", ""real_estate.contracts"", ""real_estate.payments"", ""real_estate.maintenance_requests""]","[""real_estate.listings"", ""real_estate.sales"", ""real_estate.rentals"", ""real_estate.inspections"", ""real_estate.applications"", ""real_estate.tenants"", ""real_estate.vacancies"", ""real_estate.contracts"", ""real_estate.payments"", ""real_estate.maintenance_requests""]","[""real_estate.listings"", ""real_estate.sales"", ""real_estate.rentals"", ""real_estate.inspections"", ""real_estate.applications"", ""real_estate.tenants"", ""real_estate.vacancies"", ""real_estate.contracts"", ""real_estate.payments"", ""real_estate.maintenance_requests""]"
16,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH recent_articles AS (
  SELECT a.article_id, a.title, a.author, a.publish_date, c.category_name
  FROM news.articles a
  INNER JOIN news.categories c ON a.category_id = c.category_id
  WHERE a.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)
),
popular_articles AS (
  SELECT ra.article_id, ra.title, ra.author, ra.publish_date, ra.category_name, COUNT(*) AS total_views
  FROM recent_articles ra
  INNER JOIN news.article_views av ON ra.article_id = av.article_id
  GROUP BY ra.article_id, ra.title, ra.author, ra.publish_date, ra.category_name
  HAVING total_views > 1000
),
top_authors AS (
  SELECT pa.author, SUM(pa.total_views) AS total_views
  FROM popular_articles pa
  GROUP BY pa.author
  ORDER BY total_views DESC
  LIMIT 5
)
SELECT pa.title, pa.author, pa.publish_date, pa.category_name, pa.total_views, ta.total_views AS author_total_views
FROM popular_articles pa
LEFT JOIN top_authors ta ON pa.author = ta.author
WHERE pa.publish_date >= '2022-01-01'
ORDER BY pa.publish_date DESC, pa.total_views DESC
LIMIT 10;",318,266,584,"['news.articles', 'news.categories', 'news.article_views']","['news.articles', 'news.categories', 'news.article_views']","['news.articles', 'news.categories', 'news.article_views']","['news.articles', 'news.categories', 'news.article_views']"
17,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_date,
    p.product_name,
    SUM(od.quantity * od.unit_price) AS total_revenue
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_details od ON o.order_id = od.order_id
JOIN 
    products p ON od.product_id = p.product_id
WHERE 
    o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
    AND p.category = 'Electronics'
GROUP BY 
    c.customer_id, o.order_date, p.product_id
HAVING 
    total_revenue > 1000
ORDER BY 
    total_revenue DESC;",314,165,479,"[""customers"", ""orders"", ""order_details"", ""products""]","[""customers"", ""orders"", ""order_details"", ""products""]","[""customers"", ""orders"", ""order_details"", ""products""]","[""customers"", ""orders"", ""order_details"", ""products""]"
18,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(p.price) AS total_sales,
    AVG(r.rating) AS average_rating
FROM 
    real_estate.customers c
JOIN 
    real_estate.orders o ON c.customer_id = o.customer_id
JOIN 
    real_estate.order_items oi ON o.order_id = oi.order_id
JOIN 
    real_estate.products p ON oi.product_id = p.product_id
LEFT JOIN 
    real_estate.reviews r ON p.product_id = r.product_id
WHERE 
    c.city = 'New York'
    AND o.order_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
    AND p.category IN ('Apartment', 'House')
GROUP BY 
    c.customer_id, c.first_name, c.last_name
HAVING 
    total_orders >= 3
ORDER BY 
    total_sales DESC
LIMIT 10;",317,208,525,"['real_estate.customers', 'real_estate.orders', 'real_estate.order_items', 'real_estate.products', 'real_estate.reviews']","['real_estate.customers', 'real_estate.orders', 'real_estate.order_items', 'real_estate.products', 'real_estate.reviews']","['real_estate.customers', 'real_estate.orders', 'real_estate.order_items', 'real_estate.products', 'real_estate.reviews']","['real_estate.customers', 'real_estate.orders', 'real_estate.order_items', 'real_estate.products', 'real_estate.reviews']"
19,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a logistics company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        o.order_id,
        o.order_date,
        o.customer_id,
        o.total_price,
        c.customer_name,
        c.customer_address
    FROM 
        orders o
    INNER JOIN 
        customers c ON o.customer_id = c.customer_id
    WHERE 
        o.order_date >= '2021-01-01'
    GROUP BY 
        o.order_id,
        o.order_date,
        o.customer_id,
        o.total_price,
        c.customer_name,
        c.customer_address
    HAVING 
        SUM(o.total_price) > 1000
), cte2 AS (
    SELECT 
        cte1.order_id,
        cte1.order_date,
        cte1.customer_id,
        cte1.total_price,
        cte1.customer_name,
        cte1.customer_address,
        p.product_name,
        p.product_price
    FROM 
        cte1
    LEFT JOIN 
        order_items oi ON cte1.order_id = oi.order_id
    INNER JOIN 
        products p ON oi.product_id = p.product_id
    WHERE 
        p.product_price > 50
    GROUP BY 
        cte1.order_id,
        cte1.order_date,
        cte1.customer_id,
        cte1.total_price,
        cte1.customer_name,
        cte1.customer_address,
        p.product_name,
        p.product_price
), cte3 AS (
    SELECT 
        cte2.order_id,
        cte2.order_date,
        cte2.customer_id,
        cte2.total_price,
        cte2.customer_name,
        cte2.customer_address,
        cte2.product_name,
        cte2.product_price,
        COUNT(DISTINCT cte2.product_name) AS distinct_products
    FROM 
        cte2
    GROUP BY 
        cte2.order_id,
        cte2.order_date,
        cte2.customer_id,
        cte2.total_price,
        cte2.customer_name,
        cte2.customer_address,
        cte2.product_name,
        cte2.product_price
    HAVING 
        COUNT(DISTINCT cte2.product_name) > 2
)
SELECT 
    cte3.order_id,
    DATE_FORMAT(cte3.order_date, '%Y-%m-%d') AS formatted_order_date,
    cte3.customer_id,
    cte3.customer_name,
    CONCAT(cte3.customer_address, ', ', cte3.customer_name) AS full_address,
    SUM(cte3.total_price) AS total_sales,
    AVG(cte3.product_price) AS average_product_price,
    COUNT(DISTINCT cte3.product_name) AS distinct_products
FROM 
    cte3
GROUP BY 
    cte3.order_id,
    formatted_order_date,
    cte3.customer_id,
    cte3.customer_name,
    full_address
HAVING 
    total_sales > 5000
ORDER BY 
    total_sales DESC;",316,629,945,"['orders', 'customers', 'order_items', 'products']","['orders', 'customers', 'order_items', 'products']","['orders', 'customers', 'order_items', 'products']","['orders', 'customers', 'order_items', 'products']"
20,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    CONCAT(b.bank_name, ' - ', b.branch_name) AS bank_branch,
    SUM(t.amount) AS total_transaction_amount
FROM 
    banking.customers c
JOIN 
    banking.accounts a ON c.customer_id = a.customer_id
JOIN 
    banking.banks b ON a.bank_id = b.bank_id
JOIN 
    (
        SELECT 
            t1.account_id,
            SUM(t1.amount) AS total_amount
        FROM 
            banking.transactions t1
        WHERE 
            t1.transaction_date >= '2021-01-01'
        GROUP BY 
            t1.account_id
        HAVING 
            total_amount > 10000
    ) AS t ON a.account_id = t.account_id
WHERE 
    c.age >= 18
    AND b.country = 'United States'
GROUP BY 
    customer_name,
    a.account_number,
    bank_branch
HAVING 
    COUNT(DISTINCT a.account_id) > 1
ORDER BY 
    total_transaction_amount DESC
LIMIT 10
CROSS JOIN 
    (
        SELECT 
            MAX(total_transaction_amount) AS max_transaction_amount
        FROM 
            (
                SELECT 
                    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
                    a.account_number,
                    CONCAT(b.bank_name, ' - ', b.branch_name) AS bank_branch,
                    SUM(t.amount) AS total_transaction_amount
                FROM 
                    banking.customers c
                JOIN 
                    banking.accounts a ON c.customer_id = a.customer_id
                JOIN 
                    banking.banks b ON a.bank_id = b.bank_id
                JOIN 
                    (
                    SELECT 
                        t1.account_id,
                        SUM(t1.amount) AS total_amount
                    FROM 
                        banking.transactions t1
                    WHERE 
                        t1.transaction_date >= '2021-01-01'
                    GROUP BY 
                        t1.account_id
                    HAVING 
                        total_amount > 10000
                    ) AS t ON a.account_id = t.account_id
                WHERE 
                    c.age >= 18
                    AND b.country = 'United States'
                GROUP BY 
                    customer_name,
                    a.account_number,
                    bank_branch
                HAVING 
                    COUNT(DISTINCT a.account_id) > 1
                ORDER BY 
                    total_transaction_amount DESC
                LIMIT 10
            ) AS subquery
    ) AS max_amount_subquery;",318,521,839,"['banking.customers', 'banking.accounts', 'banking.banks', 'banking.transactions']","['banking.customers', 'banking.accounts', 'banking.banks', 'banking.transactions']","['banking.customers', 'banking.accounts', 'banking.banks', 'banking.transactions']","['banking.customers', 'banking.accounts', 'banking.banks', 'banking.transactions']"
21,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_students AS (
    SELECT s.student_id, s.student_name, s.date_of_birth, s.gender, s.department_id, d.department_name
    FROM <database>.<schema>.students s
    INNER JOIN <database>.<schema>.departments d ON s.department_id = d.department_id
    WHERE s.date_of_birth >= '1995-01-01'
),
cte_courses AS (
    SELECT c.course_id, c.course_name, c.department_id, d.department_name
    FROM <database>.<schema>.courses c
    INNER JOIN <database>.<schema>.departments d ON c.department_id = d.department_id
    WHERE c.course_level = 'Intermediate'
),
cte_enrollments AS (
    SELECT e.student_id, e.course_id, e.enrollment_date, e.grade
    FROM <database>.<schema>.enrollments e
    INNER JOIN cte_students s ON e.student_id = s.student_id
    INNER JOIN cte_courses c ON e.course_id = c.course_id
    WHERE e.enrollment_date >= '2020-01-01'
),
cte_average_grades AS (
    SELECT e.student_id, AVG(e.grade) AS average_grade
    FROM cte_enrollments e
    GROUP BY e.student_id
    HAVING AVG(e.grade) >= 80
),
cte_top_students AS (
    SELECT a.student_id, a.average_grade, s.student_name, s.department_name
    FROM cte_average_grades a
    INNER JOIN cte_students s ON a.student_id = s.student_id
),
cte_department_stats AS (
    SELECT d.department_id, d.department_name, COUNT(DISTINCT s.student_id) AS total_students,
           COUNT(DISTINCT c.course_id) AS total_courses
    FROM <database>.<schema>.departments d
    LEFT JOIN cte_students s ON d.department_id = s.department_id
    LEFT JOIN cte_courses c ON d.department_id = c.department_id
    GROUP BY d.department_id, d.department_name
),
cte_top_department AS (
    SELECT ds.department_id, ds.department_name, ds.total_students, ds.total_courses
    FROM cte_department_stats ds
    WHERE ds.total_students > 100
    ORDER BY ds.total_students DESC
    LIMIT 1
)
SELECT ts.student_name, ts.department_name, ts.average_grade, td.department_name AS top_department
FROM cte_top_students ts
CROSS JOIN cte_top_department td
WHERE ts.department_name = td.department_name;",319,524,843,"['<database>.<schema>.students', '<database>.<schema>.departments', '<database>.<schema>.courses', '<database>.<schema>.enrollments']","['<database>.<schema>.students', '<database>.<schema>.departments', '<database>.<schema>.courses', '<database>.<schema>.enrollments']","['<database>.<schema>.students', '<database>.<schema>.departments', '<database>.<schema>.courses', '<database>.<schema>.enrollments']","['<database>.<schema>.students', '<database>.<schema>.departments', '<database>.<schema>.courses', '<database>.<schema>.enrollments']"
22,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ' ', a.zip_code) AS property_address,
    p.property_type,
    p.bedrooms,
    p.bathrooms,
    p.square_feet,
    p.list_price,
    COUNT(*) AS total_visits,
    SUM(p.list_price) AS total_sales,
    AVG(p.list_price) AS average_price,
    MAX(p.list_price) AS max_price,
    MIN(p.list_price) AS min_price
FROM 
    customers c
JOIN 
    visits v ON c.customer_id = v.customer_id
JOIN 
    properties p ON v.property_id = p.property_id
JOIN 
    agents ag ON p.agent_id = ag.agent_id
JOIN 
    addresses a ON p.address_id = a.address_id
WHERE 
    p.list_price > 100000
    AND p.bedrooms >= 3
    AND p.bathrooms >= 2
    AND p.square_feet >= 1500
    AND ag.agent_name LIKE 'John%'
GROUP BY 
    c.customer_id,
    p.property_id,
    a.address_id,
    p.property_type,
    p.bedrooms,
    p.bathrooms,
    p.square_feet,
    p.list_price
HAVING 
    total_visits > 5
    AND total_sales > 500000
ORDER BY 
    total_sales DESC, 
    average_price ASC
LIMIT 10;",320,313,633,"['customers', 'visits', 'properties', 'agents', 'addresses']","['customers', 'visits', 'properties', 'agents', 'addresses']","['customers', 'visits', 'properties', 'agents', 'addresses']","['customers', 'visits', 'properties', 'agents', 'addresses']"
23,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
         CONCAT(p.patient_name, ' - ', p.gender) AS patient_info
  FROM healthcare.patients p
  WHERE p.date_of_birth >= '1980-01-01'
),
cte2 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(d.doctor_name, ' - ', d.specialty) AS doctor_info
  FROM healthcare.appointments a
  INNER JOIN healthcare.doctors d ON a.doctor_id = d.doctor_id
  WHERE a.appointment_date >= CURDATE()
),
cte3 AS (
  SELECT p.patient_id, COUNT(*) AS appointment_count
  FROM healthcare.patients p
  LEFT JOIN healthcare.appointments a ON p.patient_id = a.patient_id
  WHERE a.appointment_date >= '2022-01-01'
  GROUP BY p.patient_id
  HAVING COUNT(*) > 5
),
cte4 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(p.patient_name, ' - ', d.doctor_name) AS patient_doctor_info
  FROM healthcare.appointments a
  INNER JOIN healthcare.patients p ON a.patient_id = p.patient_id
  INNER JOIN healthcare.doctors d ON a.doctor_id = d.doctor_id
  WHERE a.appointment_date BETWEEN '2022-01-01' AND '2022-12-31'
),
cte5 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(DATE_FORMAT(a.appointment_date, '%Y-%m-%d'), ' ', a.appointment_time) AS appointment_datetime
  FROM healthcare.appointments a
  WHERE a.appointment_date >= CURDATE()
),
cte6 AS (
  SELECT p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
         CONCAT(p.patient_name, ' - ', p.gender) AS patient_info
  FROM healthcare.patients p
  WHERE p.date_of_birth >= '1980-01-01'
),
cte7 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(d.doctor_name, ' - ', d.specialty) AS doctor_info
  FROM healthcare.appointments a
  INNER JOIN healthcare.doctors d ON a.doctor_id = d.doctor_id
  WHERE a.appointment_date >= CURDATE()
),
cte8 AS (
  SELECT p.patient_id, COUNT(*) AS appointment_count
  FROM healthcare.patients p
  LEFT JOIN healthcare.appointments a ON p.patient_id = a.patient_id
  WHERE a.appointment_date >= '2022-01-01'
  GROUP BY p.patient_id
  HAVING COUNT(*) > 5
),
cte9 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(p.patient_name, ' - ', d.doctor_name) AS patient_doctor_info
  FROM healthcare.appointments a
  INNER JOIN healthcare.patients p ON a.patient_id = p.patient_id
  INNER JOIN healthcare.doctors d ON a.doctor_id = d.doctor_id
  WHERE a.appointment_date BETWEEN '2022-01-01' AND '2022-12-31'
),
cte10 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(DATE_FORMAT(a.appointment_date, '%Y-%m-%d'), ' ', a.appointment_time) AS appointment_datetime
  FROM healthcare.appointments a
  WHERE a.appointment_date >= CURDATE()
)
SELECT cte1.patient_info, cte2.doctor_info, cte3.appointment_count, cte4.patient_doctor_info, 
       cte5.appointment_datetime
FROM cte1
INNER JOIN cte2 ON cte1.patient_id = cte2.patient_id
LEFT JOIN cte3 ON cte1.patient_id = cte3.patient_id
LEFT JOIN cte4 ON cte2.appointment_id = cte4.appointment_id
LEFT JOIN cte5 ON cte2.appointment_id = cte5.appointment_id
WHERE cte1.gender = 'Female'
GROUP BY cte1.patient_id, cte2.doctor_id
HAVING COUNT(*) > 1
ORDER BY cte1.patient_name ASC, cte2.appointment_date DESC;",318,1017,1335,"['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors']"
24,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","WITH 
    cte1 AS (
        SELECT 
            p.project_name,
            COUNT(DISTINCT s.sensor_id) AS num_sensors
        FROM 
            energy.projects p
        LEFT JOIN 
            energy.sensors s ON p.project_id = s.project_id
        WHERE 
            p.start_date >= '2021-01-01'
        GROUP BY 
            p.project_name
        HAVING 
            num_sensors > 5
    ),
    cte2 AS (
        SELECT 
            s.sensor_id,
            AVG(m.measurement_value) AS avg_measurement
        FROM 
            energy.sensors s
        INNER JOIN 
            energy.measurements m ON s.sensor_id = m.sensor_id
        WHERE 
            s.sensor_type = 'temperature'
        GROUP BY 
            s.sensor_id
        HAVING 
            avg_measurement > 25
    )
SELECT 
    cte1.project_name,
    cte1.num_sensors,
    cte2.avg_measurement,
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    UPPER(p.product_name) AS product_name,
    SUM(o.quantity) AS total_quantity
FROM 
    energy.customers c
INNER JOIN 
    energy.orders o ON c.customer_id = o.customer_id
LEFT JOIN 
    energy.products p ON o.product_id = p.product_id
LEFT JOIN 
    cte1 ON cte1.project_name = p.project_name
LEFT JOIN 
    cte2 ON cte2.sensor_id = s.sensor_id
WHERE 
    c.customer_country = 'USA'
    AND o.order_status = 'completed'
GROUP BY 
    cte1.project_name,
    cte1.num_sensors,
    cte2.avg_measurement,
    customer_name,
    formatted_order_date,
    product_name
HAVING 
    total_quantity > 10
ORDER BY 
    total_quantity DESC;",321,411,732,"['energy.projects', 'energy.sensors', 'energy.measurements', 'energy.customers', 'energy.orders', 'energy.products']","['energy.projects', 'energy.sensors', 'energy.measurements', 'energy.customers', 'energy.orders', 'energy.products']","['energy.projects', 'energy.sensors', 'energy.measurements', 'energy.customers', 'energy.orders', 'energy.products']","['energy.projects', 'energy.sensors', 'energy.measurements', 'energy.customers', 'energy.orders', 'energy.products']"
25,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    a.balance
  FROM 
    bank.customers AS c
  JOIN 
    bank.accounts AS a ON c.customer_id = a.customer_id
  WHERE 
    c.city = 'New York'
    AND a.balance > 10000
),
cte2 AS (
  SELECT 
    cte1.customer_name,
    COUNT(*) AS num_accounts
  FROM 
    cte1
  GROUP BY 
    cte1.customer_name
  HAVING 
    num_accounts > 2
),
cte3 AS (
  SELECT 
    cte1.customer_name,
    SUM(cte1.balance) AS total_balance
  FROM 
    cte1
  GROUP BY 
    cte1.customer_name
),
cte4 AS (
  SELECT 
    cte1.customer_name,
    MAX(cte1.balance) AS max_balance
  FROM 
    cte1
  GROUP BY 
    cte1.customer_name
),
cte5 AS (
  SELECT 
    cte1.customer_name,
    MIN(cte1.balance) AS min_balance
  FROM 
    cte1
  GROUP BY 
    cte1.customer_name
),
cte6 AS (
  SELECT 
    cte1.customer_name,
    AVG(cte1.balance) AS avg_balance
  FROM 
    cte1
  GROUP BY 
    cte1.customer_name
),
cte7 AS (
  SELECT 
    cte1.customer_name,
    DATE_FORMAT(MAX(t.transaction_date), '%Y-%m-%d') AS last_transaction_date
  FROM 
    cte1
  JOIN 
    bank.transactions AS t ON cte1.account_number = t.account_number
  GROUP BY 
    cte1.customer_name
),
cte8 AS (
  SELECT 
    cte1.customer_name,
    COUNT(DISTINCT t.transaction_id) AS num_transactions
  FROM 
    cte1
  JOIN 
    bank.transactions AS t ON cte1.account_number = t.account_number
  GROUP BY 
    cte1.customer_name
),
cte9 AS (
  SELECT 
    cte1.customer_name,
    CONCAT('***', SUBSTRING(cte1.account_number, 5, 4), '***') AS masked_account_number
  FROM 
    cte1
),
cte10 AS (
  SELECT 
    cte1.customer_name,
    CONCAT('Hello, ', UPPER(SUBSTRING(cte1.customer_name, 1, 1)), LOWER(SUBSTRING(cte1.customer_name, 2))) AS greeting
  FROM 
    cte1
),
cte11 AS (
  SELECT 
    cte1.customer_name,
    CONCAT(cte1.customer_name, ' has a balance of $', cte1.balance) AS account_info
  FROM 
    cte1
),
cte12 AS (
  SELECT 
    cte1.customer_name,
    CASE 
      WHEN cte1.balance > 50000 THEN 'High'
      WHEN cte1.balance > 10000 THEN 'Medium'
      ELSE 'Low'
    END AS account_status
  FROM 
    cte1
),
cte13 AS (
  SELECT 
    cte1.customer_name,
    CASE 
      WHEN cte1.balance > (SELECT AVG(balance) FROM cte1) THEN 'Above Average'
      ELSE 'Below Average'
    END AS balance_status
  FROM 
    cte1
),
cte14 AS (
  SELECT 
    cte1.customer_name,
    CASE 
      WHEN cte1.balance > 50000 THEN 'VIP'
      WHEN cte1.balance > 10000 THEN 'Preferred'
      ELSE 'Regular'
    END AS customer_type
  FROM 
    cte1
),
cte15 AS (
  SELECT 
    cte1.customer_name,
    CASE 
      WHEN cte1.balance > 50000 THEN 'Platinum'
      WHEN cte1.balance > 10000 THEN 'Gold'
      ELSE 'Silver'
    END AS account_level
  FROM 
    cte1
),
cte16 AS (
  SELECT 
    cte1.customer_name,
    CASE 
      WHEN cte1.balance > 50000 THEN 'Yes'
      ELSE 'No'
    END AS is_wealthy
  FROM 
    cte1
),
cte17 AS (
  SELECT 
    cte1.customer_name,
    CASE 
      WHEN cte1.balance > 50000 THEN 'Yes'
      ELSE 'No'
    END AS is_rich
  FROM 
    cte1
),
cte18 AS (
  SELECT 
    cte1.customer_name,
    CASE 
      WHEN cte1.balance > 50000 THEN 'Yes'
      ELSE 'No'
    END AS is_affluent
  FROM 
    cte1
),
cte19 AS (
  SELECT 
    cte1.customer_name,
    CASE 
      WHEN cte1.balance > 50000 THEN 'Yes'
      ELSE 'No'
    END AS is_prosperous
  FROM 
    cte1
),
cte20 AS (
  SELECT 
    cte1.customer_name,
    CASE 
      WHEN cte1.balance > 50000 THEN 'Yes'
      ELSE 'No'
    END AS is_successful
  FROM 
    cte1
)
SELECT 
  cte1.customer_name,
  cte1.balance,
  cte2.num_accounts,
  cte3.total_balance,
  cte4.max_balance,
  cte5.min_balance,
  cte6.avg_balance,
  cte7.last_transaction_date,
  cte8.num_transactions,
  cte9.masked_account_number,
  cte10.greeting,
  cte11.account_info,
  cte12.account_status,
  cte13.balance_status,
  cte14.customer_type,
  cte15.account_level,
  cte16.is_wealthy,
  cte17.is_rich,
  cte18.is_affluent,
  cte19.is_prosperous,
  cte20.is_successful
FROM 
  cte1
JOIN 
  cte2 ON cte1.customer_name = cte2.customer_name
JOIN 
  cte3 ON cte1.customer_name = cte3.customer_name
JOIN 
  cte4 ON cte1.customer_name = cte4.customer_name
JOIN 
  cte5 ON cte1.customer_name = cte5.customer_name
JOIN 
  cte6 ON cte1.customer_name = cte6.customer_name
JOIN 
  cte7 ON cte1.customer_name = cte7.customer_name
JOIN 
  cte8 ON cte1.customer_name = cte8.customer_name
JOIN 
  cte9 ON cte1.customer_name = cte9.customer_name
JOIN 
  cte10 ON cte1.customer_name = cte10.customer_name
JOIN 
  cte11 ON cte1.customer_name = cte11.customer_name
JOIN 
  cte12 ON cte1.customer_name = cte12.customer_name
JOIN 
  cte13 ON cte1.customer_name = cte13.customer_name
JOIN 
  cte14 ON cte1.customer_name = cte14.customer_name
JOIN 
  cte15 ON cte1.customer_name = cte15.customer_name
JOIN 
  cte16 ON cte1.customer_name = cte16.customer_name
JOIN 
  cte17 ON cte1.customer_name = cte17.customer_name
JOIN 
  cte18 ON cte1.customer_name = cte18.customer_name
JOIN 
  cte19 ON cte1.customer_name = cte19.customer_name
JOIN 
  cte20 ON cte1.customer_name = cte20.customer_name;",314,1674,1988,"['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']"
26,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an insurance company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ' ', a.zip_code) AS customer_address,
    p.policy_number,
    p.policy_type,
    p.policy_start_date,
    p.policy_end_date,
    SUM(p.premium_amount) AS total_premium_amount,
    COUNT(DISTINCT c.customer_id) AS total_customers,
    AVG(p.premium_amount) AS average_premium_amount,
    CONCAT(e.first_name, ' ', e.last_name) AS agent_name,
    CONCAT(b.street, ', ', b.city, ', ', b.state, ' ', b.zip_code) AS agent_address,
    CONCAT(b.phone_area_code, '-', b.phone_number) AS agent_phone_number
FROM
    insurance_company.customers c
    INNER JOIN insurance_company.addresses a ON c.address_id = a.address_id
    INNER JOIN insurance_company.policies p ON c.customer_id = p.customer_id
    LEFT JOIN insurance_company.agents e ON p.agent_id = e.agent_id
    LEFT JOIN insurance_company.addresses b ON e.address_id = b.address_id
WHERE
    p.policy_start_date >= '2021-01-01'
    AND p.policy_end_date <= '2021-12-31'
    AND p.policy_type IN ('Auto', 'Home', 'Health')
GROUP BY
    c.customer_id,
    p.policy_number,
    p.policy_type,
    p.policy_start_date,
    p.policy_end_date,
    e.agent_id
HAVING
    total_premium_amount > 10000
ORDER BY
    total_premium_amount DESC;",317,344,661,"['insurance_company.customers', 'insurance_company.addresses', 'insurance_company.policies', 'insurance_company.agents']","['insurance_company.customers', 'insurance_company.addresses', 'insurance_company.policies', 'insurance_company.agents']","['insurance_company.customers', 'insurance_company.addresses', 'insurance_company.policies', 'insurance_company.agents']","['insurance_company.customers', 'insurance_company.addresses', 'insurance_company.policies', 'insurance_company.agents']"
27,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    a.balance,
    t.transaction_date,
    t.transaction_type,
    t.amount,
    CONCAT(e.first_name, ' ', e.last_name) AS employee_name,
    d.department_name,
    CONCAT(b.first_name, ' ', b.last_name) AS beneficiary_name,
    p.payment_date,
    p.payment_method,
    p.payment_amount
FROM
    bank.customers AS c
    JOIN bank.accounts AS a ON c.customer_id = a.customer_id
    JOIN bank.transactions AS t ON a.account_id = t.account_id
    JOIN bank.employees AS e ON t.employee_id = e.employee_id
    JOIN bank.departments AS d ON e.department_id = d.department_id
    LEFT JOIN bank.beneficiaries AS b ON a.account_id = b.account_id
    LEFT JOIN bank.payments AS p ON b.beneficiary_id = p.beneficiary_id
WHERE
    c.age >= 18
    AND a.balance > 0
    AND t.transaction_type IN ('Deposit', 'Withdrawal')
    AND t.transaction_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
    AND t.transaction_date < DATE_FORMAT(NOW(), '%Y-%m-01') + INTERVAL 1 MONTH
GROUP BY
    c.customer_id,
    a.account_id,
    t.transaction_id,
    e.employee_id,
    d.department_id,
    b.beneficiary_id,
    p.payment_id
HAVING
    COUNT(DISTINCT t.transaction_id) > 5
    AND SUM(t.amount) > 1000
ORDER BY
    c.last_name ASC,
    a.balance DESC,
    t.transaction_date DESC
LIMIT 100;",327,367,694,"['bank.customers', 'bank.accounts', 'bank.transactions', 'bank.employees', 'bank.departments', 'bank.beneficiaries', 'bank.payments']","['bank.customers', 'bank.accounts', 'bank.transactions', 'bank.employees', 'bank.departments', 'bank.beneficiaries', 'bank.payments']","['bank.customers', 'bank.accounts', 'bank.transactions', 'bank.employees', 'bank.departments', 'bank.beneficiaries', 'bank.payments']","['bank.customers', 'bank.accounts', 'bank.transactions', 'bank.employees', 'bank.departments', 'bank.beneficiaries', 'bank.payments']"
28,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT_WS(' ', UPPER(e.first_name), UPPER(e.last_name)) AS employee_name,
    d.department_name,
    p.product_name,
    SUM(o.quantity) AS total_quantity,
    AVG(o.unit_price) AS average_price,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    CONCAT_WS(', ', a.street, a.city, a.state, a.zip_code) AS full_address
FROM
    manufacturing.company.employee e
    INNER JOIN manufacturing.company.department d ON e.department_id = d.department_id
    INNER JOIN manufacturing.company.order o ON e.employee_id = o.employee_id
    INNER JOIN manufacturing.company.product p ON o.product_id = p.product_id
    INNER JOIN manufacturing.company.customer c ON o.customer_id = c.customer_id
    INNER JOIN manufacturing.company.address a ON c.address_id = a.address_id
WHERE
    e.hire_date >= '2020-01-01'
    AND p.category = 'Electronics'
    AND o.order_status = 'Completed'
    AND d.department_name IN ('Production', 'Quality Control')
GROUP BY
    employee_name,
    d.department_name,
    p.product_name,
    formatted_order_date,
    customer_name,
    full_address
HAVING
    total_quantity > 10
    AND average_price < 1000
ORDER BY
    employee_name ASC,
    d.department_name DESC,
    total_quantity DESC
LIMIT 100
CROSS JOIN
    (SELECT 
        COUNT(*) AS total_orders
    FROM
        manufacturing.company.order) t;",317,341,658,"['manufacturing.company.employee', 'manufacturing.company.department', 'manufacturing.company.order', 'manufacturing.company.product', 'manufacturing.company.customer', 'manufacturing.company.address']","['manufacturing.company.employee', 'manufacturing.company.department', 'manufacturing.company.order', 'manufacturing.company.product', 'manufacturing.company.customer', 'manufacturing.company.address']","['manufacturing.company.employee', 'manufacturing.company.department', 'manufacturing.company.order', 'manufacturing.company.product', 'manufacturing.company.customer', 'manufacturing.company.address']","['manufacturing.company.employee', 'manufacturing.company.department', 'manufacturing.company.order', 'manufacturing.company.product', 'manufacturing.company.customer', 'manufacturing.company.address']"
29,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an entertainment company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    COUNT(DISTINCT customer_id) AS total_customers
  FROM 
    entertainment.sales
  WHERE 
    date >= '2021-01-01' AND date <= '2021-12-31'
  GROUP BY 
    month_year
),

cte2 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    COUNT(DISTINCT order_id) AS total_orders
  FROM 
    entertainment.orders
  WHERE 
    date >= '2021-01-01' AND date <= '2021-12-31'
  GROUP BY 
    month_year
),

cte3 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    SUM(total_price) AS total_revenue
  FROM 
    entertainment.orders
  WHERE 
    date >= '2021-01-01' AND date <= '2021-12-31'
  GROUP BY 
    month_year
),

cte4 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    COUNT(DISTINCT event_id) AS total_events
  FROM 
    entertainment.events
  WHERE 
    date >= '2021-01-01' AND date <= '2021-12-31'
  GROUP BY 
    month_year
),

cte5 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    COUNT(DISTINCT artist_id) AS total_artists
  FROM 
    entertainment.artists
  WHERE 
    date >= '2021-01-01' AND date <= '2021-12-31'
  GROUP BY 
    month_year
)

SELECT 
  cte1.month_year,
  cte1.total_customers,
  cte2.total_orders,
  cte3.total_revenue,
  cte4.total_events,
  cte5.total_artists
FROM 
  cte1
LEFT JOIN 
  cte2 ON cte1.month_year = cte2.month_year
LEFT JOIN 
  cte3 ON cte1.month_year = cte3.month_year
LEFT JOIN 
  cte4 ON cte1.month_year = cte4.month_year
LEFT JOIN 
  cte5 ON cte1.month_year = cte5.month_year
ORDER BY 
  cte1.month_year ASC;",325,562,887,"['entertainment.sales', 'entertainment.orders', 'entertainment.events', 'entertainment.artists']","['entertainment.sales', 'entertainment.orders', 'entertainment.events', 'entertainment.artists']","['entertainment.sales', 'entertainment.orders', 'entertainment.events', 'entertainment.artists']","['entertainment.sales', 'entertainment.orders', 'entertainment.events', 'entertainment.artists']"
30,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price
  FROM 
    orders o
  WHERE 
    o.order_date >= '2021-01-01'
),
cte_customers AS (
  SELECT 
    c.customer_id,
    c.customer_name,
    c.city,
    c.state
  FROM 
    customers c
  WHERE 
    c.state IN ('CA', 'NY')
),
cte_products AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.category,
    p.unit_price
  FROM 
    products p
  WHERE 
    p.category = 'Mobile Phones'
),
cte_order_details AS (
  SELECT 
    od.order_id,
    od.product_id,
    od.quantity,
    od.unit_price
  FROM 
    order_details od
),
cte_total_sales AS (
  SELECT 
    o.customer_id,
    SUM(od.quantity * od.unit_price) AS total_sales
  FROM 
    cte_orders o
    JOIN cte_order_details od ON o.order_id = od.order_id
  GROUP BY 
    o.customer_id
),
cte_average_sales AS (
  SELECT 
    c.customer_id,
    AVG(ts.total_sales) AS average_sales
  FROM 
    cte_customers c
    JOIN cte_total_sales ts ON c.customer_id = ts.customer_id
  GROUP BY 
    c.customer_id
),
cte_top_customers AS (
  SELECT 
    ac.customer_id,
    ac.customer_name,
    ac.city,
    ac.state,
    ac.total_sales,
    ac.average_sales
  FROM (
    SELECT 
      c.customer_id,
      c.customer_name,
      c.city,
      c.state,
      ts.total_sales,
      as.average_sales,
      ROW_NUMBER() OVER (PARTITION BY c.state ORDER BY ts.total_sales DESC) AS rn
    FROM 
      cte_customers c
      JOIN cte_total_sales ts ON c.customer_id = ts.customer_id
      JOIN cte_average_sales as ON c.customer_id = as.customer_id
  ) ac
  WHERE 
    ac.rn <= 5
),
cte_monthly_sales AS (
  SELECT 
    DATE_FORMAT(o.order_date, '%Y-%m') AS month,
    SUM(od.quantity * od.unit_price) AS monthly_sales
  FROM 
    cte_orders o
    JOIN cte_order_details od ON o.order_id = od.order_id
  GROUP BY 
    DATE_FORMAT(o.order_date, '%Y-%m')
),
cte_monthly_sales_rank AS (
  SELECT 
    ms.month,
    ms.monthly_sales,
    RANK() OVER (ORDER BY ms.monthly_sales DESC) AS sales_rank
  FROM 
    cte_monthly_sales ms
),
cte_top_selling_products AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.category,
    p.unit_price,
    ms.month,
    ms.monthly_sales,
    ms.sales_rank
  FROM 
    cte_products p
    JOIN cte_order_details od ON p.product_id = od.product_id
    JOIN cte_orders o ON od.order_id = o.order_id
    JOIN cte_monthly_sales_rank ms ON DATE_FORMAT(o.order_date, '%Y-%m') = ms.month
  WHERE 
    ms.sales_rank <= 3
)
SELECT 
  tc.customer_name,
  tc.city,
  tc.state,
  tc.total_sales,
  tc.average_sales,
  tsp.product_name,
  tsp.category,
  tsp.unit_price,
  tsp.month,
  tsp.monthly_sales
FROM 
  cte_top_customers tc
  CROSS JOIN cte_top_selling_products tsp
ORDER BY 
  tc.total_sales DESC, tsp.monthly_sales DESC;",316,795,1111,"['orders', 'customers', 'products', 'order_details']","['orders', 'customers', 'products', 'order_details']","['orders', 'customers', 'products', 'order_details']","['orders', 'customers', 'products', 'order_details']"
31,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an insurance company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(p.policy_id) AS total_policies
  FROM 
    insurance.customers c
  JOIN 
    insurance.policies p ON c.customer_id = p.customer_id
  WHERE 
    c.customer_age >= 30
  GROUP BY 
    c.customer_id
  HAVING 
    total_policies > 3
),
cte2 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(c.claim_id) AS total_claims
  FROM 
    insurance.customers c
  JOIN 
    insurance.claims cl ON c.customer_id = cl.customer_id
  WHERE 
    cl.claim_status = 'Approved'
  GROUP BY 
    c.customer_id
  HAVING 
    total_claims > 5
),
cte3 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    SUM(p.policy_premium) AS total_premium
  FROM 
    insurance.customers c
  JOIN 
    insurance.policies p ON c.customer_id = p.customer_id
  WHERE 
    p.policy_start_date >= '2021-01-01'
  GROUP BY 
    c.customer_id
  HAVING 
    total_premium > 10000
)
SELECT 
  cte1.customer_name,
  cte1.total_policies,
  cte2.total_claims,
  cte3.total_premium
FROM 
  cte1
JOIN 
  cte2 ON cte1.customer_name = cte2.customer_name
JOIN 
  cte3 ON cte1.customer_name = cte3.customer_name
ORDER BY 
  cte1.total_policies DESC, 
  cte2.total_claims DESC, 
  cte3.total_premium DESC
LIMIT 10;",320,413,733,"['insurance.customers', 'insurance.policies', 'insurance.claims']","['insurance.customers', 'insurance.policies', 'insurance.claims']","['insurance.customers', 'insurance.policies', 'insurance.claims']","['insurance.customers', 'insurance.policies', 'insurance.claims']"
32,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(s.first_name, ' ', s.last_name) AS student_name,
    c.course_name,
    COUNT(DISTINCT e.exam_id) AS total_exams_taken,
    AVG(e.exam_score) AS average_exam_score,
    CONCAT(t.first_name, ' ', t.last_name) AS teacher_name,
    COUNT(DISTINCT a.assignment_id) AS total_assignments_completed,
    SUM(a.assignment_score) AS total_assignment_score
FROM 
    education.students AS s
JOIN 
    education.enrollments AS en ON s.student_id = en.student_id
JOIN 
    education.courses AS c ON en.course_id = c.course_id
JOIN 
    education.exams AS e ON en.course_id = e.course_id
JOIN 
    education.teachers AS t ON c.teacher_id = t.teacher_id
LEFT JOIN 
    education.assignments AS a ON s.student_id = a.student_id
WHERE 
    s.enrollment_year >= 2018
    AND c.course_name LIKE '%Math%'
    AND t.department = 'Mathematics'
GROUP BY 
    s.student_id,
    c.course_id,
    t.teacher_id
HAVING 
    total_exams_taken >= 3
    AND average_exam_score >= 80
ORDER BY 
    total_assignment_score DESC
LIMIT 10;",316,268,584,"['education.students', 'education.enrollments', 'education.courses', 'education.exams', 'education.teachers', 'education.assignments']","['education.students', 'education.enrollments', 'education.courses', 'education.exams', 'education.teachers', 'education.assignments']","['education.students', 'education.enrollments', 'education.courses', 'education.exams', 'education.teachers', 'education.assignments']","['education.students', 'education.enrollments', 'education.courses', 'education.exams', 'education.teachers', 'education.assignments']"
33,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    o.order_id,
    o.order_date,
    o.total_price
  FROM 
    sales.customers c
  JOIN 
    sales.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_status = 'completed'
),

cte2 AS (
  SELECT 
    p.product_name,
    p.product_category,
    p.product_price,
    o.order_id
  FROM 
    inventory.products p
  JOIN 
    sales.order_items oi ON p.product_id = oi.product_id
  JOIN 
    sales.orders o ON oi.order_id = o.order_id
),

cte3 AS (
  SELECT 
    cte1.customer_name,
    cte1.order_id,
    cte1.order_date,
    cte1.total_price,
    cte2.product_name,
    cte2.product_category,
    cte2.product_price
  FROM 
    cte1
  JOIN 
    cte2 ON cte1.order_id = cte2.order_id
),

cte4 AS (
  SELECT 
    cte3.customer_name,
    cte3.order_date,
    cte3.product_category,
    SUM(cte3.total_price) AS total_sales
  FROM 
    cte3
  WHERE 
    cte3.order_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
  GROUP BY 
    cte3.customer_name,
    cte3.order_date,
    cte3.product_category
  HAVING 
    total_sales > 1000
),

cte5 AS (
  SELECT 
    cte4.customer_name,
    cte4.order_date,
    cte4.product_category,
    cte4.total_sales,
    ROW_NUMBER() OVER (PARTITION BY cte4.customer_name ORDER BY cte4.total_sales DESC) AS rank
  FROM 
    cte4
),

cte6 AS (
  SELECT 
    cte5.customer_name,
    cte5.order_date,
    cte5.product_category,
    cte5.total_sales,
    cte5.rank
  FROM 
    cte5
  WHERE 
    cte5.rank <= 3
)

SELECT 
  cte6.customer_name,
  cte6.order_date,
  cte6.product_category,
  cte6.total_sales
FROM 
  cte6
ORDER BY 
  cte6.customer_name,
  cte6.order_date,
  cte6.product_category",327,538,865,"['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']"
34,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.product_name, ' - ', p.product_code) AS Product,
    c.category_name AS Category,
    s.supplier_name AS Supplier,
    SUM(o.quantity) AS TotalQuantity,
    AVG(o.unit_price) AS AveragePrice,
    COUNT(DISTINCT o.order_id) AS TotalOrders,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS OrderDate,
    UPPER(u.username) AS UserName
FROM
    pharmaceutical_company.products p
    JOIN pharmaceutical_company.categories c ON p.category_id = c.category_id
    JOIN pharmaceutical_company.suppliers s ON p.supplier_id = s.supplier_id
    JOIN pharmaceutical_company.orders o ON p.product_id = o.product_id
    JOIN pharmaceutical_company.users u ON o.user_id = u.user_id
WHERE
    p.product_status = 'Active'
    AND c.category_name IN ('Antibiotics', 'Painkillers')
    AND s.supplier_country = 'United States'
    AND o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
GROUP BY
    p.product_name,
    c.category_name,
    s.supplier_name,
    DATE_FORMAT(o.order_date, '%Y-%m-%d'),
    UPPER(u.username)
HAVING
    TotalQuantity > 100
    AND AveragePrice < 50
ORDER BY
    TotalOrders DESC
LIMIT 10
CROSS JOIN
    (SELECT 
        MAX(total_quantity) AS max_quantity
    FROM
        (SELECT 
            p.product_name,
                SUM(o.quantity) AS total_quantity
        FROM
            pharmaceutical_company.products p
        JOIN pharmaceutical_company.orders o ON p.product_id = o.product_id
        GROUP BY
            p.product_name) AS subquery) AS max_quantity_table;",319,371,690,"['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']","['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']","['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']","['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']"
35,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    telecom.customers c
  JOIN
    telecom.orders o ON c.customer_id = o.customer_id
  WHERE
    o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY
    c.customer_id
  HAVING
    COUNT(DISTINCT o.order_id) >= 5
),
subquery1 AS (
  SELECT
    p.product_name,
    COUNT(DISTINCT op.order_id) AS total_orders
  FROM
    telecom.products p
  JOIN
    telecom.order_products op ON p.product_id = op.product_id
  WHERE
    p.product_category = 'Mobile Phones'
  GROUP BY
    p.product_id
),
subquery2 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    telecom.customers c
  JOIN
    telecom.orders o ON c.customer_id = o.customer_id
  WHERE
    o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY
    c.customer_id
)
SELECT
  cte.customer_name,
  subquery1.product_name,
  subquery2.total_orders
FROM
  cte
JOIN
  subquery1 ON cte.total_orders = subquery1.total_orders
JOIN
  subquery2 ON cte.customer_name = subquery2.customer_id
ORDER BY
  cte.customer_name ASC, subquery1.product_name DESC;",320,344,664,"['telecom.customers', 'telecom.orders', 'telecom.products', 'telecom.order_products']","['telecom.customers', 'telecom.orders', 'telecom.products', 'telecom.order_products']","['telecom.customers', 'telecom.orders', 'telecom.products', 'telecom.order_products']","['telecom.customers', 'telecom.orders', 'telecom.products', 'telecom.order_products']"
36,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.first_name, ' ', p.last_name) AS patient_name,
    p.date_of_birth,
    CONCAT(d.first_name, ' ', d.last_name) AS doctor_name,
    d.specialty,
    COUNT(DISTINCT a.appointment_id) AS total_appointments,
    SUM(CASE WHEN v.visit_date IS NOT NULL THEN 1 ELSE 0 END) AS total_visits,
    SUM(CASE WHEN v.visit_date IS NOT NULL THEN v.bill_amount ELSE 0 END) AS total_billing_amount
FROM 
    healthcare.patients p
JOIN 
    healthcare.appointments a ON p.patient_id = a.patient_id
JOIN 
    healthcare.doctors d ON a.doctor_id = d.doctor_id
LEFT JOIN 
    healthcare.visits v ON a.appointment_id = v.appointment_id
WHERE 
    p.date_of_birth <= DATE_SUB(CURDATE(), INTERVAL 18 YEAR)
    AND d.specialty = 'Cardiology'
    AND v.visit_date >= '2021-01-01'
GROUP BY 
    p.patient_id,
    d.doctor_id
HAVING 
    total_appointments >= 5
ORDER BY 
    total_billing_amount DESC;",314,247,561,"['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.visits']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.visits']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.visits']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.visits']"
37,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_enrollment AS (
  SELECT
    student_id,
    COUNT(DISTINCT course_id) AS num_courses
  FROM
    education.institution.enrollment
  GROUP BY
    student_id
  HAVING
    COUNT(DISTINCT course_id) >= 3
),
cte_average_grade AS (
  SELECT
    student_id,
    AVG(grade) AS avg_grade
  FROM
    education.institution.grades
  GROUP BY
    student_id
),
cte_top_students AS (
  SELECT
    e.student_id,
    e.num_courses,
    g.avg_grade
  FROM
    cte_enrollment e
    JOIN cte_average_grade g ON e.student_id = g.student_id
  WHERE
    g.avg_grade >= 80
),
cte_course_stats AS (
  SELECT
    c.course_id,
    COUNT(DISTINCT e.student_id) AS num_students,
    SUM(g.grade) AS total_grade
  FROM
    education.institution.courses c
    LEFT JOIN education.institution.enrollment e ON c.course_id = e.course_id
    LEFT JOIN education.institution.grades g ON e.student_id = g.student_id AND c.course_id = g.course_id
  GROUP BY
    c.course_id
),
cte_top_courses AS (
  SELECT
    cs.course_id,
    cs.num_students,
    cs.total_grade
  FROM
    cte_course_stats cs
  WHERE
    cs.num_students >= 5
  ORDER BY
    cs.total_grade DESC
  LIMIT 3
)
SELECT
  s.student_id,
  s.first_name,
  s.last_name,
  CONCAT(s.first_name, ' ', s.last_name) AS full_name,
  s.date_of_birth,
  UPPER(s.gender) AS gender,
  c.course_id,
  c.course_name,
  cs.num_students,
  cs.total_grade,
  t.avg_grade
FROM
  education.institution.students s
  JOIN cte_top_students t ON s.student_id = t.student_id
  JOIN education.institution.enrollment e ON s.student_id = e.student_id
  JOIN education.institution.courses c ON e.course_id = c.course_id
  JOIN cte_course_stats cs ON c.course_id = cs.course_id
  JOIN cte_top_courses tc ON cs.course_id = tc.course_id
WHERE
  s.date_of_birth >= DATE_FORMAT('1990-01-01', '%Y-%m-%d')
  AND s.gender = 'F'
  AND t.num_courses >= 5
ORDER BY
  s.last_name ASC,
  s.first_name ASC,
  c.course_name ASC;",315,552,867,"['education.institution.enrollment', 'education.institution.grades', 'education.institution.courses', 'education.institution.students']","['education.institution.enrollment', 'education.institution.grades', 'education.institution.courses', 'education.institution.students']","['education.institution.enrollment', 'education.institution.grades', 'education.institution.courses', 'education.institution.students']","['education.institution.enrollment', 'education.institution.grades', 'education.institution.courses', 'education.institution.students']"
38,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
        o.order_id,
        o.order_date,
        o.total_price
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    WHERE 
        o.order_status = 'completed'
),
cte2 AS (
    SELECT 
        p.product_name,
        p.product_price,
        p.product_category,
        o.order_id,
        o.order_date
    FROM 
        products p
    CROSS JOIN 
        orders o
    WHERE 
        p.product_id = o.product_id
),
cte3 AS (
    SELECT 
        cte1.customer_name,
        cte1.order_id,
        cte1.order_date,
        cte1.total_price,
        cte2.product_name,
        cte2.product_price,
        cte2.product_category
    FROM 
        cte1
    INNER JOIN 
        cte2 ON cte1.order_id = cte2.order_id
),
cte4 AS (
    SELECT 
        cte3.customer_name,
        cte3.order_id,
        cte3.order_date,
        cte3.total_price,
        cte3.product_name,
        cte3.product_price,
        cte3.product_category,
        SUM(cte3.total_price) AS total_sales
    FROM 
        cte3
    GROUP BY 
        cte3.customer_name,
        cte3.order_id,
        cte3.order_date,
        cte3.total_price,
        cte3.product_name,
        cte3.product_price,
        cte3.product_category
    HAVING 
        total_sales > 1000
)
SELECT 
    cte4.customer_name,
    cte4.order_id,
    DATE_FORMAT(cte4.order_date, '%Y-%m-%d') AS formatted_order_date,
    cte4.total_price,
    cte4.product_name,
    cte4.product_price,
    cte4.product_category,
    UPPER(cte4.customer_name) AS uppercase_customer_name,
    CONCAT(cte4.product_name, ' - ', cte4.product_category) AS product_details
FROM 
    cte4
ORDER BY 
    cte4.customer_name ASC,
    cte4.order_date DESC;",319,493,812,"['customers', 'orders', 'products']","['customers', 'orders', 'products']","['customers', 'orders', 'products']","['customers', 'orders', 'products']"
39,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH monthly_revenue AS (
    SELECT
        DATE_FORMAT(o.order_date, '%Y-%m') AS month,
        SUM(o.total_price) AS revenue
    FROM
        orders o
    WHERE
        o.order_date >= '2021-01-01'
    GROUP BY
        DATE_FORMAT(o.order_date, '%Y-%m')
),
customer_usage AS (
    SELECT
        c.customer_id,
        COUNT(DISTINCT c.call_id) AS total_calls,
        SUM(c.call_duration) AS total_duration
    FROM
        customers c
    JOIN
        call_logs cl ON c.customer_id = cl.customer_id
    WHERE
        cl.call_date >= '2021-01-01'
    GROUP BY
        c.customer_id
),
top_customers AS (
    SELECT
        cu.customer_id,
        cu.customer_name,
        SUM(mr.revenue) AS total_revenue
    FROM
        customer_usage cu
    JOIN
        monthly_revenue mr ON cu.customer_id = mr.customer_id
    GROUP BY
        cu.customer_id,
        cu.customer_name
    HAVING
        SUM(mr.revenue) > 10000
),
average_usage AS (
    SELECT
        DATE_FORMAT(cl.call_date, '%Y-%m') AS month,
        AVG(cl.call_duration) AS avg_duration
    FROM
        call_logs cl
    WHERE
        cl.call_date >= '2021-01-01'
    GROUP BY
        DATE_FORMAT(cl.call_date, '%Y-%m')
),
final_query AS (
    SELECT
        tc.customer_id,
        tc.customer_name,
        tc.total_revenue,
        au.avg_duration
    FROM
        top_customers tc
    JOIN
        average_usage au ON tc.customer_id = au.customer_id
    WHERE
        au.avg_duration > 10
)
SELECT
    f.customer_id,
    f.customer_name,
    f.total_revenue,
    f.avg_duration,
    CONCAT('Monthly revenue for ', f.customer_name, ' is $', f.total_revenue) AS revenue_message
FROM
    final_query f
ORDER BY
    f.total_revenue DESC;",313,445,758,"['orders', 'customers', 'call_logs']","['orders', 'customers', 'call_logs']","['orders', 'customers', 'call_logs']","['orders', 'customers', 'call_logs']"
40,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH 
    cte1 AS (
        SELECT 
            CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
            COUNT(DISTINCT o.order_id) AS total_orders
        FROM 
            customers c
        INNER JOIN 
            orders o ON c.customer_id = o.customer_id
        WHERE 
            o.order_date >= '2021-01-01'
        GROUP BY 
            c.customer_id
        HAVING 
            total_orders > 5
    ),
    cte2 AS (
        SELECT 
            p.product_name,
            SUM(od.quantity) AS total_quantity
        FROM 
            products p
        INNER JOIN 
            order_details od ON p.product_id = od.product_id
        INNER JOIN 
            orders o ON od.order_id = o.order_id
        WHERE 
            o.order_date >= '2021-01-01'
        GROUP BY 
            p.product_id
        HAVING 
            total_quantity > 100
    )
SELECT 
    cte1.customer_name,
    cte2.product_name,
    cte2.total_quantity,
    CONCAT('$', FORMAT(cte2.total_quantity * p.product_price, 2)) AS total_revenue
FROM 
    cte1
INNER JOIN 
    cte2 ON cte1.customer_name = cte2.customer_name
INNER JOIN 
    products p ON cte2.product_name = p.product_name
ORDER BY 
    cte1.total_orders DESC, cte2.total_quantity DESC;",315,312,627,"['customers', 'orders', 'products', 'order_details']","['customers', 'orders', 'products', 'order_details']","['customers', 'orders', 'products', 'order_details']","['customers', 'orders', 'products', 'order_details']"
41,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH monthly_revenue AS (
    SELECT
        DATE_FORMAT(o.order_date, '%Y-%m') AS month,
        SUM(o.total_price) AS revenue
    FROM
        orders o
    WHERE
        o.order_date >= '2021-01-01'
    GROUP BY
        DATE_FORMAT(o.order_date, '%Y-%m')
),
customer_usage AS (
    SELECT
        c.customer_id,
        COUNT(DISTINCT c.call_id) AS total_calls,
        SUM(c.call_duration) AS total_duration
    FROM
        customers c
    JOIN
        call_logs cl ON c.customer_id = cl.customer_id
    WHERE
        cl.call_date >= '2021-01-01'
    GROUP BY
        c.customer_id
),
top_customers AS (
    SELECT
        cu.customer_id,
        cu.customer_name,
        SUM(mr.revenue) AS total_revenue
    FROM
        customer_usage cu
    JOIN
        monthly_revenue mr ON cu.customer_id = mr.customer_id
    GROUP BY
        cu.customer_id,
        cu.customer_name
    HAVING
        SUM(mr.revenue) > 1000
),
final_query AS (
    SELECT
        tc.customer_id,
        tc.customer_name,
        tc.total_revenue,
        cu.total_calls,
        cu.total_duration
    FROM
        top_customers tc
    JOIN
        customer_usage cu ON tc.customer_id = cu.customer_id
)
SELECT
    f.customer_id,
    f.customer_name,
    f.total_revenue,
    f.total_calls,
    f.total_duration,
    CONCAT('Average call duration: ', AVG(f.total_duration), ' minutes') AS average_duration
FROM
    final_query f
GROUP BY
    f.customer_id,
    f.customer_name,
    f.total_revenue,
    f.total_calls,
    f.total_duration
HAVING
    AVG(f.total_duration) > 10
ORDER BY
    f.total_revenue DESC;",313,409,722,"[""orders"", ""customers"", ""call_logs""]","[""orders"", ""customers"", ""call_logs""]","[""orders"", ""customers"", ""call_logs""]","[""orders"", ""customers"", ""call_logs""]"
42,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(o.order_id) AS total_orders
  FROM
    travel_agency.customers c
  INNER JOIN
    travel_agency.orders o ON c.customer_id = o.customer_id
  WHERE
    o.order_date >= '2021-01-01'
  GROUP BY
    c.customer_id
  HAVING
    total_orders > 5
),
subquery1 AS (
  SELECT
    p.package_id,
    p.package_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.order_price) AS total_revenue
  FROM
    travel_agency.packages p
  LEFT JOIN
    travel_agency.orders o ON p.package_id = o.package_id
  WHERE
    o.order_date >= '2021-01-01'
  GROUP BY
    p.package_id
),
subquery2 AS (
  SELECT
    p.package_id,
    COUNT(DISTINCT o.customer_id) AS total_customers
  FROM
    travel_agency.packages p
  LEFT JOIN
    travel_agency.orders o ON p.package_id = o.package_id
  WHERE
    o.order_date >= '2021-01-01'
  GROUP BY
    p.package_id
)
SELECT
  cte.customer_name,
  subquery1.package_name,
  subquery1.total_orders,
  subquery1.total_revenue,
  subquery2.total_customers
FROM
  cte
INNER JOIN
  subquery1 ON cte.customer_name = subquery1.customer_name
INNER JOIN
  subquery2 ON subquery1.package_id = subquery2.package_id
ORDER BY
  subquery1.total_revenue DESC;",313,379,692,"['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages']","['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages']","['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages']","['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages']"
43,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    a.balance
  FROM 
    customers c
  INNER JOIN 
    accounts a ON c.customer_id = a.customer_id
  WHERE 
    a.balance > 1000
),
cte2 AS (
  SELECT 
    t.transaction_id,
    t.account_number,
    t.amount,
    t.transaction_date
  FROM 
    transactions t
  INNER JOIN 
    cte1 ON t.account_number = cte1.account_number
  WHERE 
    t.transaction_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
),
cte3 AS (
  SELECT 
    cte2.account_number,
    COUNT(DISTINCT cte2.transaction_id) AS num_transactions
  FROM 
    cte2
  GROUP BY 
    cte2.account_number
  HAVING 
    num_transactions > 5
),
cte4 AS (
  SELECT 
    cte3.account_number,
    SUM(cte2.amount) AS total_amount
  FROM 
    cte2
  INNER JOIN 
    cte3 ON cte2.account_number = cte3.account_number
  GROUP BY 
    cte3.account_number
),
cte5 AS (
  SELECT 
    cte4.account_number,
    AVG(cte2.amount) AS avg_amount
  FROM 
    cte2
  INNER JOIN 
    cte4 ON cte2.account_number = cte4.account_number
  GROUP BY 
    cte4.account_number
)
SELECT 
  cte1.customer_name,
  cte1.account_number,
  cte1.balance,
  cte4.total_amount,
  cte5.avg_amount
FROM 
  cte1
INNER JOIN 
  cte4 ON cte1.account_number = cte4.account_number
INNER JOIN 
  cte5 ON cte1.account_number = cte5.account_number
CROSS JOIN 
  branches b
WHERE 
  b.branch_id = 1
ORDER BY 
  cte1.customer_name ASC;",320,450,770,"['customers', 'accounts', 'transactions', 'branches']","['customers', 'accounts', 'transactions', 'branches']","['customers', 'accounts', 'transactions', 'branches']","['customers', 'accounts', 'transactions', 'branches']"
44,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    o.order_date >= '2021-01-01'
  GROUP BY
    c.customer_id
  HAVING
    total_orders > 5
),
subquery1 AS (
  SELECT
    p.product_name,
    SUM(od.quantity) AS total_quantity
  FROM
    products p
  INNER JOIN
    order_details od ON p.product_id = od.product_id
  WHERE
    p.category_id = 1
  GROUP BY
    p.product_id
),
subquery2 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_distinct_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  GROUP BY
    c.customer_id
),
subquery3 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_distinct_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  GROUP BY
    c.customer_id
),
subquery4 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_distinct_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  GROUP BY
    c.customer_id
)
SELECT
  cte.customer_name,
  cte.total_orders,
  subquery1.product_name,
  subquery1.total_quantity,
  subquery2.total_distinct_orders,
  subquery3.total_distinct_orders,
  subquery4.total_distinct_orders
FROM
  cte
INNER JOIN
  subquery1 ON cte.customer_name = subquery1.product_name
INNER JOIN
  subquery2 ON cte.customer_name = subquery2.customer_id
INNER JOIN
  subquery3 ON cte.customer_name = subquery3.customer_id
INNER JOIN
  subquery4 ON cte.customer_name = subquery4.customer_id
ORDER BY
  cte.total_orders DESC, subquery1.total_quantity ASC
LIMIT 10;",313,504,817,"['customers', 'orders', 'products', 'order_details']","['customers', 'orders', 'products', 'order_details']","['customers', 'orders', 'products', 'order_details']","['customers', 'orders', 'products', 'order_details']"
45,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        o.order_id,
        o.order_date,
        o.customer_id,
        c.customer_name,
        c.customer_email,
        c.customer_phone
    FROM 
        orders o
    JOIN 
        customers c ON o.customer_id = c.customer_id
    WHERE 
        o.order_status = 'completed'
),
cte2 AS (
    SELECT 
        oi.order_id,
        SUM(oi.quantity * oi.unit_price) AS order_total
    FROM 
        order_items oi
    GROUP BY 
        oi.order_id
),
cte3 AS (
    SELECT 
        o.order_id,
        COUNT(DISTINCT p.product_id) AS unique_products
    FROM 
        orders o
    JOIN 
        order_items oi ON o.order_id = oi.order_id
    JOIN 
        products p ON oi.product_id = p.product_id
    GROUP BY 
        o.order_id
),
cte4 AS (
    SELECT 
        o.order_id,
        COUNT(DISTINCT c.customer_id) AS unique_customers
    FROM 
        orders o
    JOIN 
        customers c ON o.customer_id = c.customer_id
    GROUP BY 
        o.order_id
),
cte5 AS (
    SELECT 
        o.order_id,
        COUNT(DISTINCT s.shipping_id) AS unique_shippings
    FROM 
        orders o
    JOIN 
        shippings s ON o.order_id = s.order_id
    GROUP BY 
        o.order_id
),
cte6 AS (
    SELECT 
        o.order_id,
        COUNT(DISTINCT p.payment_id) AS unique_payments
    FROM 
        orders o
    JOIN 
        payments p ON o.order_id = p.order_id
    GROUP BY 
        o.order_id
)
SELECT 
    cte1.order_id,
    cte1.order_date,
    cte1.customer_id,
    cte1.customer_name,
    cte1.customer_email,
    cte1.customer_phone,
    cte2.order_total,
    cte3.unique_products,
    cte4.unique_customers,
    cte5.unique_shippings,
    cte6.unique_payments
FROM 
    cte1
JOIN 
    cte2 ON cte1.order_id = cte2.order_id
JOIN 
    cte3 ON cte1.order_id = cte3.order_id
JOIN 
    cte4 ON cte1.order_id = cte4.order_id
JOIN 
    cte5 ON cte1.order_id = cte5.order_id
JOIN 
    cte6 ON cte1.order_id = cte6.order_id
WHERE 
    cte2.order_total > 1000
    AND cte3.unique_products > 5
    AND cte4.unique_customers > 1
    AND cte5.unique_shippings > 1
    AND cte6.unique_payments > 1
GROUP BY 
    cte1.order_id,
    cte1.order_date,
    cte1.customer_id,
    cte1.customer_name,
    cte1.customer_email,
    cte1.customer_phone,
    cte2.order_total,
    cte3.unique_products,
    cte4.unique_customers,
    cte5.unique_shippings,
    cte6.unique_payments
HAVING 
    COUNT(*) > 1
ORDER BY 
    cte2.order_total DESC
LIMIT 10;",317,724,1041,"['orders', 'customers', 'order_items', 'products', 'shippings', 'payments']","['orders', 'customers', 'order_items', 'products', 'shippings', 'payments']","['orders', 'customers', 'order_items', 'products', 'shippings', 'payments']","['orders', 'customers', 'order_items', 'products', 'shippings', 'payments']"
46,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    c.phone_number,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ' ', a.zip_code) AS customer_address,
    p.product_name,
    p.price,
    SUM(o.quantity) AS total_quantity,
    SUM(o.quantity * p.price) AS total_sales
FROM
    kusto_database.customers AS c
CROSS JOIN
    lateral (
        SELECT 
            a.street,
            a.city,
            a.state,
            a.zip_code
        FROM
            customer_addresses AS a
        WHERE
            a.customer_id = c.customer_id
        LIMIT 1
    ) AS a
CROSS JOIN
    lateral (
        SELECT 
            o.product_id,
            o.quantity
        FROM
            orders AS o
        WHERE
            o.customer_id = c.customer_id
    ) AS o
JOIN
    products AS p ON p.product_id = o.product_id
WHERE
    c.status = 'active'
    AND p.category = 'telecommunications'
GROUP BY
    c.customer_id,
    c.first_name,
    c.last_name,
    c.phone_number,
    a.street,
    a.city,
    a.state,
    a.zip_code,
    p.product_id,
    p.product_name,
    p.price
HAVING
    total_sales > 1000
ORDER BY
    total_sales DESC;",325,297,622,"['kusto_database.customers', 'customer_addresses', 'orders', 'products']","['kusto_database.customers', 'customer_addresses', 'orders', 'products']","['kusto_database.customers', 'customer_addresses', 'orders', 'products']","['kusto_database.customers', 'customer_addresses', 'orders', 'products']"
47,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    t.trip_name,
    t.destination,
    t.start_date,
    t.end_date,
    COUNT(DISTINCT r.reservation_id) AS total_reservations,
    SUM(r.total_price) AS total_revenue
FROM 
    travel_agency.customers AS c
CROSS JOIN 
    travel_agency.trips AS t
CROSS JOIN 
    travel_agency.reservations AS r
JOIN 
    travel_agency.hotels AS h ON r.hotel_id = h.hotel_id
JOIN 
    travel_agency.flights AS f ON r.flight_id = f.flight_id
JOIN 
    travel_agency.activities AS a ON r.activity_id = a.activity_id
WHERE 
    c.customer_id = r.customer_id
    AND t.trip_id = r.trip_id
    AND t.start_date >= '2022-01-01'
    AND t.end_date <= '2022-12-31'
    AND h.rating >= 4
    AND f.airline = 'AirlineX'
    AND a.category = 'Adventure'
GROUP BY 
    c.customer_id,
    t.trip_id,
    t.destination,
    t.start_date,
    t.end_date
HAVING 
    total_reservations > 2
ORDER BY 
    total_revenue DESC;",322,283,605,"['travel_agency.customers', 'travel_agency.trips', 'travel_agency.reservations', 'travel_agency.hotels', 'travel_agency.flights', 'travel_agency.activities']","['travel_agency.customers', 'travel_agency.trips', 'travel_agency.reservations', 'travel_agency.hotels', 'travel_agency.flights', 'travel_agency.activities']","['travel_agency.customers', 'travel_agency.trips', 'travel_agency.reservations', 'travel_agency.hotels', 'travel_agency.flights', 'travel_agency.activities']","['travel_agency.customers', 'travel_agency.trips', 'travel_agency.reservations', 'travel_agency.hotels', 'travel_agency.flights', 'travel_agency.activities']"
48,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    o.order_id,
    o.order_date,
    o.total_price
  FROM 
    customers c
  JOIN 
    orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
),
cte2 AS (
  SELECT 
    cte1.customer_name,
    cte1.order_id,
    cte1.order_date,
    cte1.total_price,
    p.product_name,
    p.product_price
  FROM 
    cte1
  JOIN 
    order_items oi ON cte1.order_id = oi.order_id
  JOIN 
    products p ON oi.product_id = p.product_id
),
cte3 AS (
  SELECT 
    cte2.customer_name,
    cte2.order_id,
    cte2.order_date,
    cte2.total_price,
    cte2.product_name,
    cte2.product_price,
    SUM(cte2.product_price) OVER (PARTITION BY cte2.customer_name) AS total_product_price
  FROM 
    cte2
),
cte4 AS (
  SELECT 
    cte3.customer_name,
    cte3.order_id,
    cte3.order_date,
    cte3.total_price,
    cte3.product_name,
    cte3.product_price,
    cte3.total_product_price,
    COUNT(DISTINCT cte3.order_id) OVER (PARTITION BY cte3.customer_name) AS total_orders,
    ROW_NUMBER() OVER (PARTITION BY cte3.customer_name ORDER BY cte3.order_date DESC) AS row_num
  FROM 
    cte3
),
cte5 AS (
  SELECT 
    cte4.customer_name,
    cte4.order_id,
    cte4.order_date,
    cte4.total_price,
    cte4.product_name,
    cte4.product_price,
    cte4.total_product_price,
    cte4.total_orders,
    cte4.row_num
  FROM 
    cte4
  WHERE 
    cte4.row_num = 1
),
cte6 AS (
  SELECT 
    cte5.customer_name,
    cte5.order_id,
    cte5.order_date,
    cte5.total_price,
    cte5.product_name,
    cte5.product_price,
    cte5.total_product_price,
    cte5.total_orders,
    cte5.row_num,
    CASE 
      WHEN cte5.total_orders > 5 THEN 'Loyal Customer'
      ELSE 'Regular Customer'
    END AS customer_type
  FROM 
    cte5
),
cte7 AS (
  SELECT 
    cte6.customer_name,
    cte6.order_id,
    cte6.order_date,
    cte6.total_price,
    cte6.product_name,
    cte6.product_price,
    cte6.total_product_price,
    cte6.total_orders,
    cte6.row_num,
    cte6.customer_type,
    CASE 
      WHEN cte6.total_product_price > 1000 THEN 'High Value'
      WHEN cte6.total_product_price > 500 THEN 'Medium Value'
      ELSE 'Low Value'
    END AS customer_value
  FROM 
    cte6
)
SELECT 
  cte7.customer_name,
  cte7.order_id,
  DATE_FORMAT(cte7.order_date, '%Y-%m-%d') AS formatted_order_date,
  cte7.total_price,
  cte7.product_name,
  cte7.product_price,
  cte7.total_product_price,
  cte7.total_orders,
  cte7.customer_type,
  cte7.customer_value
FROM 
  cte7
WHERE 
  cte7.customer_value = 'High Value'
GROUP BY 
  cte7.customer_name,
  cte7.order_id,
  cte7.formatted_order_date,
  cte7.total_price,
  cte7.product_name,
  cte7.product_price,
  cte7.total_product_price,
  cte7.total_orders,
  cte7.customer_type,
  cte7.customer_value
HAVING 
  COUNT(DISTINCT cte7.product_name) > 3
ORDER BY 
  cte7.customer_name ASC,
  cte7.total_product_price DESC;",319,935,1254,"['customers', 'orders', 'order_items', 'products']","['customers', 'orders', 'order_items', 'products']","['customers', 'orders', 'order_items', 'products']","['customers', 'orders', 'order_items', 'products']"
49,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","WITH property_sales AS (
  SELECT
    p.property_id,
    p.property_name,
    p.property_type,
    s.sale_date,
    s.sale_price
  FROM
    real_estate.property AS p
  JOIN
    real_estate.sale AS s
  ON
    p.property_id = s.property_id
  WHERE
    p.property_type = 'House'
    AND s.sale_date >= '2021-01-01'
),

property_stats AS (
  SELECT
    property_type,
    COUNT(*) AS total_properties,
    AVG(sale_price) AS avg_sale_price
  FROM
    real_estate.property
  GROUP BY
    property_type
),

top_agents AS (
  SELECT
    a.agent_id,
    CONCAT(a.first_name, ' ', a.last_name) AS agent_name,
    COUNT(*) AS total_sales
  FROM
    real_estate.agent AS a
  JOIN
    real_estate.sale AS s
  ON
    a.agent_id = s.agent_id
  WHERE
    s.sale_date >= '2021-01-01'
  GROUP BY
    a.agent_id,
    agent_name
  HAVING
    total_sales > 5
),

property_analysis AS (
  SELECT
    ps.property_type,
    ps.total_properties,
    ps.avg_sale_price,
    ta.agent_name,
    ta.total_sales
  FROM
    property_stats AS ps
  JOIN
    top_agents AS ta
  ON
    ps.property_type = ta.property_type
),

final_result AS (
  SELECT
    pa.property_type,
    pa.total_properties,
    pa.avg_sale_price,
    pa.agent_name,
    pa.total_sales,
    DATE_FORMAT(ps.sale_date, '%Y-%m') AS sale_month,
    SUM(ps.sale_price) AS total_sales_amount
  FROM
    property_analysis AS pa
  JOIN
    property_sales AS ps
  ON
    pa.property_type = ps.property_type
    AND pa.agent_name = ps.agent_name
  GROUP BY
    pa.property_type,
    pa.total_properties,
    pa.avg_sale_price,
    pa.agent_name,
    pa.total_sales,
    sale_month
  HAVING
    total_sales_amount > 100000
)

SELECT
  property_type,
  total_properties,
  avg_sale_price,
  agent_name,
  total_sales,
  sale_month,
  total_sales_amount
FROM
  final_result
ORDER BY
  total_sales_amount DESC
LIMIT
  10;",316,515,831,"['real_estate.property', 'real_estate.sale', 'real_estate.agent']","['real_estate.property', 'real_estate.sale', 'real_estate.agent']","['real_estate.property', 'real_estate.sale', 'real_estate.agent']","['real_estate.property', 'real_estate.sale', 'real_estate.agent']"
50,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(schools.name, ' - ', departments.name) AS department_name,
    COUNT(DISTINCT students.id) AS total_students
  FROM 
    education.schools
  INNER JOIN 
    education.departments ON schools.id = departments.school_id
  INNER JOIN 
    education.courses ON departments.id = courses.department_id
  INNER JOIN 
    education.students ON courses.id = students.course_id
  WHERE 
    schools.location = 'New York'
  GROUP BY 
    department_name
  HAVING 
    total_students > 100
),
cte2 AS (
  SELECT 
    CONCAT(students.first_name, ' ', students.last_name) AS student_name,
    COUNT(DISTINCT exams.id) AS total_exams
  FROM 
    education.students
  INNER JOIN 
    education.exams ON students.id = exams.student_id
  WHERE 
    students.enrollment_year = 2020
  GROUP BY 
    student_name
  HAVING 
    total_exams > 5
),
cte3 AS (
  SELECT 
    CONCAT(teachers.first_name, ' ', teachers.last_name) AS teacher_name,
    COUNT(DISTINCT courses.id) AS total_courses
  FROM 
    education.teachers
  INNER JOIN 
    education.courses ON teachers.id = courses.teacher_id
  WHERE 
    teachers.department_id IN (
      SELECT 
        id
      FROM 
        education.departments
      WHERE 
        school_id = (
          SELECT 
            id
          FROM 
            education.schools
          WHERE 
            name = 'ABC University'
        )
    )
  GROUP BY 
    teacher_name
  HAVING 
    total_courses > 3
)
SELECT 
  cte1.department_name,
  cte2.student_name,
  cte3.teacher_name,
  COUNT(DISTINCT enrollments.id) AS total_enrollments,
  SUM(courses.credit_hours) AS total_credit_hours
FROM 
  education.enrollments
INNER JOIN 
  education.students ON enrollments.student_id = students.id
INNER JOIN 
  education.courses ON enrollments.course_id = courses.id
INNER JOIN 
  cte1 ON departments.name = cte1.department_name
INNER JOIN 
  cte2 ON students.first_name = cte2.student_name
INNER JOIN 
  cte3 ON teachers.first_name = cte3.teacher_name
CROSS JOIN 
  education.classrooms
WHERE 
  enrollments.year = 2021
GROUP BY 
  cte1.department_name,
  cte2.student_name,
  cte3.teacher_name
HAVING 
  total_enrollments > 10
ORDER BY 
  total_credit_hours DESC;",318,566,884,"['education.schools', 'education.departments', 'education.courses', 'education.students', 'education.exams', 'education.teachers', 'education.enrollments', 'education.classrooms']","['education.schools', 'education.departments', 'education.courses', 'education.students', 'education.exams', 'education.teachers', 'education.enrollments', 'education.classrooms']","['education.schools', 'education.departments', 'education.courses', 'education.students', 'education.exams', 'education.teachers', 'education.enrollments', 'education.classrooms']","['education.schools', 'education.departments', 'education.courses', 'education.students', 'education.exams', 'education.teachers', 'education.enrollments', 'education.classrooms']"
51,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        customers.customer_id,
        customers.customer_name,
        orders.order_id,
        orders.order_date,
        orders.total_price
    FROM 
        telecom.customers
    INNER JOIN 
        telecom.orders ON customers.customer_id = orders.customer_id
    WHERE 
        customers.customer_status = 'Active'
),
cte2 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT order_id) AS total_orders
    FROM 
        cte1
    GROUP BY 
        customer_id
    HAVING 
        total_orders > 5
),
cte3 AS (
    SELECT 
        customer_id,
        SUM(total_price) AS total_sales
    FROM 
        cte1
    GROUP BY 
        customer_id
),
cte4 AS (
    SELECT 
        customer_id,
        DATE_FORMAT(order_date, '%Y-%m') AS month,
        COUNT(DISTINCT order_id) AS monthly_orders
    FROM 
        cte1
    GROUP BY 
        customer_id,
        month
),
cte5 AS (
    SELECT 
        customer_id,
        MAX(monthly_orders) AS max_monthly_orders
    FROM 
        cte4
    GROUP BY 
        customer_id
),
cte6 AS (
    SELECT 
        customer_id,
        month,
        monthly_orders
    FROM 
        cte4
    WHERE 
        (customer_id, monthly_orders) IN (
            SELECT 
                customer_id,
                max_monthly_orders
            FROM 
                cte5
        )
),
cte7 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT order_id) AS total_orders,
        SUM(total_price) AS total_sales,
        MAX(monthly_orders) AS max_monthly_orders
    FROM 
        cte1
    LEFT JOIN 
        cte6 ON cte1.customer_id = cte6.customer_id
    GROUP BY 
        customer_id
),
cte8 AS (
    SELECT 
        customer_id,
        CASE
            WHEN total_orders > 10 THEN 'High'
            WHEN total_orders > 5 THEN 'Medium'
            ELSE 'Low'
        END AS order_frequency
    FROM 
        cte7
),
cte9 AS (
    SELECT 
        customer_id,
        CASE
            WHEN total_sales > 10000 THEN 'High'
            WHEN total_sales > 5000 THEN 'Medium'
            ELSE 'Low'
        END AS sales_category
    FROM 
        cte7
),
cte10 AS (
    SELECT 
        customer_id,
        CASE
            WHEN max_monthly_orders > 3 THEN 'High'
            WHEN max_monthly_orders > 1 THEN 'Medium'
            ELSE 'Low'
        END AS peak_order_month
    FROM 
        cte7
)
SELECT 
    cte1.customer_id,
    cte1.customer_name,
    cte1.order_id,
    cte1.order_date,
    cte1.total_price,
    cte2.total_orders,
    cte3.total_sales,
    cte8.order_frequency,
    cte9.sales_category,
    cte10.peak_order_month
FROM 
    cte1
LEFT JOIN 
    cte2 ON cte1.customer_id = cte2.customer_id
LEFT JOIN 
    cte3 ON cte1.customer_id = cte3.customer_id
LEFT JOIN 
    cte8 ON cte1.customer_id = cte8.customer_id
LEFT JOIN 
    cte9 ON cte1.customer_id = cte9.customer_id
LEFT JOIN 
    cte10 ON cte1.customer_id = cte10.customer_id
ORDER BY 
    cte1.customer_id;",319,775,1094,"['telecom.customers', 'telecom.orders']","['telecom.customers', 'telecom.orders']","['telecom.customers', 'telecom.orders']","['telecom.customers', 'telecom.orders']"
52,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    a.balance
  FROM 
    bank.customers AS c
  JOIN 
    bank.accounts AS a ON c.customer_id = a.customer_id
  WHERE 
    c.city = 'New York'
),
cte2 AS (
  SELECT 
    customer_name,
    COUNT(*) AS num_transactions
  FROM 
    bank.transactions AS t
  JOIN 
    cte1 ON t.account_number = cte1.account_number
  WHERE 
    t.transaction_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY 
    customer_name
),
cte3 AS (
  SELECT 
    customer_name,
    SUM(balance) AS total_balance
  FROM 
    cte1
  GROUP BY 
    customer_name
),
cte4 AS (
  SELECT 
    customer_name,
    AVG(num_transactions) AS avg_transactions
  FROM 
    cte2
  GROUP BY 
    customer_name
),
cte5 AS (
  SELECT 
    customer_name,
    CASE 
      WHEN total_balance > 10000 THEN 'High'
      WHEN total_balance > 5000 THEN 'Medium'
      ELSE 'Low'
    END AS balance_category
  FROM 
    cte3
),
cte6 AS (
  SELECT 
    customer_name,
    CASE 
      WHEN avg_transactions > 10 THEN 'Active'
      WHEN avg_transactions > 5 THEN 'Moderate'
      ELSE 'Inactive'
    END AS activity_status
  FROM 
    cte4
),
cte7 AS (
  SELECT 
    customer_name,
    balance_category,
    activity_status
  FROM 
    cte5
  JOIN 
    cte6 USING (customer_name)
),
cte8 AS (
  SELECT 
    customer_name,
    balance_category,
    activity_status,
    COUNT(*) AS num_customers
  FROM 
    cte7
  GROUP BY 
    balance_category,
    activity_status
),
cte9 AS (
  SELECT 
    balance_category,
    activity_status,
    MAX(num_customers) AS max_customers
  FROM 
    cte8
  GROUP BY 
    balance_category
),
cte10 AS (
  SELECT 
    cte8.balance_category,
    cte8.activity_status,
    cte8.num_customers,
    cte9.max_customers,
    CONCAT(UPPER(SUBSTRING(balance_category, 1, 1)), SUBSTRING(balance_category, 2)) AS formatted_balance_category,
    CONCAT(UPPER(SUBSTRING(activity_status, 1, 1)), SUBSTRING(activity_status, 2)) AS formatted_activity_status
  FROM 
    cte8
  JOIN 
    cte9 USING (balance_category)
),
cte11 AS (
  SELECT 
    formatted_balance_category,
    formatted_activity_status,
    num_customers,
    ROUND((num_customers / max_customers) * 100, 2) AS percentage
  FROM 
    cte10
),
cte12 AS (
  SELECT 
    formatted_balance_category,
    GROUP_CONCAT(CONCAT(formatted_activity_status, ': ', num_customers, ' (', percentage, '%)') ORDER BY num_customers DESC SEPARATOR ', ') AS summary
  FROM 
    cte11
  GROUP BY 
    formatted_balance_category
)
SELECT 
  formatted_balance_category,
  summary
FROM 
  cte12
ORDER BY 
  formatted_balance_category ASC;",314,740,1054,"[""bank.customers"", ""bank.accounts"", ""bank.transactions""]","[""bank.customers"", ""bank.accounts"", ""bank.transactions""]","[""bank.customers"", ""bank.accounts"", ""bank.transactions""]","[""bank.customers"", ""bank.accounts"", ""bank.transactions""]"
53,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    c.phone_number,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ' ', a.zip_code) AS customer_address,
    p.plan_name,
    COUNT(DISTINCT s.service_id) AS total_services,
    SUM(s.data_usage) AS total_data_usage,
    AVG(s.call_duration) AS average_call_duration,
    DATE_FORMAT(MAX(s.start_date), '%Y-%m-%d') AS last_service_date,
    UPPER(p.plan_type) AS plan_type,
    CONCAT(e.first_name, ' ', e.last_name) AS employee_name,
    e.department,
    CONCAT(m.first_name, ' ', m.last_name) AS manager_name,
    m.department AS manager_department
FROM
    customers c
        JOIN
    addresses a ON c.address_id = a.address_id
        JOIN
    services s ON c.customer_id = s.customer_id
        JOIN
    plans p ON s.plan_id = p.plan_id
        JOIN
    employees e ON c.employee_id = e.employee_id
        JOIN
    employees m ON e.manager_id = m.employee_id
        CROSS JOIN
    (SELECT 
        COUNT(DISTINCT customer_id) AS total_customers
    FROM
        customers) tc
        CROSS JOIN
    (SELECT 
        COUNT(DISTINCT plan_id) AS total_plans
    FROM
        plans) tp
WHERE
    c.status = 'Active'
        AND a.state = 'California'
        AND p.plan_type IN ('Postpaid', 'Prepaid')
        AND s.start_date >= '2021-01-01'
GROUP BY c.customer_id , p.plan_id , e.employee_id , m.employee_id
HAVING total_services > 5
    AND total_data_usage > 100
    AND average_call_duration > 10
ORDER BY customer_name ASC , total_services DESC
LIMIT 100;",320,403,723,"['customers', 'addresses', 'services', 'plans', 'employees']","['customers', 'addresses', 'services', 'plans', 'employees']","['customers', 'addresses', 'services', 'plans', 'employees']","['customers', 'addresses', 'services', 'plans', 'employees']"
54,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT property.id AS property_id,
         property.name AS property_name,
         property.address AS property_address,
         property.bedrooms AS property_bedrooms,
         property.bathrooms AS property_bathrooms,
         property.price AS property_price,
         agent.name AS agent_name,
         agent.email AS agent_email
  FROM real_estate.property
  JOIN real_estate.agent ON property.agent_id = agent.id
  WHERE property.status = 'available'
),
cte2 AS (
  SELECT property_id,
         COUNT(*) AS num_inquiries
  FROM real_estate.inquiry
  GROUP BY property_id
),
cte3 AS (
  SELECT property_id,
         AVG(rating) AS avg_rating
  FROM real_estate.review
  GROUP BY property_id
),
cte4 AS (
  SELECT property_id,
         COUNT(*) AS num_bookings
  FROM real_estate.booking
  GROUP BY property_id
),
cte5 AS (
  SELECT property_id,
         COUNT(*) AS num_visits
  FROM real_estate.visit
  GROUP BY property_id
),
cte6 AS (
  SELECT property_id,
         COUNT(*) AS num_contracts
  FROM real_estate.contract
  GROUP BY property_id
),
cte7 AS (
  SELECT property_id,
         COUNT(*) AS num_payments
  FROM real_estate.payment
  GROUP BY property_id
),
cte8 AS (
  SELECT property_id,
         SUM(amount) AS total_payments
  FROM real_estate.payment
  GROUP BY property_id
),
cte9 AS (
  SELECT property_id,
         COUNT(*) AS num_complaints
  FROM real_estate.complaint
  GROUP BY property_id
),
cte10 AS (
  SELECT property_id,
         COUNT(*) AS num_repairs
  FROM real_estate.repair
  GROUP BY property_id
),
cte11 AS (
  SELECT property_id,
         COUNT(*) AS num_inspections
  FROM real_estate.inspection
  GROUP BY property_id
),
cte12 AS (
  SELECT property_id,
         COUNT(*) AS num_appraisals
  FROM real_estate.appraisal
  GROUP BY property_id
),
cte13 AS (
  SELECT property_id,
         COUNT(*) AS num_listings
  FROM real_estate.listing
  GROUP BY property_id
),
cte14 AS (
  SELECT property_id,
         COUNT(*) AS num_contracts
  FROM real_estate.contract
  GROUP BY property_id
),
cte15 AS (
  SELECT property_id,
         COUNT(*) AS num_documents
  FROM real_estate.document
  GROUP BY property_id
),
cte16 AS (
  SELECT property_id,
         COUNT(*) AS num_photos
  FROM real_estate.photo
  GROUP BY property_id
),
cte17 AS (
  SELECT property_id,
         COUNT(*) AS num_videos
  FROM real_estate.video
  GROUP BY property_id
),
cte18 AS (
  SELECT property_id,
         COUNT(*) AS num_floorplans
  FROM real_estate.floorplan
  GROUP BY property_id
),
cte19 AS (
  SELECT property_id,
         COUNT(*) AS num_virtual_tours
  FROM real_estate.virtual_tour
  GROUP BY property_id
),
cte20 AS (
  SELECT property_id,
         COUNT(*) AS num_reviews
  FROM real_estate.review
  GROUP BY property_id
),
cte21 AS (
  SELECT property_id,
         COUNT(*) AS num_ratings
  FROM real_estate.rating
  GROUP BY property_id
),
cte22 AS (
  SELECT property_id,
         COUNT(*) AS num_likes
  FROM real_estate.like
  GROUP BY property_id
),
cte23 AS (
  SELECT property_id,
         COUNT(*) AS num_dislikes
  FROM real_estate.dislike
  GROUP BY property_id
),
cte24 AS (
  SELECT property_id,
         COUNT(*) AS num_favorites
  FROM real_estate.favorite
  GROUP BY property_id
),
cte25 AS (
  SELECT property_id,
         COUNT(*) AS num_shares
  FROM real_estate.share
  GROUP BY property_id
),
cte26 AS (
  SELECT property_id,
         COUNT(*) AS num_comments
  FROM real_estate.comment
  GROUP BY property_id
),
cte27 AS (
  SELECT property_id,
         COUNT(*) AS num_inquiries
  FROM real_estate.inquiry
  GROUP BY property_id
),
cte28 AS (
  SELECT property_id,
         COUNT(*) AS num_offers
  FROM real_estate.offer
  GROUP BY property_id
),
cte29 AS (
  SELECT property_id,
         COUNT(*) AS num_sales
  FROM real_estate.sale
  GROUP BY property_id
),
cte30 AS (
  SELECT property_id,
         COUNT(*) AS num_rentals
  FROM real_estate.rental
  GROUP BY property_id
),
cte31 AS (
  SELECT property_id,
         COUNT(*) AS num_leases
  FROM real_estate.lease
  GROUP BY property_id
),
cte32 AS (
  SELECT property_id,
         COUNT(*) AS num_tenants
  FROM real_estate.tenant
  GROUP BY property_id
),
cte33 AS (
  SELECT property_id,
         COUNT(*) AS num_owners
  FROM real_estate.owner
  GROUP BY property_id
),
cte34 AS (
  SELECT property_id,
         COUNT(*) AS num_agents
  FROM real_estate.agent
  GROUP BY property_id
),
cte35 AS (
  SELECT property_id,
         COUNT(*) AS num_managers
  FROM real_estate.manager
  GROUP BY property_id
),
cte36 AS (
  SELECT property_id,
         COUNT(*) AS num_investors
  FROM real_estate.investor
  GROUP BY property_id
),
cte37 AS (
  SELECT property_id,
         COUNT(*) AS num_lenders
  FROM real_estate.lender
  GROUP BY property_id
),
cte38 AS (
  SELECT property_id,
         COUNT(*) AS num_insurers
  FROM real_estate.insurer
  GROUP BY property_id
),
cte39 AS (
  SELECT property_id,
         COUNT(*) AS num_appraisers
  FROM real_estate.appraiser
  GROUP BY property_id
),
cte40 AS (
  SELECT property_id,
         COUNT(*) AS num_inspectors
  FROM real_estate.inspector
  GROUP BY property_id
),
cte41 AS (
  SELECT property_id,
         COUNT(*) AS num_contractors
  FROM real_estate.contractor
  GROUP BY property_id
),
cte42 AS (
  SELECT property_id,
         COUNT(*) AS num_realtors
  FROM real_estate.realtor
  GROUP BY property_id
),
cte43 AS (
  SELECT property_id,
         COUNT(*) AS num_lawyers
  FROM real_estate.lawyer
  GROUP BY property_id
),
cte44 AS (
  SELECT property_id,
         COUNT(*) AS num_accountants
  FROM real_estate.accountant
  GROUP BY property_id
),
cte45 AS (
  SELECT property_id,
         COUNT(*) AS num_designers
  FROM real_estate.designer
  GROUP BY property_id
),
cte46 AS (
  SELECT property_id,
         COUNT(*) AS num_mortgages
  FROM real_estate.mortgage
  GROUP BY property_id
),
cte47 AS (
  SELECT property_id,
         COUNT(*) AS num_loans
  FROM real_estate.loan
  GROUP BY property_id
),
cte48 AS (
  SELECT property_id,
         COUNT(*) AS num_insurances
  FROM real_estate.insurance
  GROUP BY property_id
),
cte49 AS (
  SELECT property_id,
         COUNT(*) AS num_taxes
  FROM real_estate.tax
  GROUP BY property_id
),
cte50 AS (
  SELECT property_id,
         COUNT(*) AS num_utilities
  FROM real_estate.utility
  GROUP BY property_id
),
cte51 AS (
  SELECT property_id,
         COUNT(*) AS num_services
  FROM real_estate.service
  GROUP BY property_id
),
cte52 AS (
  SELECT property_id,
         COUNT(*) AS num_amenities
  FROM real_estate.amenity
  GROUP BY property_id
),
cte53 AS (
  SELECT property_id,
         COUNT(*) AS num_features
  FROM real_estate.feature
  GROUP BY property_id
),
cte54 AS (
  SELECT property_id,
         COUNT(*) AS num_neighborhoods
  FROM real_estate.neighborhood
  GROUP BY property_id
),
cte55 AS (
  SELECT property_id,
         COUNT(*) AS num_schools
  FROM real_estate.school
  GROUP BY property_id
),
cte56 AS (
  SELECT property_id,
         COUNT(*) AS num_hospitals
  FROM real_estate.hospital
  GROUP BY property_id
),
cte57 AS (
  SELECT property_id,
         COUNT(*) AS num_parks
  FROM real_estate.park
  GROUP BY property_id
),
cte58 AS (
  SELECT property_id,
         COUNT(*) AS num_shops
  FROM real_estate.shop
  GROUP BY property_id
),
cte59 AS (
  SELECT property_id,
         COUNT(*) AS num_restaurants
  FROM real_estate.restaurant
  GROUP BY property_id
),
cte60 AS (
  SELECT property_id,
         COUNT(*) AS num_transportation
  FROM real_estate.transportation
  GROUP BY property_id
),
cte61 AS (
  SELECT property_id,
         COUNT(*) AS num_entertainment
  FROM real_estate.entertainment
  GROUP BY property_id
),
cte62 AS (
  SELECT property_id,
         COUNT(*) AS num_recreational
  FROM real_estate.recreational
  GROUP BY property_id
),
cte63 AS (
  SELECT property_id,
         COUNT(*) AS num_gyms
  FROM real_estate.gym
  GROUP BY property_id
),
cte64 AS (
  SELECT property_id,
         COUNT(*) AS num_pools
  FROM real_estate.pool
  GROUP BY property_id
),
cte65 AS (
  SELECT property_id,
         COUNT(*) AS num_clubs
  FROM real_estate.club
  GROUP BY property_id
),
cte66 AS (
  SELECT property_id,
         COUNT(*) AS num_security
  FROM real_estate.security
  GROUP BY property_id
),
cte67 AS (
  SELECT property_id,
         COUNT(*) AS num_pets
  FROM real_estate.pet
  GROUP BY property_id
),
cte68 AS (
  SELECT property_id,
         COUNT(*) AS num_parking
  FROM real_estate.parking
  GROUP BY property_id
),
cte69 AS (
  SELECT property_id,
         COUNT(*) AS num_garages
  FROM real_estate.garage
  GROUP BY property_id
),
cte70 AS (
  SELECT property_id,
         COUNT(*) AS num_storage
  FROM real_estate.storage
  GROUP BY property_id
),
cte71 AS (
  SELECT property_id,
         COUNT(*) AS num_landscaping
  FROM real_estate.landscaping
  GROUP BY property_id
),
cte72 AS (
  SELECT property_id,
         COUNT(*) AS num_maintenance
  FROM real_estate.maintenance
  GROUP BY property_id
),
cte73 AS (
  SELECT property_id,
         COUNT(*) AS num_cleaning
  FROM real_estate.cleaning
  GROUP BY property_id
),
cte74 AS (
  SELECT property_id,
         COUNT(*) AS num_utilities
  FROM real_estate.utility
  GROUP BY property_id
),
cte75 AS (
  SELECT property_id,
         COUNT(*) AS num_internet
  FROM real_estate.internet
  GROUP BY property_id
),
cte76 AS (
  SELECT property_id,
         COUNT(*) AS num_tv
  FROM real_estate.tv
  GROUP BY property_id
),
cte77 AS (
  SELECT property_id,
         COUNT(*) AS num_phone
  FROM real_estate.phone
  GROUP BY property_id
),
cte78 AS (
  SELECT property_id,
         COUNT(*) AS num_electricity
  FROM real_estate.electricity
  GROUP BY property_id
),
cte79 AS (
  SELECT property_id,
         COUNT(*) AS num_water
  FROM real_estate.water
  GROUP BY property_id
),
cte80 AS (
  SELECT property_id,
         COUNT(*) AS num_gas
  FROM real_estate.gas
  GROUP BY property_id
),
cte81 AS (
  SELECT property_id,
         COUNT(*) AS num_sewage
  FROM real_estate.sewage
  GROUP BY property_id
),
cte82 AS (
  SELECT property_id,
         COUNT(*) AS num_heating
  FROM real_estate.heating
  GROUP BY property_id
),
cte83 AS (
  SELECT property_id,
         COUNT(*) AS num_cooling
  FROM real_estate.cooling
  GROUP BY property_id
),
cte84 AS (
  SELECT property_id,
         COUNT(*) AS num_security
  FROM real_estate.security
  GROUP BY property_id
),
cte85 AS (
  SELECT property_id,
         COUNT(*) AS num_fire
  FROM real_estate.fire
  GROUP BY property_id
),
cte86 AS (
  SELECT property_id,
         COUNT(*) AS num_insurance
  FROM real_estate.insurance
  GROUP BY property_id
),
cte87 AS (
  SELECT property_id,
         COUNT(*) AS num_taxes
  FROM real_estate.tax
  GROUP BY property_id
),
cte88 AS (
  SELECT property_id,
         COUNT(*) AS num_maintenance
  FROM real_estate.maintenance
  GROUP BY property_id
),
cte89 AS (
  SELECT property_id,
         COUNT(*) AS num_cleaning
  FROM real_estate.cleaning
  GROUP BY property_id
),
cte90 AS (
  SELECT property_id,
         COUNT(*) AS num_landscaping
  FROM real_estate.landscaping
  GROUP BY property_id
),
cte91 AS (
  SELECT property_id,
         COUNT(*) AS num_parking
  FROM real_estate.parking
  GROUP BY property_id
),
cte92 AS (
  SELECT property_id,
         COUNT(*) AS num_garages
  FROM real_estate.garage
  GROUP BY property_id
),
cte93 AS (
  SELECT property_id,
         COUNT(*) AS num_storage
  FROM real_estate.storage
  GROUP BY property_id
),
cte94 AS (
  SELECT property_id,
         COUNT(*) AS num_landlords
  FROM real_estate.landlord
  GROUP BY property_id
),
cte95 AS (
  SELECT property_id,
         COUNT(*) AS num_tenants
  FROM real_estate.tenant
  GROUP BY property_id
),
cte96 AS (
  SELECT property_id,
         COUNT(*) AS num_owners
  FROM real_estate.owner
  GROUP BY property_id
),
cte97 AS (
  SELECT property_id,
         COUNT(*) AS num_agents
  FROM real_estate.agent
  GROUP BY property_id
),
cte98 AS (
  SELECT property_id,
         COUNT(*) AS num_managers
  FROM real_estate.manager
  GROUP BY property_id
),
cte99 AS (
  SELECT property_id,
         COUNT(*) AS num_investors
  FROM real_estate.investor
  GROUP BY property_id
),
cte100 AS (
  SELECT property_id,
         COUNT(*) AS num_lenders
  FROM real_estate.lender
  GROUP BY property_id
),
cte101 AS (
  SELECT property_id,
         COUNT(*) AS num_insurers
  FROM real_estate.insurer
  GROUP BY property_id
),
cte102 AS (
  SELECT property_id,
         COUNT(*) AS num_appraisers
  FROM real_estate.appraiser
  GROUP BY property_id
),
cte103 AS (
  SELECT property_id,
         COUNT(*) AS num_inspectors
  FROM real_estate.inspector
  GROUP BY property_id
),
cte104 AS (
  SELECT property_id,
         COUNT(*) AS num_contractors
  FROM real_estate.contractor
  GROUP BY property_id
),
cte105 AS (
  SELECT property_id,
         COUNT(*) AS num_realtors
  FROM real_estate.realtor
  GROUP BY property_id
),
cte106 AS (
  SELECT property_id,
         COUNT(*) AS num_lawyers
  FROM real_estate.lawyer
  GROUP BY property_id
),
cte107 AS (
  SELECT property_id,
         COUNT(*) AS num_accountants
  FROM real_estate.accountant
  GROUP BY property_id
),
cte108 AS (
  SELECT property_id,
         COUNT(*) AS num_designers
  FROM real_estate.designer
  GROUP BY property_id
),
cte109 AS (
  SELECT property_id,
         COUNT(*) AS num_mortgages
  FROM real_estate.mortgage
  GROUP BY property_id
),
cte110 AS (
  SELECT property_id,
         COUNT(*) AS num_loans
  FROM real_estate.loan
  GROUP BY property_id
),
cte111 AS (
  SELECT property_id,
         COUNT(*) AS num_insurances
  FROM real_estate.insurance
  GROUP BY property_id
),
cte112 AS (
  SELECT property_id,
         COUNT(*) AS num_taxes
  FROM real_estate.tax
  GROUP BY property_id
),
cte113 AS (
  SELECT property_id,
         COUNT(*) AS num_utilities
  FROM real_estate.utility
  GROUP BY property_id
),
cte114 AS (
 ",316,3782,4098,"[""real_estate.property"", ""real_estate.agent"", ""real_estate.inquiry"", ""real_estate.review"", ""real_estate.booking"", ""real_estate.visit"", ""real_estate.contract"", ""real_estate.payment"", ""real_estate.complaint"", ""real_estate.repair"", ""real_estate.inspection"", ""real_estate.appraisal"", ""real_estate.listing"", ""real_estate.document"", ""real_estate.photo"", ""real_estate.video"", ""real_estate.floorplan"", ""real_estate.virtual_tour"", ""real_estate.rating"", ""real_estate.like"", ""real_estate.dislike"", ""real_estate.favorite"", ""real_estate.share"", ""real_estate.comment"", ""real_estate.offer"", ""real_estate.sale"", ""real_estate.rental"", ""real_estate.lease"", ""real_estate.tenant"", ""real_estate.owner"",","[""real_estate.property"", ""real_estate.agent"", ""real_estate.inquiry"", ""real_estate.review"", ""real_estate.booking"", ""real_estate.visit"", ""real_estate.contract"", ""real_estate.payment"", ""real_estate.complaint"", ""real_estate.repair"", ""real_estate.inspection"", ""real_estate.appraisal"", ""real_estate.listing"", ""real_estate.document"", ""real_estate.photo"", ""real_estate.video"", ""real_estate.floorplan"", ""real_estate.virtual_tour"", ""real_estate.rating"", ""real_estate.like"", ""real_estate.dislike"", ""real_estate.favorite"", ""real_estate.share"", ""real_estate.comment"", ""real_estate.offer"", ""real_estate.sale"", ""real_estate.rental"", ""real_estate.lease"", ""real_estate.tenant"", ""real_estate.owner"",","[""real_estate.property"", ""real_estate.agent"", ""real_estate.inquiry"", ""real_estate.review"", ""real_estate.booking"", ""real_estate.visit"", ""real_estate.contract"", ""real_estate.payment"", ""real_estate.complaint"", ""real_estate.repair"", ""real_estate.inspection"", ""real_estate.appraisal"", ""real_estate.listing"", ""real_estate.document"", ""real_estate.photo"", ""real_estate.video"", ""real_estate.floorplan"", ""real_estate.virtual_tour"", ""real_estate.rating"", ""real_estate.like"", ""real_estate.dislike"", ""real_estate.favorite"", ""real_estate.share"", ""real_estate.comment"", ""real_estate.offer"", ""real_estate.sale"", ""real_estate.rental"", ""real_estate.lease"", ""real_estate.tenant"", ""real_estate.owner"",","[""real_estate.property"", ""real_estate.agent"", ""real_estate.inquiry"", ""real_estate.review"", ""real_estate.booking"", ""real_estate.visit"", ""real_estate.contract"", ""real_estate.payment"", ""real_estate.complaint"", ""real_estate.repair"", ""real_estate.inspection"", ""real_estate.appraisal"", ""real_estate.listing"", ""real_estate.document"", ""real_estate.photo"", ""real_estate.video"", ""real_estate.floorplan"", ""real_estate.virtual_tour"", ""real_estate.rating"", ""real_estate.like"", ""real_estate.dislike"", ""real_estate.favorite"", ""real_estate.share"", ""real_estate.comment"", ""real_estate.offer"", ""real_estate.sale"", ""real_estate.rental"", ""real_estate.lease"", ""real_estate.tenant"", ""real_estate.owner"","
55,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_patient AS (
  SELECT 
    p.patient_id,
    p.patient_name,
    p.date_of_birth,
    p.gender,
    p.address,
    p.phone_number,
    p.email
  FROM 
    healthcare_database.patients p
  WHERE 
    p.date_of_birth <= DATE_SUB(CURRENT_DATE(), INTERVAL 18 YEAR)
),

cte_appointment AS (
  SELECT 
    a.appointment_id,
    a.patient_id,
    a.appointment_date,
    a.appointment_time,
    a.doctor_id,
    a.department_id,
    a.reason
  FROM 
    healthcare_database.appointments a
  WHERE 
    a.appointment_date >= CURRENT_DATE()
),

cte_doctor AS (
  SELECT 
    d.doctor_id,
    d.doctor_name,
    d.specialty,
    d.department_id,
    d.years_of_experience,
    d.education
  FROM 
    healthcare_database.doctors d
),

cte_department AS (
  SELECT 
    dep.department_id,
    dep.department_name,
    dep.location,
    dep.head_doctor_id
  FROM 
    healthcare_database.departments dep
),

cte_prescription AS (
  SELECT 
    pr.prescription_id,
    pr.patient_id,
    pr.doctor_id,
    pr.prescription_date,
    pr.medication_name,
    pr.dosage,
    pr.frequency
  FROM 
    healthcare_database.prescriptions pr
),

cte_medication AS (
  SELECT 
    m.medication_id,
    m.medication_name,
    m.manufacturer,
    m.price_per_unit
  FROM 
    healthcare_database.medications m
),

cte_invoice AS (
  SELECT 
    i.invoice_id,
    i.patient_id,
    i.invoice_date,
    i.total_amount,
    i.payment_status
  FROM 
    healthcare_database.invoices i
),

cte_payment AS (
  SELECT 
    p.payment_id,
    p.invoice_id,
    p.payment_date,
    p.payment_amount,
    p.payment_method
  FROM 
    healthcare_database.payments p
),

cte_diagnosis AS (
  SELECT 
    d.diagnosis_id,
    d.patient_id,
    d.doctor_id,
    d.diagnosis_date,
    d.diagnosis_description
  FROM 
    healthcare_database.diagnoses d
),

cte_lab_test AS (
  SELECT 
    lt.lab_test_id,
    lt.patient_id,
    lt.doctor_id,
    lt.test_date,
    lt.test_name,
    lt.result
  FROM 
    healthcare_database.lab_tests lt
),

cte_treatment AS (
  SELECT 
    t.treatment_id,
    t.patient_id,
    t.doctor_id,
    t.treatment_date,
    t.treatment_description
  FROM 
    healthcare_database.treatments t
),

cte_patient_summary AS (
  SELECT 
    p.patient_id,
    COUNT(DISTINCT a.appointment_id) AS total_appointments,
    COUNT(DISTINCT pr.prescription_id) AS total_prescriptions,
    COUNT(DISTINCT i.invoice_id) AS total_invoices,
    COUNT(DISTINCT d.diagnosis_id) AS total_diagnoses,
    COUNT(DISTINCT lt.lab_test_id) AS total_lab_tests,
    COUNT(DISTINCT t.treatment_id) AS total_treatments
  FROM 
    cte_patient p
    LEFT JOIN cte_appointment a ON p.patient_id = a.patient_id
    LEFT JOIN cte_prescription pr ON p.patient_id = pr.patient_id
    LEFT JOIN cte_invoice i ON p.patient_id = i.patient_id
    LEFT JOIN cte_diagnosis d ON p.patient_id = d.patient_id
    LEFT JOIN cte_lab_test lt ON p.patient_id = lt.patient_id
    LEFT JOIN cte_treatment t ON p.patient_id = t.patient_id
  GROUP BY 
    p.patient_id
  HAVING 
    total_appointments > 5
),

cte_doctor_summary AS (
  SELECT 
    d.doctor_id,
    d.doctor_name,
    d.specialty,
    COUNT(DISTINCT a.appointment_id) AS total_appointments,
    COUNT(DISTINCT pr.prescription_id) AS total_prescriptions,
    COUNT(DISTINCT dpt.department_id) AS total_departments,
    COUNT(DISTINCT lt.lab_test_id) AS total_lab_tests,
    COUNT(DISTINCT t.treatment_id) AS total_treatments
  FROM 
    cte_doctor d
    LEFT JOIN cte_appointment a ON d.doctor_id = a.doctor_id
    LEFT JOIN cte_prescription pr ON d.doctor_id = pr.doctor_id
    LEFT JOIN cte_department dpt ON d.department_id = dpt.department_id
    LEFT JOIN cte_lab_test lt ON d.doctor_id = lt.doctor_id
    LEFT JOIN cte_treatment t ON d.doctor_id = t.doctor_id
  GROUP BY 
    d.doctor_id
  HAVING 
    total_appointments > 10
),

cte_department_summary AS (
  SELECT 
    dep.department_id,
    dep.department_name,
    COUNT(DISTINCT d.doctor_id) AS total_doctors,
    COUNT(DISTINCT a.appointment_id) AS total_appointments,
    COUNT(DISTINCT pr.prescription_id) AS total_prescriptions,
    COUNT(DISTINCT lt.lab_test_id) AS total_lab_tests,
    COUNT(DISTINCT t.treatment_id) AS total_treatments
  FROM 
    cte_department dep
    LEFT JOIN cte_doctor d ON dep.department_id = d.department_id
    LEFT JOIN cte_appointment a ON dep.department_id = a.department_id
    LEFT JOIN cte_prescription pr ON dep.department_id = pr.department_id
    LEFT JOIN cte_lab_test lt ON dep.department_id = lt.department_id
    LEFT JOIN cte_treatment t ON dep.department_id = t.department_id
  GROUP BY 
    dep.department_id
  HAVING 
    total_doctors > 5
),

cte_medication_summary AS (
  SELECT 
    m.medication_id,
    m.medication_name,
    COUNT(DISTINCT pr.prescription_id) AS total_prescriptions,
    SUM(pr.dosage) AS total_dosage,
    COUNT(DISTINCT i.invoice_id) AS total_invoices,
    SUM(i.total_amount) AS total_amount
  FROM 
    cte_medication m
    LEFT JOIN cte_prescription pr ON m.medication_name = pr.medication_name
    LEFT JOIN cte_invoice i ON m.medication_name = i.medication_name
  GROUP BY 
    m.medication_id
  HAVING 
    total_prescriptions > 100
),

cte_payment_summary AS (
  SELECT 
    p.payment_id,
    p.payment_method,
    COUNT(DISTINCT i.invoice_id) AS total_invoices,
    SUM(i.total_amount) AS total_amount
  FROM 
    cte_payment p
    LEFT JOIN cte_invoice i ON p.invoice_id = i.invoice_id
  GROUP BY 
    p.payment_id
  HAVING 
    total_invoices > 50
)

SELECT 
  ps.patient_id,
  ps.patient_name,
  ps.date_of_birth,
  ps.gender,
  ps.address,
  ps.phone_number,
  ps.email,
  ds.doctor_id,
  ds.doctor_name,
  ds.specialty,
  ds.years_of_experience,
  ds.education,
  dpts.department_id,
  dpts.department_name,
  dpts.location,
  dpts.head_doctor_id,
  ms.medication_id,
  ms.medication_name,
  ms.manufacturer,
  ms.price_per_unit,
  is.invoice_id,
  is.invoice_date,
  is.total_amount,
  is.payment_status,
  ps.total_appointments,
  ps.total_prescriptions,
  ps.total_invoices,
  ps.total_diagnoses,
  ps.total_lab_tests,
  ps.total_treatments,
  ds.total_appointments,
  ds.total_prescriptions,
  ds.total_departments,
  ds.total_lab_tests,
  ds.total_treatments,
  dpts.total_doctors,
  dpts.total_appointments,
  dpts.total_prescriptions,
  dpts.total_lab_tests,
  dpts.total_treatments,
  ms.total_prescriptions,
  ms.total_dosage,
  ms.total_invoices,
  ms.total_amount,
  ps.total_appointments + ds.total_appointments + dpts.total_appointments AS total_all_appointments,
  ps.total_prescriptions + ds.total_prescriptions + ms.total_prescriptions AS total_all_prescriptions,
  ps.total_invoices + dpts.total_invoices + ms.total_invoices + is.total_invoices AS total_all_invoices,
  ps.total_diagnoses + ds.total_lab_tests + dpts.total_lab_tests AS total_all_diagnoses,
  ps.total_lab_tests + ds.total_lab_tests + dpts.total_lab_tests + ms.total_lab_tests AS total_all_lab_tests,
  ps.total_treatments + ds.total_treatments + dpts.total_treatments AS total_all_treatments,
  is.total_amount + ms.total_amount AS total_all_amount
FROM 
  cte_patient_summary ps
  CROSS JOIN cte_doctor_summary ds
  CROSS JOIN cte_department_summary dpts
  CROSS JOIN cte_medication_summary ms
  CROSS JOIN cte_invoice is
WHERE 
  ps.patient_id = ds.doctor_id
  AND ds.department_id = dpts.department_id
  AND ms.medication_id = is.invoice_id
  AND ps.total_appointments + ds.total_appointments + dpts.total_appointments > 50
  AND ps.total_prescriptions + ds.total_prescriptions + ms.total_prescriptions > 100
  AND ps.total_invoices + dpts.total_invoices + ms.total_invoices + is.total_invoices > 200
  AND ps.total_diagnoses + ds.total_lab_tests + dpts.total_lab_tests > 50
  AND ps.total_lab_tests + ds.total_lab_tests + dpts.total_lab_tests + ms.total_lab_tests > 100
  AND ps.total_treatments + ds.total_treatments + dpts.total_treatments > 50
  AND is.total_amount + ms.total_amount > 10000;",321,2148,2469,"['healthcare_database.patients', 'healthcare_database.appointments', 'healthcare_database.doctors', 'healthcare_database.departments', 'healthcare_database.prescriptions', 'healthcare_database.medications', 'healthcare_database.invoices', 'healthcare_database.payments', 'healthcare_database.diagnoses', 'healthcare_database.lab_tests', 'healthcare_database.treatments']","['healthcare_database.patients', 'healthcare_database.appointments', 'healthcare_database.doctors', 'healthcare_database.departments', 'healthcare_database.prescriptions', 'healthcare_database.medications', 'healthcare_database.invoices', 'healthcare_database.payments', 'healthcare_database.diagnoses', 'healthcare_database.lab_tests', 'healthcare_database.treatments']","['healthcare_database.patients', 'healthcare_database.appointments', 'healthcare_database.doctors', 'healthcare_database.departments', 'healthcare_database.prescriptions', 'healthcare_database.medications', 'healthcare_database.invoices', 'healthcare_database.payments', 'healthcare_database.diagnoses', 'healthcare_database.lab_tests', 'healthcare_database.treatments']","['healthcare_database.patients', 'healthcare_database.appointments', 'healthcare_database.doctors', 'healthcare_database.departments', 'healthcare_database.prescriptions', 'healthcare_database.medications', 'healthcare_database.invoices', 'healthcare_database.payments', 'healthcare_database.diagnoses', 'healthcare_database.lab_tests', 'healthcare_database.treatments']"
56,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH 
    cte_orders AS (
        SELECT 
            o.order_id,
            o.order_date,
            o.customer_id,
            o.total_price
        FROM 
            ecommerce.orders o
        WHERE 
            o.order_date >= '2021-01-01'
    ),
    cte_customers AS (
        SELECT 
            c.customer_id,
            c.customer_name,
            c.city,
            c.state
        FROM 
            ecommerce.customers c
    ),
    cte_products AS (
        SELECT 
            p.product_id,
            p.product_name,
            p.category,
            p.unit_price
        FROM 
            ecommerce.products p
    ),
    cte_order_details AS (
        SELECT 
            od.order_id,
            od.product_id,
            od.quantity,
            od.unit_price
        FROM 
            ecommerce.order_details od
    )
SELECT 
    c.customer_name,
    c.city,
    c.state,
    COUNT(DISTINCT o.order_id) AS TotalOrders,
    SUM(od.quantity) AS TotalItems,
    SUM(od.quantity * od.unit_price) AS TotalRevenue
FROM 
    cte_customers c
JOIN 
    cte_orders o ON c.customer_id = o.customer_id
JOIN 
    cte_order_details od ON o.order_id = od.order_id
JOIN 
    cte_products p ON od.product_id = p.product_id
WHERE 
    p.category = 'Electronics'
GROUP BY 
    c.customer_name,
    c.city,
    c.state
HAVING 
    COUNT(DISTINCT o.order_id) > 2
ORDER BY 
    TotalRevenue DESC;",316,332,648,"['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products', 'ecommerce.order_details']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products', 'ecommerce.order_details']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products', 'ecommerce.order_details']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products', 'ecommerce.order_details']"
57,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","WITH total_sales AS (
  SELECT
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    SUM(o.total_price) AS total_sales
  FROM
    customers c
    JOIN orders o ON c.customer_id = o.customer_id
  WHERE
    o.order_date >= '2021-01-01'
  GROUP BY
    c.first_name,
    c.last_name
),

average_price AS (
  SELECT
    p.property_id,
    AVG(p.price) AS avg_price
  FROM
    properties p
    JOIN property_types pt ON p.property_type_id = pt.property_type_id
  WHERE
    pt.property_type = 'House'
  GROUP BY
    p.property_id
),

top_agents AS (
  SELECT
    CONCAT(a.first_name, ' ', a.last_name) AS agent_name,
    COUNT(*) AS total_sales
  FROM
    agents a
    JOIN orders o ON a.agent_id = o.agent_id
  WHERE
    o.order_date >= '2021-01-01'
  GROUP BY
    a.first_name,
    a.last_name
  HAVING
    COUNT(*) > 10
),

property_stats AS (
  SELECT
    p.property_id,
    COUNT(*) AS total_visits,
    MAX(v.visit_date) AS last_visit
  FROM
    properties p
    JOIN visits v ON p.property_id = v.property_id
  WHERE
    v.visit_date >= '2021-01-01'
  GROUP BY
    p.property_id
),

final_query AS (
  SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    c.phone_number,
    ts.total_sales,
    ap.avg_price,
    ta.total_sales AS agent_sales,
    ps.total_visits,
    ps.last_visit
  FROM
    customers c
    JOIN total_sales ts ON c.customer_id = ts.customer_id
    JOIN average_price ap ON c.customer_id = ap.customer_id
    JOIN top_agents ta ON c.customer_id = ta.customer_id
    JOIN property_stats ps ON c.customer_id = ps.customer_id
  WHERE
    c.registration_date >= '2021-01-01'
    AND c.city = 'New York'
    AND c.state = 'NY'
    AND c.country = 'USA'
)
SELECT
  customer_id,
  CONCAT(first_name, ' ', last_name) AS customer_name,
  email,
  phone_number,
  total_sales,
  avg_price,
  agent_sales,
  total_visits,
  DATE_FORMAT(last_visit, '%Y-%m-%d') AS last_visit_formatted
FROM
  final_query
ORDER BY
  total_sales DESC,
  avg_price DESC,
  agent_sales DESC,
  total_visits DESC
LIMIT 100;",319,579,898,"['customers', 'orders', 'properties', 'property_types', 'agents', 'visits']","['customers', 'orders', 'properties', 'property_types', 'agents', 'visits']","['customers', 'orders', 'properties', 'property_types', 'agents', 'visits']","['customers', 'orders', 'properties', 'property_types', 'agents', 'visits']"
58,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price
  FROM 
    manufacturing.orders o
  WHERE 
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

cte_customers AS (
  SELECT 
    c.customer_id,
    c.customer_name,
    c.city,
    c.state
  FROM 
    manufacturing.customers c
),

cte_products AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.category,
    p.unit_price
  FROM 
    manufacturing.products p
),

cte_order_details AS (
  SELECT 
    od.order_id,
    od.product_id,
    od.quantity,
    od.unit_price
  FROM 
    manufacturing.order_details od
),

cte_sales AS (
  SELECT 
    o.order_id,
    o.order_date,
    c.customer_name,
    c.city,
    c.state,
    SUM(od.quantity * od.unit_price) AS total_sales
  FROM 
    cte_orders o
    JOIN cte_customers c ON o.customer_id = c.customer_id
    JOIN cte_order_details od ON o.order_id = od.order_id
  WHERE 
    c.state IN ('CA', 'NY', 'TX')
  GROUP BY 
    o.order_id,
    o.order_date,
    c.customer_name,
    c.city,
    c.state
),

cte_top_customers AS (
  SELECT 
    customer_name,
    SUM(total_sales) AS total_sales
  FROM 
    cte_sales
  GROUP BY 
    customer_name
  HAVING 
    SUM(total_sales) > 10000
),

cte_top_products AS (
  SELECT 
    p.product_name,
    SUM(od.quantity) AS total_quantity
  FROM 
    cte_order_details od
    JOIN cte_products p ON od.product_id = p.product_id
  GROUP BY 
    p.product_name
  HAVING 
    SUM(od.quantity) > 100
),

cte_monthly_sales AS (
  SELECT 
    DATE_FORMAT(o.order_date, '%Y-%m') AS month,
    SUM(o.total_price) AS total_sales
  FROM 
    cte_orders o
  GROUP BY 
    DATE_FORMAT(o.order_date, '%Y-%m')
),

cte_average_sales AS (
  SELECT 
    AVG(total_sales) AS average_sales
  FROM 
    cte_monthly_sales
),

cte_final AS (
  SELECT 
    tc.customer_name,
    tp.product_name,
    ms.month,
    ms.total_sales,
    as.average_sales
  FROM 
    cte_top_customers tc
    CROSS JOIN cte_top_products tp
    JOIN cte_monthly_sales ms ON 1 = 1
    JOIN cte_average_sales as ON 1 = 1
)

SELECT 
  final.customer_name,
  final.product_name,
  final.month,
  final.total_sales,
  final.average_sales
FROM 
  cte_final final
ORDER BY 
  final.total_sales DESC;",325,648,973,"['manufacturing.orders', 'manufacturing.customers', 'manufacturing.products', 'manufacturing.order_details']","['manufacturing.orders', 'manufacturing.customers', 'manufacturing.products', 'manufacturing.order_details']","['manufacturing.orders', 'manufacturing.customers', 'manufacturing.products', 'manufacturing.order_details']","['manufacturing.orders', 'manufacturing.customers', 'manufacturing.products', 'manufacturing.order_details']"
59,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_patient AS (
  SELECT 
    p.patient_id,
    p.patient_name,
    p.date_of_birth,
    p.gender,
    p.address,
    p.phone_number,
    p.email,
    p.insurance_provider
  FROM 
    healthcare.company.patient AS p
  WHERE 
    p.insurance_provider = 'XYZ Insurance'
),

cte_appointment AS (
  SELECT 
    a.appointment_id,
    a.patient_id,
    a.appointment_date,
    a.appointment_time,
    a.doctor_id,
    a.department_id,
    a.reason_for_visit
  FROM 
    healthcare.company.appointment AS a
  WHERE 
    a.appointment_date >= CURDATE()
),

cte_doctor AS (
  SELECT 
    d.doctor_id,
    d.doctor_name,
    d.specialty,
    d.department_id,
    d.years_of_experience,
    d.education
  FROM 
    healthcare.company.doctor AS d
),

cte_department AS (
  SELECT 
    dept.department_id,
    dept.department_name,
    dept.location,
    dept.head_doctor_id
  FROM 
    healthcare.company.department AS dept
),

cte_prescription AS (
  SELECT 
    pr.prescription_id,
    pr.patient_id,
    pr.doctor_id,
    pr.prescription_date,
    pr.medication_name,
    pr.dosage,
    pr.frequency
  FROM 
    healthcare.company.prescription AS pr
),

cte_medication AS (
  SELECT 
    m.medication_id,
    m.medication_name,
    m.manufacturer,
    m.unit_price,
    m.expiry_date
  FROM 
    healthcare.company.medication AS m
),

cte_invoice AS (
  SELECT 
    i.invoice_id,
    i.patient_id,
    i.invoice_date,
    i.total_amount,
    i.payment_status
  FROM 
    healthcare.company.invoice AS i
),

cte_payment AS (
  SELECT 
    p.payment_id,
    p.invoice_id,
    p.payment_date,
    p.payment_amount,
    p.payment_method
  FROM 
    healthcare.company.payment AS p
),

cte_lab_test AS (
  SELECT 
    lt.test_id,
    lt.patient_id,
    lt.doctor_id,
    lt.test_date,
    lt.test_name,
    lt.result
  FROM 
    healthcare.company.lab_test AS lt
),

cte_doctor_patient AS (
  SELECT 
    dp.doctor_id,
    dp.patient_id
  FROM 
    healthcare.company.doctor_patient AS dp
),

cte_doctor_department AS (
  SELECT 
    dd.doctor_id,
    dd.department_id
  FROM 
    healthcare.company.doctor_department AS dd
),

cte_department_patient AS (
  SELECT 
    dp.department_id,
    dp.patient_id
  FROM 
    healthcare.company.department_patient AS dp
)

SELECT 
  p.patient_name,
  p.date_of_birth,
  p.gender,
  p.address,
  p.phone_number,
  p.email,
  p.insurance_provider,
  CONCAT(d.doctor_name, ' - ', d.specialty) AS treating_doctor,
  dept.department_name,
  COUNT(DISTINCT a.appointment_id) AS total_appointments,
  COUNT(DISTINCT pr.prescription_id) AS total_prescriptions,
  COUNT(DISTINCT i.invoice_id) AS total_invoices,
  SUM(i.total_amount) AS total_amount_billed,
  COUNT(DISTINCT pmt.payment_id) AS total_payments,
  SUM(pmt.payment_amount) AS total_amount_paid,
  COUNT(DISTINCT lt.test_id) AS total_lab_tests
FROM 
  cte_patient AS p
  LEFT JOIN cte_appointment AS a ON p.patient_id = a.patient_id
  LEFT JOIN cte_doctor AS d ON a.doctor_id = d.doctor_id
  LEFT JOIN cte_department AS dept ON a.department_id = dept.department_id
  LEFT JOIN cte_prescription AS pr ON p.patient_id = pr.patient_id
  LEFT JOIN cte_invoice AS i ON p.patient_id = i.patient_id
  LEFT JOIN cte_payment AS pmt ON i.invoice_id = pmt.invoice_id
  LEFT JOIN cte_lab_test AS lt ON p.patient_id = lt.patient_id
  LEFT JOIN cte_doctor_patient AS dp ON d.doctor_id = dp.doctor_id
  LEFT JOIN cte_doctor_department AS dd ON d.doctor_id = dd.doctor_id
  LEFT JOIN cte_department_patient AS dp ON dept.department_id = dp.department_id
WHERE 
  p.gender = 'Female'
  AND d.years_of_experience >= 5
  AND pr.prescription_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
  AND i.payment_status = 'Paid'
GROUP BY 
  p.patient_id,
  p.patient_name,
  p.date_of_birth,
  p.gender,
  p.address,
  p.phone_number,
  p.email,
  p.insurance_provider,
  d.doctor_name,
  d.specialty,
  dept.department_name
HAVING 
  total_appointments > 3
  AND total_prescriptions > 2
  AND total_invoices > 1
  AND total_amount_billed > 1000
  AND total_payments > 1
  AND total_amount_paid > 500
  AND total_lab_tests > 0;",315,1111,1426,"['healthcare.company.patient', 'healthcare.company.appointment', 'healthcare.company.doctor', 'healthcare.company.department', 'healthcare.company.prescription', 'healthcare.company.medication', 'healthcare.company.invoice', 'healthcare.company.payment', 'healthcare.company.lab_test', 'healthcare.company.doctor_patient', 'healthcare.company.doctor_department', 'healthcare.company.department_patient']","['healthcare.company.patient', 'healthcare.company.appointment', 'healthcare.company.doctor', 'healthcare.company.department', 'healthcare.company.prescription', 'healthcare.company.medication', 'healthcare.company.invoice', 'healthcare.company.payment', 'healthcare.company.lab_test', 'healthcare.company.doctor_patient', 'healthcare.company.doctor_department', 'healthcare.company.department_patient']","['healthcare.company.patient', 'healthcare.company.appointment', 'healthcare.company.doctor', 'healthcare.company.department', 'healthcare.company.prescription', 'healthcare.company.medication', 'healthcare.company.invoice', 'healthcare.company.payment', 'healthcare.company.lab_test', 'healthcare.company.doctor_patient', 'healthcare.company.doctor_department', 'healthcare.company.department_patient']","['healthcare.company.patient', 'healthcare.company.appointment', 'healthcare.company.doctor', 'healthcare.company.department', 'healthcare.company.prescription', 'healthcare.company.medication', 'healthcare.company.invoice', 'healthcare.company.payment', 'healthcare.company.lab_test', 'healthcare.company.doctor_patient', 'healthcare.company.doctor_department', 'healthcare.company.department_patient']"
60,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.product_category,
    SUM(o.quantity) AS total_quantity
  FROM 
    production['|'].products AS p
  JOIN 
    sales['|'].orders AS o ON p.product_id = o.product_id
  WHERE 
    o.order_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
  GROUP BY 
    p.product_id,
    p.product_name,
    p.product_category
),

cte2 AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.product_category,
    AVG(o.unit_price) AS avg_unit_price
  FROM 
    production.products AS p
  JOIN 
    sales.orders AS o ON p.product_id = o.product_id
  WHERE 
    o.order_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
  GROUP BY 
    p.product_id,
    p.product_name,
    p.product_category
),

cte3 AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.product_category,
    COUNT(o.order_id) AS total_orders
  FROM 
    production.products AS p
  JOIN 
    sales.orders AS o ON p.product_id = o.product_id
  WHERE 
    o.order_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
  GROUP BY 
    p.product_id,
    p.product_name,
    p.product_category
)

SELECT 
  cte1.product_id,
  cte1.product_name,
  cte1.product_category,
  cte1.total_quantity,
  cte2.avg_unit_price,
  cte3.total_orders,
  CONCAT('Category: ', UPPER(cte1.product_category)) AS category_label
FROM 
  cte1
JOIN 
  cte2 ON cte1.product_id = cte2.product_id
JOIN 
  cte3 ON cte1.product_id = cte3.product_id
CROSS JOIN 
  production['|'].manufacturers AS m
WHERE 
  m.manufacturer_id = cte1.product_id
HAVING 
  cte1.total_quantity > 100
ORDER BY 
  cte1.total_quantity DESC;",321,466,787,"['production.products', 'sales.orders', 'production.manufacturers']","['production.products', 'sales.orders', 'production.manufacturers']","['production.products', 'sales.orders', 'production.manufacturers']","['production.products', 'sales.orders', 'production.manufacturers']"
61,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.product_name, ' - ', p.product_code) AS product_info,
    c.category_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.quantity) AS total_quantity,
    SUM(o.quantity * p.unit_price) AS total_revenue,
    AVG(o.quantity) AS avg_quantity,
    AVG(p.unit_price) AS avg_price,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date
FROM
    pharmaceuticals.products p
    INNER JOIN pharmaceuticals.categories c ON p.category_id = c.category_id
    LEFT JOIN (
        SELECT 
            o.order_id,
            o.product_id,
            o.quantity,
            o.order_date
        FROM
            pharmaceuticals.orders o
        WHERE
            o.order_date >= '2021-01-01'
    ) o ON p.product_id = o.product_id
WHERE
    p.is_active = 1
    AND c.category_name IN ('Antibiotics', 'Painkillers')
GROUP BY
    p.product_name,
    p.product_code,
    c.category_name,
    DATE_FORMAT(o.order_date, '%Y-%m-%d')
HAVING
    total_quantity > 100
    AND total_revenue > 5000
ORDER BY
    total_revenue DESC,
    avg_quantity ASC
LIMIT 10;",319,282,601,"['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.orders']"
62,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.first_name, ' ', p.last_name) AS patient_name,
    CONCAT(d.first_name, ' ', d.last_name) AS doctor_name,
    COUNT(*) AS appointment_count,
    SUM(a.duration) AS total_duration,
    AVG(a.duration) AS average_duration,
    MAX(a.start_time) AS latest_appointment,
    MIN(a.start_time) AS earliest_appointment,
    UPPER(p.gender) AS gender,
    DATE_FORMAT(p.date_of_birth, '%Y-%m-%d') AS formatted_dob,
    CONCAT(p.address_line1, ', ', p.address_line2, ', ', p.city, ', ', p.state, ', ', p.zip_code) AS full_address
FROM 
    healthcare.patients AS p
JOIN 
    healthcare.appointments AS a ON p.patient_id = a.patient_id
JOIN 
    healthcare.doctors AS d ON a.doctor_id = d.doctor_id
JOIN 
    healthcare.specialties AS s ON d.specialty_id = s.specialty_id
WHERE 
    p.date_of_birth >= '1980-01-01'
    AND p.date_of_birth <= '1990-12-31'
    AND s.name = 'Cardiology'
    AND a.start_time >= '2022-01-01'
    AND a.start_time <= '2022-12-31'
GROUP BY 
    p.patient_id, d.doctor_id
HAVING 
    COUNT(*) > 1
ORDER BY 
    patient_name ASC, appointment_count DESC
LIMIT 100
CROSS JOIN 
    (SELECT 
        COUNT(*) AS total_patients
    FROM 
        healthcare.patients) AS tp;",319,341,660,"['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.specialties']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.specialties']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.specialties']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.specialties']"
63,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.first_name, ' ', p.last_name) AS patient_name,
    CONCAT(d.first_name, ' ', d.last_name) AS doctor_name,
    a.appointment_date,
    a.appointment_time,
    CONCAT('Room ', r.room_number) AS room,
    CONCAT('Floor ', f.floor_number) AS floor,
    CONCAT('Building ', b.building_name) AS building,
    CONCAT('Department ', dp.department_name) AS department,
    CONCAT('Specialty ', s.specialty_name) AS specialty,
    CONCAT('Insurance ', i.insurance_name) AS insurance,
    CONCAT('Policy No. ', i.policy_number) AS policy_number,
    CONCAT('Claim No. ', c.claim_number) AS claim_number,
    CONCAT('Diagnosis Code ', d.diagnosis_code) AS diagnosis_code,
    CONCAT('Procedure Code ', p.procedure_code) AS procedure_code,
    CONCAT('Medication ', m.medication_name) AS medication,
    CONCAT('Dosage ', m.dosage) AS dosage,
    CONCAT('Frequency ', m.frequency) AS frequency,
    CONCAT('Duration ', m.duration) AS duration,
    CONCAT('Lab Test ', lt.lab_test_name) AS lab_test,
    CONCAT('Result ', lt.result) AS result,
    CONCAT('Reference Range ', lt.reference_range) AS reference_range,
    CONCAT('Lab Technician ', lt.lab_technician) AS lab_technician
FROM
    healthcare.company.patient AS p
        CROSS JOIN
    healthcare.company.doctor AS d
        CROSS JOIN
    healthcare.company.appointment AS a
        CROSS JOIN
    healthcare.company.room AS r
        CROSS JOIN
    healthcare.company.floor AS f
        CROSS JOIN
    healthcare.company.building AS b
        CROSS JOIN
    healthcare.company.department AS dp
        CROSS JOIN
    healthcare.company.specialty AS s
        CROSS JOIN
    healthcare.company.insurance AS i
        CROSS JOIN
    healthcare.company.claim AS c
        CROSS JOIN
    healthcare.company.diagnosis AS d
        CROSS JOIN
    healthcare.company.procedure AS p
        CROSS JOIN
    healthcare.company.medication AS m
        CROSS JOIN
    healthcare.company.lab_test AS lt
WHERE
    p.patient_id = a.patient_id
        AND d.doctor_id = a.doctor_id
        AND r.room_id = a.room_id
        AND f.floor_id = r.floor_id
        AND b.building_id = f.building_id
        AND dp.department_id = d.department_id
        AND s.specialty_id = d.specialty_id
        AND i.insurance_id = p.insurance_id
        AND c.claim_id = p.claim_id
        AND d.diagnosis_id = c.diagnosis_id
        AND p.procedure_id = c.procedure_id
        AND m.medication_id = p.medication_id
        AND lt.lab_test_id = p.lab_test_id
GROUP BY patient_name , doctor_name , appointment_date , appointment_time , room , floor , building , department , specialty , insurance , policy_number , claim_number , diagnosis_code , procedure_code , medication , dosage , frequency , duration , lab_test , result , reference_range , lab_technician
HAVING
    COUNT(*) > 1;",320,672,992,"['healthcare.company.patient', 'healthcare.company.doctor', 'healthcare.company.appointment', 'healthcare.company.room', 'healthcare.company.floor', 'healthcare.company.building', 'healthcare.company.department', 'healthcare.company.specialty', 'healthcare.company.insurance', 'healthcare.company.claim', 'healthcare.company.diagnosis', 'healthcare.company.procedure', 'healthcare.company.medication', 'healthcare.company.lab_test']","['healthcare.company.patient', 'healthcare.company.doctor', 'healthcare.company.appointment', 'healthcare.company.room', 'healthcare.company.floor', 'healthcare.company.building', 'healthcare.company.department', 'healthcare.company.specialty', 'healthcare.company.insurance', 'healthcare.company.claim', 'healthcare.company.diagnosis', 'healthcare.company.procedure', 'healthcare.company.medication', 'healthcare.company.lab_test']","['healthcare.company.patient', 'healthcare.company.doctor', 'healthcare.company.appointment', 'healthcare.company.room', 'healthcare.company.floor', 'healthcare.company.building', 'healthcare.company.department', 'healthcare.company.specialty', 'healthcare.company.insurance', 'healthcare.company.claim', 'healthcare.company.diagnosis', 'healthcare.company.procedure', 'healthcare.company.medication', 'healthcare.company.lab_test']","['healthcare.company.patient', 'healthcare.company.doctor', 'healthcare.company.appointment', 'healthcare.company.room', 'healthcare.company.floor', 'healthcare.company.building', 'healthcare.company.department', 'healthcare.company.specialty', 'healthcare.company.insurance', 'healthcare.company.claim', 'healthcare.company.diagnosis', 'healthcare.company.procedure', 'healthcare.company.medication', 'healthcare.company.lab_test']"
64,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(manufacturing_orders.order_id, '-', manufacturing_orders.order_date) AS order_number,
    manufacturing_orders.order_status,
    manufacturing_orders.order_quantity,
    manufacturing_orders.order_price,
    manufacturing_orders.order_quantity * manufacturing_orders.order_price AS total_amount,
    DATE_FORMAT(manufacturing_orders.order_date, '%Y-%m-%d') AS formatted_order_date,
    UPPER(manufacturing_products.product_name) AS product_name,
    manufacturing_products.product_category,
    manufacturing_products.product_weight,
    manufacturing_products.product_price,
    manufacturing_products.product_price * manufacturing_orders.order_quantity AS total_price,
    CONCAT(manufacturing_customers.customer_first_name, ' ', manufacturing_customers.customer_last_name) AS customer_name,
    manufacturing_customers.customer_email,
    manufacturing_customers.customer_phone,
    manufacturing_customers.customer_address,
    manufacturing_customers.customer_city,
    manufacturing_customers.customer_state,
    manufacturing_customers.customer_country,
    manufacturing_customers.customer_zipcode
FROM
    manufacturing.orders AS manufacturing_orders
        CROSS JOIN
    manufacturing.products AS manufacturing_products
        CROSS JOIN
    manufacturing.customers AS manufacturing_customers
WHERE
    manufacturing_orders.product_id = manufacturing_products.product_id
        AND manufacturing_orders.customer_id = manufacturing_customers.customer_id
        AND manufacturing_orders.order_status = 'Completed'
        AND manufacturing_products.product_category = 'Electronics'
        AND manufacturing_customers.customer_country = 'United States'
GROUP BY
    manufacturing_orders.order_id,
    manufacturing_orders.order_date,
    manufacturing_orders.order_status,
    manufacturing_orders.order_quantity,
    manufacturing_orders.order_price,
    manufacturing_products.product_name,
    manufacturing_products.product_category,
    manufacturing_products.product_weight,
    manufacturing_products.product_price,
    manufacturing_customers.customer_first_name,
    manufacturing_customers.customer_last_name,
    manufacturing_customers.customer_email,
    manufacturing_customers.customer_phone,
    manufacturing_customers.customer_address,
    manufacturing_customers.customer_city,
    manufacturing_customers.customer_state,
    manufacturing_customers.customer_country,
    manufacturing_customers.customer_zipcode
HAVING
    COUNT(manufacturing_orders.order_id) > 1
ORDER BY
    total_amount DESC;",322,433,755,"['manufacturing.orders', 'manufacturing.products', 'manufacturing.customers']","['manufacturing.orders', 'manufacturing.products', 'manufacturing.customers']","['manufacturing.orders', 'manufacturing.products', 'manufacturing.customers']","['manufacturing.orders', 'manufacturing.products', 'manufacturing.customers']"
65,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a logistics company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price
  FROM 
    logistics.orders o
  WHERE 
    o.order_date >= '2021-01-01'
),
cte_customers AS (
  SELECT 
    c.customer_id,
    c.customer_name,
    c.city,
    c.country
  FROM 
    logistics.customers c
  WHERE 
    c.country = 'United States'
),
cte_products AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.category,
    p.unit_price
  FROM 
    logistics.products p
  WHERE 
    p.category IN ('Electronics', 'Furniture')
),
cte_order_details AS (
  SELECT 
    od.order_id,
    od.product_id,
    od.quantity,
    od.unit_price
  FROM 
    logistics.order_details od
),
cte_shipments AS (
  SELECT 
    s.shipment_id,
    s.order_id,
    s.shipment_date,
    s.shipment_status
  FROM 
    logistics.shipments s
  WHERE 
    s.shipment_status = 'Delivered'
),
cte_sales AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    c.customer_name,
    p.product_name,
    od.quantity,
    od.unit_price,
    (od.quantity * od.unit_price) AS total_price
  FROM 
    cte_orders o
    JOIN cte_customers c ON o.customer_id = c.customer_id
    JOIN cte_order_details od ON o.order_id = od.order_id
    JOIN cte_products p ON od.product_id = p.product_id
),
cte_top_customers AS (
  SELECT 
    customer_id,
    SUM(total_price) AS total_sales
  FROM 
    cte_sales
  GROUP BY 
    customer_id
  HAVING 
    SUM(total_price) > 10000
),
cte_monthly_sales AS (
  SELECT 
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    SUM(total_price) AS monthly_revenue
  FROM 
    cte_sales
  GROUP BY 
    DATE_FORMAT(order_date, '%Y-%m')
),
cte_category_sales AS (
  SELECT 
    category,
    SUM(total_price) AS category_revenue
  FROM 
    cte_sales
  GROUP BY 
    category
),
cte_shipment_stats AS (
  SELECT 
    shipment_status,
    COUNT(*) AS shipment_count
  FROM 
    cte_shipments
  GROUP BY 
    shipment_status
)
SELECT 
  c.customer_name,
  c.city,
  c.country,
  s.month,
  s.monthly_revenue,
  t.total_sales,
  cs.category,
  cs.category_revenue,
  ss.shipment_status,
  ss.shipment_count
FROM 
  cte_customers c
  LEFT JOIN cte_top_customers t ON c.customer_id = t.customer_id
  LEFT JOIN cte_monthly_sales s ON c.customer_id = s.customer_id
  LEFT JOIN cte_category_sales cs ON c.customer_id = cs.customer_id
  LEFT JOIN cte_shipment_stats ss ON c.customer_id = ss.customer_id
ORDER BY 
  c.customer_name ASC;",318,689,1007,"['logistics.orders', 'logistics.customers', 'logistics.products', 'logistics.order_details', 'logistics.shipments']","['logistics.orders', 'logistics.customers', 'logistics.products', 'logistics.order_details', 'logistics.shipments']","['logistics.orders', 'logistics.customers', 'logistics.products', 'logistics.order_details', 'logistics.shipments']","['logistics.orders', 'logistics.customers', 'logistics.products', 'logistics.order_details', 'logistics.shipments']"
66,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    WHERE 
        c.customer_city = 'New York'
    GROUP BY 
        c.customer_id
    HAVING 
        total_orders > 5
),
cte2 AS (
    SELECT 
        p.product_name,
        SUM(op.quantity) AS total_quantity
    FROM 
        products p
    INNER JOIN 
        order_products op ON p.product_id = op.product_id
    WHERE 
        p.product_category = 'Mobile Phones'
    GROUP BY 
        p.product_id
    HAVING 
        total_quantity > 100
),
cte3 AS (
    SELECT 
        c.customer_id,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    GROUP BY 
        c.customer_id
),
cte4 AS (
    SELECT 
        c.customer_id,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    GROUP BY 
        c.customer_id
),
cte5 AS (
    SELECT 
        c.customer_id,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    GROUP BY 
        c.customer_id
),
cte6 AS (
    SELECT 
        c.customer_id,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    GROUP BY 
        c.customer_id
),
cte7 AS (
    SELECT 
        c.customer_id,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    GROUP BY 
        c.customer_id
),
cte8 AS (
    SELECT 
        c.customer_id,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    GROUP BY 
        c.customer_id
),
cte9 AS (
    SELECT 
        c.customer_id,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    GROUP BY 
        c.customer_id
),
cte10 AS (
    SELECT 
        c.customer_id,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    GROUP BY 
        c.customer_id
)
SELECT 
    cte1.customer_name,
    cte2.product_name,
    cte3.total_orders,
    cte4.total_orders,
    cte5.total_orders,
    cte6.total_orders,
    cte7.total_orders,
    cte8.total_orders,
    cte9.total_orders,
    cte10.total_orders
FROM 
    cte1
CROSS JOIN 
    cte2
CROSS JOIN 
    cte3
CROSS JOIN 
    cte4
CROSS JOIN 
    cte5
CROSS JOIN 
    cte6
CROSS JOIN 
    cte7
CROSS JOIN 
    cte8
CROSS JOIN 
    cte9
CROSS JOIN 
    cte10
WHERE 
    cte1.total_orders > 5
    AND cte2.total_quantity > 100
    AND cte3.total_orders > 10
    AND cte4.total_orders > 20
    AND cte5.total_orders > 30
    AND cte6.total_orders > 40
    AND cte7.total_orders > 50
    AND cte8.total_orders > 60
    AND cte9.total_orders > 70
    AND cte10.total_orders > 80;",319,918,1237,"['customers', 'orders', 'products', 'order_products']","['customers', 'orders', 'products', 'order_products']","['customers', 'orders', 'products', 'order_products']","['customers', 'orders', 'products', 'order_products']"
67,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    c.email AS customer_email,
    p.product_name AS product,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS order_date,
    SUM(o.quantity * p.unit_price) AS total_revenue
FROM
    energy_company.customers c
        JOIN
    energy_company.orders o ON c.customer_id = o.customer_id
        JOIN
    energy_company.order_items oi ON o.order_id = oi.order_id
        JOIN
    energy_company.products p ON oi.product_id = p.product_id
        JOIN
    energy_company.suppliers s ON p.supplier_id = s.supplier_id
        JOIN
    energy_company.locations l ON s.location_id = l.location_id
WHERE
    l.country = 'United States'
        AND oi.quantity > 0
        AND o.order_date BETWEEN '2020-01-01' AND '2020-12-31'
GROUP BY c.customer_id , p.product_id
HAVING
    COUNT(DISTINCT o.order_id) > 1
        AND AVG(p.unit_price) > 100
ORDER BY total_revenue DESC;",324,247,571,"['energy_company.customers', 'energy_company.orders', 'energy_company.order_items', 'energy_company.products', 'energy_company.suppliers', 'energy_company.locations']","['energy_company.customers', 'energy_company.orders', 'energy_company.order_items', 'energy_company.products', 'energy_company.suppliers', 'energy_company.locations']","['energy_company.customers', 'energy_company.orders', 'energy_company.order_items', 'energy_company.products', 'energy_company.suppliers', 'energy_company.locations']","['energy_company.customers', 'energy_company.orders', 'energy_company.order_items', 'energy_company.products', 'energy_company.suppliers', 'energy_company.locations']"
68,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH 
    cte_orders AS (
        SELECT 
            o.order_id,
            o.order_date,
            o.customer_id,
            o.total_price
        FROM 
            orders o
        WHERE 
            o.order_date >= '2021-01-01'
    ),
    cte_customers AS (
        SELECT 
            c.customer_id,
            c.customer_name,
            c.city,
            c.country
        FROM 
            customers c
        WHERE 
            c.country = 'USA'
    ),
    cte_products AS (
        SELECT 
            p.product_id,
            p.product_name,
            p.category,
            p.unit_price
        FROM 
            products p
        WHERE 
            p.category IN ('Electronics', 'Clothing')
    )
SELECT 
    c.customer_name,
    c.city,
    c.country,
    COUNT(DISTINCT o.order_id) AS TotalOrders,
    SUM(o.total_price) AS TotalSales,
    AVG(p.unit_price) AS AvgUnitPrice
FROM 
    cte_customers c
JOIN 
    cte_orders o ON c.customer_id = o.customer_id
JOIN 
    cte_products p ON o.order_id = p.order_id
WHERE 
    o.order_date >= '2021-01-01'
GROUP BY 
    c.customer_name,
    c.city,
    c.country
HAVING 
    COUNT(DISTINCT o.order_id) > 2
ORDER BY 
    TotalSales DESC;",314,300,614,"['orders', 'customers', 'products']","['orders', 'customers', 'products']","['orders', 'customers', 'products']","['orders', 'customers', 'products']"
69,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a retail company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH
  cte1 AS (
    SELECT
      CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
      o.order_id,
      o.order_date,
      o.order_total
    FROM
      sales.customers c
    JOIN
      sales.orders o ON c.customer_id = o.customer_id
    WHERE
      o.order_date >= '2021-01-01'
      AND o.order_date <= '2021-12-31'
  ),
  cte2 AS (
    SELECT
      p.product_name,
      p.product_category,
      oi.order_id,
      oi.quantity,
      oi.unit_price
    FROM
      inventory.products p
    JOIN
      sales.order_items oi ON p.product_id = oi.product_id
  ),
  cte3 AS (
    SELECT
      cte1.customer_name,
      cte1.order_id,
      cte1.order_date,
      cte1.order_total,
      cte2.product_name,
      cte2.product_category,
      cte2.quantity,
      cte2.unit_price
    FROM
      cte1
    JOIN
      cte2 ON cte1.order_id = cte2.order_id
  )
SELECT
  cte3.customer_name,
  cte3.order_id,
  DATE_FORMAT(cte3.order_date, '%Y-%m-%d') AS formatted_order_date,
  SUM(cte3.order_total) AS total_sales,
  COUNT(DISTINCT cte3.product_name) AS unique_products,
  AVG(cte3.quantity) AS average_quantity,
  SUM(cte3.unit_price * cte3.quantity) AS revenue
FROM
  cte3
WHERE
  cte3.product_category = 'Electronics'
GROUP BY
  cte3.customer_name,
  cte3.order_id,
  formatted_order_date
HAVING
  total_sales > 1000
ORDER BY
  total_sales DESC;",315,407,722,"['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']"
70,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(s.first_name, ' ', s.last_name) AS student_name,
    c.course_name,
    COUNT(DISTINCT e.enrollment_id) AS total_enrollments,
    AVG(g.grade) AS average_grade,
    CONCAT(t.first_name, ' ', t.last_name) AS teacher_name,
    d.department_name,
    SUM(p.price) AS total_payment
FROM
    education.students AS s
        JOIN
    education.enrollments AS e ON s.student_id = e.student_id
        JOIN
    education.courses AS c ON e.course_id = c.course_id
        JOIN
    education.grades AS g ON e.enrollment_id = g.enrollment_id
        JOIN
    education.teachers AS t ON c.teacher_id = t.teacher_id
        JOIN
    education.departments AS d ON c.department_id = d.department_id
        JOIN
    education.payments AS p ON s.student_id = p.student_id
WHERE
    s.age >= 18
        AND c.course_name LIKE '%Math%'
        AND g.grade >= 70
        AND p.payment_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY s.student_id , c.course_id , t.teacher_id , d.department_id
HAVING
    total_enrollments > 3
        AND average_grade >= 80
ORDER BY total_payment DESC
LIMIT 10;",321,288,609,"['education.students', 'education.enrollments', 'education.courses', 'education.grades', 'education.teachers', 'education.departments', 'education.payments']","['education.students', 'education.enrollments', 'education.courses', 'education.grades', 'education.teachers', 'education.departments', 'education.payments']","['education.students', 'education.enrollments', 'education.courses', 'education.grades', 'education.teachers', 'education.departments', 'education.payments']","['education.students', 'education.enrollments', 'education.courses', 'education.grades', 'education.teachers', 'education.departments', 'education.payments']"
71,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_sales AS (
  SELECT
    o.order_id,
    o.customer_id,
    o.order_date,
    o.total_price,
    p.product_name,
    p.unit_price,
    c.customer_name,
    c.city,
    c.country
  FROM
    kusto['shop'].orders o
  JOIN
    kusto['shop'].products p ON o.product_id = p.product_id
  JOIN
    kusto['shop'].customers c ON o.customer_id = c.customer_id
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),
cte_monthly_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m')
),
cte_top_customers AS (
  SELECT
    customer_id,
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders
  FROM
    cte_sales
  GROUP BY
    customer_id,
    customer_name
  HAVING
    COUNT(DISTINCT order_id) > 5
),
cte_product_sales AS (
  SELECT
    product_name,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    product_name
  HAVING
    SUM(total_price) > 1000
),
cte_city_sales AS (
  SELECT
    city,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    city
),
cte_country_sales AS (
  SELECT
    country,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    country
),
cte_monthly_sales_rank AS (
  SELECT
    month,
    total_sales,
    RANK() OVER (ORDER BY total_sales DESC) AS sales_rank
  FROM
    cte_monthly_sales
),
cte_top_customers_rank AS (
  SELECT
    customer_id,
    customer_name,
    total_orders,
    RANK() OVER (ORDER BY total_orders DESC) AS orders_rank
  FROM
    cte_top_customers
),
cte_product_sales_rank AS (
  SELECT
    product_name,
    total_sales,
    RANK() OVER (ORDER BY total_sales DESC) AS sales_rank
  FROM
    cte_product_sales
),
cte_city_sales_rank AS (
  SELECT
    city,
    total_orders,
    total_sales,
    RANK() OVER (ORDER BY total_sales DESC) AS sales_rank
  FROM
    cte_city_sales
),
cte_country_sales_rank AS (
  SELECT
    country,
    total_orders,
    total_sales,
    RANK() OVER (ORDER BY total_sales DESC) AS sales_rank
  FROM
    cte_country_sales
)
SELECT
  msr.month,
  msr.total_sales AS monthly_sales,
  tcr.customer_name,
  tcr.total_orders AS customer_orders,
  psr.product_name,
  psr.total_sales AS product_sales,
  csr.city,
  csr.total_orders AS city_orders,
  csr.total_sales AS city_sales,
  cor.country,
  cor.total_orders AS country_orders,
  cor.total_sales AS country_sales
FROM
  cte_monthly_sales_rank msr
JOIN
  cte_top_customers_rank tcr ON msr.sales_rank = tcr.orders_rank
JOIN
  cte_product_sales_rank psr ON msr.sales_rank = psr.sales_rank
JOIN
  cte_city_sales_rank csr ON msr.sales_rank = csr.sales_rank
JOIN
  cte_country_sales_rank cor ON msr.sales_rank = cor.sales_rank
ORDER BY
  msr.sales_rank ASC;",324,844,1168,"['kusto.shop.orders', 'kusto.shop.products', 'kusto.shop.customers']","['kusto.shop.orders', 'kusto.shop.products', 'kusto.shop.customers']","['kusto.shop.orders', 'kusto.shop.products', 'kusto.shop.customers']","['kusto.shop.orders', 'kusto.shop.products', 'kusto.shop.customers']"
72,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(u.first_name, ' ', u.last_name) AS full_name,
    a.article_title,
    a.article_date,
    c.category_name,
    COUNT(DISTINCT c.comment_id) AS total_comments,
    SUM(a.article_views) AS total_views,
    AVG(r.rating_value) AS average_rating
FROM 
    users u
JOIN 
    articles a ON u.user_id = a.author_id
JOIN 
    categories c ON a.category_id = c.category_id
LEFT JOIN 
    comments cmt ON a.article_id = cmt.article_id
LEFT JOIN 
    ratings r ON a.article_id = r.article_id
WHERE 
    a.article_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
    AND a.article_date < DATE_FORMAT(NOW() + INTERVAL 1 MONTH, '%Y-%m-01')
    AND a.article_status = 'published'
GROUP BY 
    u.user_id,
    a.article_id,
    c.category_id
HAVING 
    total_comments > 10
ORDER BY 
    total_views DESC
LIMIT 10;",316,224,540,"['users', 'articles', 'categories', 'comments', 'ratings']","['users', 'articles', 'categories', 'comments', 'ratings']","['users', 'articles', 'categories', 'comments', 'ratings']","['users', 'articles', 'categories', 'comments', 'ratings']"
73,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH
  cte_orders AS (
    SELECT
      o.order_id,
      o.order_date,
      o.customer_id,
      o.total_price,
      c.customer_name,
      c.customer_email
    FROM
      ecommerce.orders o
    JOIN
      ecommerce.customers c ON o.customer_id = c.customer_id
    WHERE
      o.order_date >= '2021-01-01'
      AND o.order_date <= '2021-12-31'
  ),
  cte_order_items AS (
    SELECT
      oi.order_id,
      oi.product_id,
      oi.quantity,
      oi.unit_price,
      p.product_name,
      p.category_id,
      c.category_name
    FROM
      ecommerce.order_items oi
    JOIN
      ecommerce.products p ON oi.product_id = p.product_id
    JOIN
      ecommerce.categories c ON p.category_id = c.category_id
  ),
  cte_category_sales AS (
    SELECT
      c.category_id,
      c.category_name,
      SUM(oi.quantity * oi.unit_price) AS category_sales
    FROM
      cte_order_items oi
    JOIN
      ecommerce.categories c ON oi.category_id = c.category_id
    GROUP BY
      c.category_id,
      c.category_name
  ),
  cte_customer_sales AS (
    SELECT
      o.customer_id,
      c.customer_name,
      SUM(o.total_price) AS customer_sales
    FROM
      cte_orders o
    JOIN
      ecommerce.customers c ON o.customer_id = c.customer_id
    GROUP BY
      o.customer_id,
      c.customer_name
  ),
  cte_top_customers AS (
    SELECT
      customer_id,
      customer_name,
      customer_sales,
      ROW_NUMBER() OVER (ORDER BY customer_sales DESC) AS rank
    FROM
      cte_customer_sales
  ),
  cte_top_categories AS (
    SELECT
      category_id,
      category_name,
      category_sales,
      ROW_NUMBER() OVER (ORDER BY category_sales DESC) AS rank
    FROM
      cte_category_sales
  )
SELECT
  o.order_id,
  o.order_date,
  o.customer_id,
  o.total_price,
  o.customer_name,
  o.customer_email,
  oi.product_id,
  oi.quantity,
  oi.unit_price,
  oi.product_name,
  oi.category_id,
  oi.category_name,
  cs.customer_sales,
  tc.customer_name AS top_customer_name,
  tc.customer_sales AS top_customer_sales,
  cc.category_name AS top_category_name,
  cc.category_sales AS top_category_sales
FROM
  cte_orders o
JOIN
  cte_order_items oi ON o.order_id = oi.order_id
JOIN
  cte_customer_sales cs ON o.customer_id = cs.customer_id
JOIN
  cte_top_customers tc ON cs.customer_id = tc.customer_id
JOIN
  cte_category_sales cc ON oi.category_id = cc.category_id
JOIN
  cte_top_categories tc ON cc.category_id = tc.category_id
WHERE
  oi.quantity > 0
  AND oi.unit_price > 0
  AND cs.customer_sales > 1000
  AND cc.category_sales > 5000
HAVING
  SUM(oi.quantity * oi.unit_price) > 10000
ORDER BY
  o.order_date DESC
LIMIT
  100;",319,697,1016,"['ecommerce.orders', 'ecommerce.customers', 'ecommerce.order_items', 'ecommerce.products', 'ecommerce.categories']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.order_items', 'ecommerce.products', 'ecommerce.categories']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.order_items', 'ecommerce.products', 'ecommerce.categories']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.order_items', 'ecommerce.products', 'ecommerce.categories']"
74,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_articles AS (
  SELECT a.article_id, a.title, a.author, a.publish_date, a.category_id, c.category_name
  FROM articles a
  JOIN categories c ON a.category_id = c.category_id
  WHERE a.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)
),
cte_top_articles AS (
  SELECT article_id, title, author, publish_date, category_id, category_name
  FROM cte_articles
  WHERE article_id IN (
    SELECT article_id
    FROM (
      SELECT article_id, COUNT(*) AS total_views
      FROM article_views
      GROUP BY article_id
      ORDER BY total_views DESC
      LIMIT 5
    ) top_articles
  )
),
cte_comments AS (
  SELECT article_id, COUNT(*) AS total_comments
  FROM comments
  WHERE comment_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
  GROUP BY article_id
),
cte_avg_rating AS (
  SELECT article_id, AVG(rating) AS avg_rating
  FROM ratings
  GROUP BY article_id
),
cte_popular_categories AS (
  SELECT category_id, COUNT(*) AS total_articles
  FROM articles
  WHERE publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
  GROUP BY category_id
  HAVING total_articles > 10
),
cte_recent_authors AS (
  SELECT author, COUNT(*) AS total_articles
  FROM articles
  WHERE publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)
  GROUP BY author
  HAVING total_articles > 3
)
SELECT a.title, a.author, a.publish_date, a.category_name, 
  CONCAT('https://news-site.com/article/', a.article_id) AS article_url,
  COALESCE(c.total_comments, 0) AS total_comments,
  COALESCE(r.avg_rating, 0) AS avg_rating,
  CASE
    WHEN a.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) THEN 'New'
    WHEN a.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY) THEN 'Recent'
    ELSE 'Old'
  END AS article_age,
  CASE
    WHEN a.category_id IN (SELECT category_id FROM cte_popular_categories) THEN 'Popular'
    ELSE 'Not Popular'
  END AS category_popularity,
  CASE
    WHEN a.author IN (SELECT author FROM cte_recent_authors) THEN 'Active'
    ELSE 'Inactive'
  END AS author_activity
FROM cte_articles a
LEFT JOIN cte_comments c ON a.article_id = c.article_id
LEFT JOIN cte_avg_rating r ON a.article_id = r.article_id
LEFT JOIN cte_top_articles t ON a.article_id = t.article_id
ORDER BY a.publish_date DESC, a.title ASC
LIMIT 10;",318,589,907,"['articles', 'categories', 'article_views', 'comments', 'ratings']","['articles', 'categories', 'article_views', 'comments', 'ratings']","['articles', 'categories', 'article_views', 'comments', 'ratings']","['articles', 'categories', 'article_views', 'comments', 'ratings']"
75,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(students.first_name, ' ', students.last_name) AS student_name,
    courses.course_name,
    COUNT(enrollments.student_id) AS total_enrollments,
    AVG(grades.grade) AS average_grade,
    CONCAT(teachers.first_name, ' ', teachers.last_name) AS teacher_name
FROM 
    education.students
JOIN 
    education.enrollments ON students.student_id = enrollments.student_id
JOIN 
    education.courses ON enrollments.course_id = courses.course_id
JOIN 
    education.grades ON enrollments.enrollment_id = grades.enrollment_id
JOIN 
    education.teachers ON courses.teacher_id = teachers.teacher_id
WHERE 
    students.age >= 18
    AND courses.course_level = 'Intermediate'
    AND grades.grade >= 70
GROUP BY 
    students.student_id,
    courses.course_id,
    teachers.teacher_id
HAVING 
    total_enrollments > 3
ORDER BY 
    average_grade DESC
LIMIT 10
CROSS JOIN 
    (SELECT 
        COUNT(DISTINCT students.student_id) AS total_students
    FROM 
        education.students) AS student_count;",317,237,554,"['education.students', 'education.enrollments', 'education.courses', 'education.grades', 'education.teachers']","['education.students', 'education.enrollments', 'education.courses', 'education.grades', 'education.teachers']","['education.students', 'education.enrollments', 'education.courses', 'education.grades', 'education.teachers']","['education.students', 'education.enrollments', 'education.courses', 'education.grades', 'education.teachers']"
76,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(manufacturing.company_name, ' - ', manufacturing.location) AS ManufacturingCompany,
    products.product_name AS ProductName,
    SUM(orders.quantity) AS TotalQuantitySold,
    AVG(orders.unit_price) AS AverageUnitPrice,
    DATE_FORMAT(orders.order_date, '%Y-%m-%d') AS OrderDate,
    CONCAT(customers.first_name, ' ', customers.last_name) AS CustomerName,
    CONCAT(employees.first_name, ' ', employees.last_name) AS SalespersonName
FROM 
    manufacturing.products
JOIN 
    manufacturing.orders ON products.product_id = orders.product_id
JOIN 
    sales.customers ON orders.customer_id = customers.customer_id
JOIN 
    sales.employees ON orders.salesperson_id = employees.employee_id
JOIN 
    manufacturing.suppliers ON products.supplier_id = suppliers.supplier_id
JOIN 
    manufacturing.categories ON products.category_id = categories.category_id
WHERE 
    orders.order_date >= '2021-01-01' AND orders.order_date <= '2021-12-31'
    AND suppliers.country = 'United States'
    AND categories.category_name = 'Electronics'
GROUP BY 
    manufacturing.company_name,
    manufacturing.location,
    products.product_name,
    DATE_FORMAT(orders.order_date, '%Y-%m-%d'),
    CONCAT(customers.first_name, ' ', customers.last_name),
    CONCAT(employees.first_name, ' ', employees.last_name)
HAVING 
    TotalQuantitySold > 100
ORDER BY 
    TotalQuantitySold DESC
LIMIT 10
CROSS JOIN 
    (SELECT 
        COUNT(DISTINCT orders.order_id) AS TotalOrders,
        SUM(orders.total_price) AS TotalSales
    FROM 
        manufacturing.orders
    WHERE 
        orders.order_date >= '2021-01-01' AND orders.order_date <= '2021-12-31') AS Summary",319,386,705,"['manufacturing.products', 'manufacturing.orders', 'sales.customers', 'sales.employees', 'manufacturing.suppliers', 'manufacturing.categories']","['manufacturing.products', 'manufacturing.orders', 'sales.customers', 'sales.employees', 'manufacturing.suppliers', 'manufacturing.categories']","['manufacturing.products', 'manufacturing.orders', 'sales.customers', 'sales.employees', 'manufacturing.suppliers', 'manufacturing.categories']","['manufacturing.products', 'manufacturing.orders', 'sales.customers', 'sales.employees', 'manufacturing.suppliers', 'manufacturing.categories']"
77,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    c.phone_number,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ' ', a.zip_code) AS customer_address,
    p.plan_name,
    COUNT(DISTINCT s.service_id) AS total_services,
    SUM(s.data_usage) AS total_data_usage,
    AVG(s.call_duration) AS average_call_duration,
    DATE_FORMAT(MAX(s.start_date), '%Y-%m-%d') AS last_service_date,
    CONCAT(e.first_name, ' ', e.last_name) AS employee_name,
    e.department,
    CONCAT(tower.latitude, ', ', tower.longitude) AS tower_location
FROM
    telecommunications.customers c
        JOIN
    telecommunications.addresses a ON c.address_id = a.address_id
        JOIN
    telecommunications.services s ON c.customer_id = s.customer_id
        JOIN
    telecommunications.plans p ON s.plan_id = p.plan_id
        JOIN
    telecommunications.employees e ON s.employee_id = e.employee_id
        CROSS JOIN
    telecommunications.towers tower
WHERE
    c.status = 'Active'
        AND p.plan_type = 'Mobile'
        AND s.start_date >= '2021-01-01'
        AND s.end_date IS NULL
GROUP BY c.customer_id , p.plan_id , e.employee_id , tower.tower_id
HAVING
    total_data_usage > 1000
        AND average_call_duration > 5
ORDER BY total_services DESC , last_service_date ASC
LIMIT 100;",319,323,642,"['telecommunications.customers', 'telecommunications.addresses', 'telecommunications.services', 'telecommunications.plans', 'telecommunications.employees', 'telecommunications.towers']","['telecommunications.customers', 'telecommunications.addresses', 'telecommunications.services', 'telecommunications.plans', 'telecommunications.employees', 'telecommunications.towers']","['telecommunications.customers', 'telecommunications.addresses', 'telecommunications.services', 'telecommunications.plans', 'telecommunications.employees', 'telecommunications.towers']","['telecommunications.customers', 'telecommunications.addresses', 'telecommunications.services', 'telecommunications.plans', 'telecommunications.employees', 'telecommunications.towers']"
78,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.product_name, ' - ', p.product_code) AS Product,
    c.category_name AS Category,
    s.supplier_name AS Supplier,
    SUM(o.quantity) AS TotalQuantity,
    SUM(o.quantity * o.unit_price) AS TotalRevenue,
    AVG(o.unit_price) AS AveragePrice,
    COUNT(DISTINCT o.order_id) AS TotalOrders
FROM
    pharmacy.products p
    JOIN pharmacy.categories c ON p.category_id = c.category_id
    JOIN pharmacy.suppliers s ON p.supplier_id = s.supplier_id
    JOIN (
        SELECT 
            od.order_id,
            od.product_id,
            od.quantity,
            od.unit_price
        FROM
            pharmacy.order_details od
            JOIN (
                SELECT 
                    o.order_id,
                    o.order_date,
                    o.customer_id
                FROM
                    pharmacy.orders o
                WHERE
                    o.order_date >= '2021-01-01'
                    AND o.order_date <= '2021-12-31'
                    AND o.order_status = 'Completed'
            ) AS sub_orders ON od.order_id = sub_orders.order_id
    ) AS o ON p.product_id = o.product_id
GROUP BY
    p.product_name,
    p.product_code,
    c.category_name,
    s.supplier_name
HAVING
    TotalQuantity > 100
    AND TotalRevenue > 5000
ORDER BY
    TotalRevenue DESC
CROSS JOIN (
    SELECT 
        MAX(order_date) AS max_order_date
    FROM
        pharmacy.orders
) AS max_date
WHERE
    DATE_FORMAT(max_date.max_order_date, '%Y-%m-%d') = '2021-12-31'",317,353,670,"['pharmacy.products', 'pharmacy.categories', 'pharmacy.suppliers', 'pharmacy.order_details', 'pharmacy.orders']","['pharmacy.products', 'pharmacy.categories', 'pharmacy.suppliers', 'pharmacy.order_details', 'pharmacy.orders']","['pharmacy.products', 'pharmacy.categories', 'pharmacy.suppliers', 'pharmacy.order_details', 'pharmacy.orders']","['pharmacy.products', 'pharmacy.categories', 'pharmacy.suppliers', 'pharmacy.order_details', 'pharmacy.orders']"
79,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    c.customer_email
  FROM 
    orders o
  INNER JOIN 
    customers c ON o.customer_id = c.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),
cte_product_sales AS (
  SELECT 
    p.product_id,
    p.product_name,
    SUM(op.quantity) AS total_quantity_sold,
    SUM(op.quantity * op.unit_price) AS total_sales
  FROM 
    products p
  LEFT JOIN 
    order_products op ON p.product_id = op.product_id
  GROUP BY 
    p.product_id,
    p.product_name
),
cte_customer_stats AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_price) AS total_spent
  FROM 
    customers c
  LEFT JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
)
SELECT 
  c.customer_name,
  c.customer_email,
  COUNT(DISTINCT o.order_id) AS total_orders,
  SUM(o.total_price) AS total_spent,
  ps.total_quantity_sold,
  ps.total_sales
FROM 
  cte_orders o
INNER JOIN 
  cte_customer_stats c ON o.customer_id = c.customer_id
LEFT JOIN 
  cte_product_sales ps ON o.order_id = ps.order_id
WHERE 
  c.total_orders >= 5
  AND ps.total_sales > 1000
GROUP BY 
  c.customer_id,
  c.customer_name,
  c.customer_email,
  ps.total_quantity_sold,
  ps.total_sales
HAVING 
  SUM(o.total_price) > 5000
ORDER BY 
  c.customer_name ASC;",317,408,725,"['orders', 'customers', 'products', 'order_products']","['orders', 'customers', 'products', 'order_products']","['orders', 'customers', 'products', 'order_products']","['orders', 'customers', 'products', 'order_products']"
80,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_type,
        p.unit_price,
        SUM(o.quantity) AS total_quantity
    FROM 
        products p
    INNER JOIN 
        orders o ON p.product_id = o.product_id
    WHERE 
        o.order_date >= '2021-01-01'
    GROUP BY 
        p.product_id,
        p.product_name,
        p.product_type,
        p.unit_price
),
cte2 AS (
    SELECT 
        c.customer_id,
        c.customer_name,
        c.city,
        c.state,
        COUNT(o.order_id) AS total_orders
    FROM 
        customers c
    LEFT JOIN 
        orders o ON c.customer_id = o.customer_id
    WHERE 
        c.state IN ('CA', 'TX', 'NY')
    GROUP BY 
        c.customer_id,
        c.customer_name,
        c.city,
        c.state
),
cte3 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_type,
        p.unit_price,
        SUM(o.quantity) AS total_quantity
    FROM 
        products p
    INNER JOIN 
        orders o ON p.product_id = o.product_id
    WHERE 
        o.order_date >= '2021-01-01'
    GROUP BY 
        p.product_id,
        p.product_name,
        p.product_type,
        p.unit_price
)
SELECT 
    cte1.product_id,
    cte1.product_name,
    cte1.product_type,
    cte1.unit_price,
    cte1.total_quantity,
    cte2.customer_id,
    cte2.customer_name,
    cte2.city,
    cte2.state,
    cte2.total_orders,
    cte3.total_quantity AS total_quantity_2021
FROM 
    cte1
INNER JOIN 
    cte2 ON cte1.product_id = cte2.customer_id
LEFT JOIN 
    cte3 ON cte1.product_id = cte3.product_id
WHERE 
    cte1.total_quantity > 100
HAVING 
    cte2.total_orders > 5
ORDER BY 
    cte1.product_name ASC,
    cte2.customer_name DESC
LIMIT 100;",319,479,798,"['products', 'orders', 'customers']","['products', 'orders', 'customers']","['products', 'orders', 'customers']","['products', 'orders', 'customers']"
81,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a logistics company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    o.order_date,
    p.product_name,
    p.unit_price,
    SUM(oi.quantity) AS total_quantity,
    SUM(oi.quantity * p.unit_price) AS total_revenue
FROM 
    logistics.customers c
JOIN 
    logistics.orders o ON c.customer_id = o.customer_id
JOIN 
    logistics.order_items oi ON o.order_id = oi.order_id
JOIN 
    logistics.products p ON oi.product_id = p.product_id
WHERE 
    o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id
HAVING 
    total_revenue > 1000
ORDER BY 
    total_revenue DESC, total_quantity ASC
LIMIT 10;",316,192,508,"['logistics.customers', 'logistics.orders', 'logistics.order_items', 'logistics.products']","['logistics.customers', 'logistics.orders', 'logistics.order_items', 'logistics.products']","['logistics.customers', 'logistics.orders', 'logistics.order_items', 'logistics.products']","['logistics.customers', 'logistics.orders', 'logistics.order_items', 'logistics.products']"
82,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
        o.order_id,
        o.order_date,
        o.total_price
    FROM 
        sales.customers c
    INNER JOIN 
        sales.orders o ON c.customer_id = o.customer_id
    WHERE 
        o.order_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
),
cte2 AS (
    SELECT 
        p.product_name,
        p.product_category,
        oi.order_id,
        oi.quantity,
        oi.unit_price
    FROM 
        inventory.products p
    INNER JOIN 
        sales.order_items oi ON p.product_id = oi.product_id
),
cte3 AS (
    SELECT 
        cte1.customer_name,
        cte1.order_id,
        cte1.order_date,
        cte1.total_price,
        cte2.product_name,
        cte2.product_category,
        cte2.quantity,
        cte2.unit_price,
        cte2.quantity * cte2.unit_price AS item_total_price
    FROM 
        cte1
    INNER JOIN 
        cte2 ON cte1.order_id = cte2.order_id
),
cte4 AS (
    SELECT 
        cte3.customer_name,
        cte3.order_id,
        cte3.order_date,
        cte3.total_price,
        cte3.product_category,
        SUM(cte3.item_total_price) AS category_total_price
    FROM 
        cte3
    GROUP BY 
        cte3.customer_name,
        cte3.order_id,
        cte3.order_date,
        cte3.total_price,
        cte3.product_category
),
cte5 AS (
    SELECT 
        cte4.customer_name,
        cte4.order_id,
        cte4.order_date,
        cte4.total_price,
        cte4.product_category,
        cte4.category_total_price,
        SUM(cte4.category_total_price) OVER (PARTITION BY cte4.customer_name) AS customer_total_price
    FROM 
        cte4
),
cte6 AS (
    SELECT 
        cte5.customer_name,
        cte5.order_id,
        cte5.order_date,
        cte5.total_price,
        cte5.product_category,
        cte5.category_total_price,
        cte5.customer_total_price,
        RANK() OVER (PARTITION BY cte5.customer_name ORDER BY cte5.customer_total_price DESC) AS customer_rank
    FROM 
        cte5
),
cte7 AS (
    SELECT 
        cte6.customer_name,
        cte6.order_id,
        cte6.order_date,
        cte6.total_price,
        cte6.product_category,
        cte6.category_total_price,
        cte6.customer_total_price,
        cte6.customer_rank
    FROM 
        cte6
    WHERE 
        cte6.customer_rank <= 10
)
SELECT 
    cte7.customer_name,
    cte7.order_id,
    cte7.order_date,
    cte7.total_price,
    cte7.product_category,
    cte7.category_total_price,
    cte7.customer_total_price,
    cte7.customer_rank
FROM 
    cte7
WHERE 
    cte7.total_price > 1000
ORDER BY 
    cte7.customer_rank ASC, 
    cte7.total_price DESC;",322,732,1054,"['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']"
83,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_sales AS (
  SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    p.product_name,
    p.category,
    p.unit_price,
    p.quantity
  FROM
    sales.orders o
  JOIN
    sales.customers c ON o.customer_id = c.customer_id
  JOIN
    sales.order_items oi ON o.order_id = oi.order_id
  JOIN
    sales.products p ON oi.product_id = p.product_id
),
cte_monthly_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m')
),
cte_top_customers AS (
  SELECT
    customer_id,
    SUM(total_price) AS total_spent
  FROM
    cte_sales
  GROUP BY
    customer_id
  HAVING
    SUM(total_price) > (
      SELECT
        AVG(total_sales)
      FROM
        cte_monthly_sales
    )
),
cte_category_sales AS (
  SELECT
    category,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    category
),
cte_monthly_category_sales AS (
  SELECT
    month,
    category,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    month,
    category
),
cte_monthly_top_category AS (
  SELECT
    month,
    category,
    total_sales,
    ROW_NUMBER() OVER (PARTITION BY month ORDER BY total_sales DESC) AS rank
  FROM
    cte_monthly_category_sales
),
cte_monthly_top_category_sales AS (
  SELECT
    month,
    category,
    total_sales
  FROM
    cte_monthly_top_category
  WHERE
    rank = 1
)
SELECT
  c.customer_name,
  c.total_spent,
  mc.month,
  mc.total_orders,
  mc.total_sales,
  cs.total_sales AS category_sales,
  tc.total_sales AS top_customer_sales
FROM
  cte_top_customers tc
JOIN
  sales.customers c ON tc.customer_id = c.customer_id
JOIN
  cte_monthly_sales mc ON c.customer_id = mc.customer_id
JOIN
  cte_category_sales cs ON c.category = cs.category
JOIN
  cte_monthly_top_category_sales mtc ON mc.month = mtc.month
WHERE
  c.customer_id IN (
    SELECT
      customer_id
    FROM
      sales.customers
    WHERE
      UPPER(customer_name) LIKE '%SMITH%'
  )
ORDER BY
  c.total_spent DESC,
  mc.month ASC;",321,605,926,"['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']"
84,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH
  cte_orders AS (
    SELECT
      o.order_id,
      o.order_date,
      o.customer_id,
      o.total_price
    FROM
      ecommerce.orders o
    WHERE
      o.order_date >= '2021-01-01'
      AND o.order_date <= '2021-12-31'
  ),
  cte_customers AS (
    SELECT
      c.customer_id,
      c.customer_name,
      c.city,
      c.state
    FROM
      ecommerce.customers c
  ),
  cte_products AS (
    SELECT
      p.product_id,
      p.product_name,
      p.category,
      p.price
    FROM
      ecommerce.products p
  ),
  cte_order_items AS (
    SELECT
      oi.order_id,
      oi.product_id,
      oi.quantity,
      oi.price
    FROM
      ecommerce.order_items oi
  )
SELECT
  c.customer_name,
  c.city,
  c.state,
  COUNT(DISTINCT o.order_id) AS TotalOrders,
  SUM(oi.quantity) AS TotalItems,
  SUM(oi.price) AS TotalRevenue,
  AVG(oi.price) AS AvgPrice,
  CONCAT(c.customer_name, ' - ', c.city, ', ', c.state) AS CustomerLocation,
  UPPER(p.category) AS Category,
  DATE_FORMAT(o.order_date, '%Y-%m-%d') AS FormattedOrderDate
FROM
  cte_orders o
  CROSS JOIN cte_customers c
  LATERAL JOIN cte_order_items oi ON o.order_id = oi.order_id
  INNER JOIN cte_products p ON oi.product_id = p.product_id
WHERE
  c.customer_id = o.customer_id
  AND p.category IN ('Electronics', 'Clothing')
  AND oi.quantity > 0
GROUP BY
  c.customer_name,
  c.city,
  c.state,
  p.category,
  o.order_date
HAVING
  TotalOrders > 1
ORDER BY
  TotalRevenue DESC,
  TotalItems ASC
LIMIT
  100;",322,431,753,"[""ecommerce.orders"", ""ecommerce.customers"", ""ecommerce.products"", ""ecommerce.order_items""]","[""ecommerce.orders"", ""ecommerce.customers"", ""ecommerce.products"", ""ecommerce.order_items""]","[""ecommerce.orders"", ""ecommerce.customers"", ""ecommerce.products"", ""ecommerce.order_items""]","[""ecommerce.orders"", ""ecommerce.customers"", ""ecommerce.products"", ""ecommerce.order_items""]"
85,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a logistics company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    o.order_date,
    p.product_name,
    p.unit_price,
    SUM(od.quantity) AS total_quantity,
    SUM(od.quantity * p.unit_price) AS total_price
FROM 
    logistics.orders o
JOIN 
    logistics.customers c ON o.customer_id = c.customer_id
JOIN 
    logistics.order_details od ON o.order_id = od.order_id
JOIN 
    logistics.products p ON od.product_id = p.product_id
WHERE 
    o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
    AND c.country = 'United States'
    AND p.category = 'Electronics'
GROUP BY 
    c.first_name,
    c.last_name,
    o.order_id,
    o.order_date,
    p.product_name,
    p.unit_price
HAVING 
    COUNT(DISTINCT o.order_id) > 1
    AND SUM(od.quantity) > 10
    AND AVG(p.unit_price) > 100
ORDER BY 
    total_price DESC
LIMIT 100
CROSS JOIN 
    (SELECT 
        CONCAT('Year:', DATE_FORMAT(o.order_date, '%Y'), ', Month:', DATE_FORMAT(o.order_date, '%m')) AS order_month
    FROM 
        logistics.orders o
    WHERE 
        o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
    GROUP BY 
        DATE_FORMAT(o.order_date, '%Y-%m')
    HAVING 
        COUNT(DISTINCT o.order_id) > 10
    ORDER BY 
        COUNT(DISTINCT o.order_id) DESC
    LIMIT 1) AS subquery1;",322,375,697,"['logistics.orders', 'logistics.customers', 'logistics.order_details', 'logistics.products']","['logistics.orders', 'logistics.customers', 'logistics.order_details', 'logistics.products']","['logistics.orders', 'logistics.customers', 'logistics.order_details', 'logistics.products']","['logistics.orders', 'logistics.customers', 'logistics.order_details', 'logistics.products']"
86,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.price) AS total_revenue
FROM 
    ecommerce.customers c
INNER JOIN 
    ecommerce.orders o ON c.customer_id = o.customer_id
LEFT JOIN 
    ecommerce.order_products op ON o.order_id = op.order_id
LEFT JOIN 
    ecommerce.products p ON op.product_id = p.product_id
WHERE 
    o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id
HAVING 
    total_revenue > 1000
ORDER BY 
    total_revenue DESC;",320,197,517,"['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']","['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']","['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']","['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']"
87,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.price) AS total_price
FROM 
    ecommerce.customers c
JOIN 
    ecommerce.orders o ON c.customer_id = o.customer_id
JOIN 
    ecommerce.order_products op ON o.order_id = op.order_id
JOIN 
    ecommerce.products p ON op.product_id = p.product_id
WHERE 
    o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
    AND p.category = 'Electronics'
    AND c.country = 'United States'
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id
HAVING 
    total_price > 1000
ORDER BY 
    total_price DESC
LIMIT 10;",317,213,530,"['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']","['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']","['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']","['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']"
88,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_sales AS (
  SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    p.product_name,
    p.product_price
  FROM
    sales.orders o
  JOIN
    sales.customers c ON o.customer_id = c.customer_id
  JOIN
    sales.order_items oi ON o.order_id = oi.order_id
  JOIN
    sales.products p ON oi.product_id = p.product_id
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

cte_monthly_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m')
),

cte_top_customers AS (
  SELECT
    customer_id,
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders
  FROM
    cte_sales
  GROUP BY
    customer_id,
    customer_name
  HAVING
    COUNT(DISTINCT order_id) > 5
),

cte_product_sales AS (
  SELECT
    product_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    product_name
),

cte_monthly_product_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    product_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m'),
    product_name
),

cte_monthly_customer_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    customer_id,
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m'),
    customer_id,
    customer_name
),

cte_monthly_customer_product_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    customer_id,
    customer_name,
    product_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m'),
    customer_id,
    customer_name,
    product_name
),

cte_monthly_customer_product_sales_ranked AS (
  SELECT
    month,
    customer_id,
    customer_name,
    product_name,
    total_orders,
    total_sales,
    ROW_NUMBER() OVER (PARTITION BY month ORDER BY total_sales DESC) AS sales_rank
  FROM
    cte_monthly_customer_product_sales
),

cte_monthly_customer_product_sales_top AS (
  SELECT
    month,
    customer_id,
    customer_name,
    product_name,
    total_orders,
    total_sales
  FROM
    cte_monthly_customer_product_sales_ranked
  WHERE
    sales_rank <= 3
),

cte_monthly_customer_product_sales_bottom AS (
  SELECT
    month,
    customer_id,
    customer_name,
    product_name,
    total_orders,
    total_sales
  FROM
    cte_monthly_customer_product_sales_ranked
  WHERE
    sales_rank > 3
),

cte_monthly_customer_product_sales_summary AS (
  SELECT
    month,
    COUNT(DISTINCT customer_id) AS unique_customers,
    COUNT(DISTINCT product_name) AS unique_products,
    SUM(total_orders) AS total_orders,
    SUM(total_sales) AS total_sales
  FROM
    cte_monthly_customer_product_sales
  GROUP BY
    month
),

cte_monthly_customer_product_sales_summary_top AS (
  SELECT
    month,
    unique_customers,
    unique_products,
    total_orders,
    total_sales
  FROM
    cte_monthly_customer_product_sales_summary
  WHERE
    total_sales > 10000
),

cte_monthly_customer_product_sales_summary_bottom AS (
  SELECT
    month,
    unique_customers,
    unique_products,
    total_orders,
    total_sales
  FROM
    cte_monthly_customer_product_sales_summary
  WHERE
    total_sales <= 10000
)

SELECT
  ms.month,
  ms.total_orders,
  ms.total_sales,
  tc.customer_name,
  ps.product_name,
  cps.total_orders,
  cps.total_sales,
  cpsr.sales_rank,
  cps_summary.unique_customers,
  cps_summary.unique_products,
  cps_summary.total_orders,
  cps_summary.total_sales
FROM
  cte_monthly_sales ms
LEFT JOIN
  cte_top_customers tc ON ms.month = DATE_FORMAT(tc.order_date, '%Y-%m')
LEFT JOIN
  cte_product_sales ps ON ms.month = DATE_FORMAT(ps.order_date, '%Y-%m')
LEFT JOIN
  cte_monthly_customer_sales cs ON ms.month = DATE_FORMAT(cs.order_date, '%Y-%m')
LEFT JOIN
  cte_monthly_customer_product_sales cps ON ms.month = cps.month
LEFT JOIN
  cte_monthly_customer_product_sales_top cps_top ON ms.month = cps_top.month
LEFT JOIN
  cte_monthly_customer_product_sales_bottom cps_bottom ON ms.month = cps_bottom.month
LEFT JOIN
  cte_monthly_customer_product_sales_summary cps_summary ON ms.month = cps_summary.month
ORDER BY
  ms.month ASC, cps.total_sales DESC, cpsr.sales_rank ASC;",322,1224,1546,"['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']"
89,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT
    articles.article_id,
    articles.title,
    articles.author,
    articles.publish_date,
    categories.category_name
  FROM
    news.articles
  JOIN
    news.categories ON articles.category_id = categories.category_id
  WHERE
    articles.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)
),
cte2 AS (
  SELECT
    cte1.article_id,
    cte1.title,
    cte1.author,
    cte1.publish_date,
    cte1.category_name,
    COUNT(DISTINCT comments.comment_id) AS comment_count
  FROM
    cte1
  LEFT JOIN
    news.comments ON cte1.article_id = comments.article_id
  GROUP BY
    cte1.article_id,
    cte1.title,
    cte1.author,
    cte1.publish_date,
    cte1.category_name
),
cte3 AS (
  SELECT
    cte2.article_id,
    cte2.title,
    cte2.author,
    cte2.publish_date,
    cte2.category_name,
    cte2.comment_count,
    AVG(ratings.rating_value) AS average_rating
  FROM
    cte2
  LEFT JOIN
    news.ratings ON cte2.article_id = ratings.article_id
  GROUP BY
    cte2.article_id,
    cte2.title,
    cte2.author,
    cte2.publish_date,
    cte2.category_name,
    cte2.comment_count
)
SELECT
  cte3.title,
  cte3.author,
  DATE_FORMAT(cte3.publish_date, '%Y-%m-%d') AS formatted_publish_date,
  cte3.category_name,
  cte3.comment_count,
  cte3.average_rating,
  CONCAT('https://news-site.com/article/', cte3.article_id) AS article_url
FROM
  cte3
WHERE
  cte3.comment_count > 10
HAVING
  cte3.average_rating > 4.5
ORDER BY
  cte3.publish_date DESC
LIMIT
  10;",328,450,778,"['news.articles', 'news.categories', 'news.comments', 'news.ratings']","['news.articles', 'news.categories', 'news.comments', 'news.ratings']","['news.articles', 'news.categories', 'news.comments', 'news.ratings']","['news.articles', 'news.categories', 'news.comments', 'news.ratings']"
90,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an insurance company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_insured_customers AS (
    SELECT 
        c.customer_id,
        c.first_name,
        c.last_name,
        c.date_of_birth,
        c.address,
        c.city,
        c.state,
        c.zip_code,
        p.policy_id,
        p.policy_type,
        p.policy_start_date,
        p.policy_end_date,
        p.premium_amount
    FROM 
        customers c
    INNER JOIN 
        policies p ON c.customer_id = p.customer_id
    WHERE 
        p.policy_start_date <= CURDATE()
        AND p.policy_end_date >= CURDATE()
),
cte_claimed_policies AS (
    SELECT 
        p.policy_id,
        p.claim_id,
        p.claim_date,
        p.claim_amount,
        p.claim_status
    FROM 
        policies p
    INNER JOIN 
        claims c ON p.policy_id = c.policy_id
    WHERE 
        c.claim_date BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE()
),
cte_total_premiums AS (
    SELECT 
        customer_id,
        SUM(premium_amount) AS total_premiums
    FROM 
        policies
    WHERE 
        policy_start_date <= CURDATE()
        AND policy_end_date >= CURDATE()
    GROUP BY 
        customer_id
),
cte_total_claims AS (
    SELECT 
        customer_id,
        COUNT(claim_id) AS total_claims
    FROM 
        cte_claimed_policies
    GROUP BY 
        customer_id
),
cte_average_claim_amount AS (
    SELECT 
        customer_id,
        AVG(claim_amount) AS average_claim_amount
    FROM 
        cte_claimed_policies
    GROUP BY 
        customer_id
)
SELECT 
    ic.customer_id,
    ic.first_name,
    ic.last_name,
    ic.date_of_birth,
    ic.address,
    ic.city,
    ic.state,
    ic.zip_code,
    ic.policy_id,
    ic.policy_type,
    ic.policy_start_date,
    ic.policy_end_date,
    ic.premium_amount,
    cp.claim_id,
    cp.claim_date,
    cp.claim_amount,
    cp.claim_status,
    tp.total_premiums,
    tc.total_claims,
    ac.average_claim_amount
FROM 
    cte_insured_customers ic
CROSS JOIN 
    cte_claimed_policies cp
LEFT JOIN 
    cte_total_premiums tp ON ic.customer_id = tp.customer_id
LEFT JOIN 
    cte_total_claims tc ON ic.customer_id = tc.customer_id
LEFT JOIN 
    cte_average_claim_amount ac ON ic.customer_id = ac.customer_id
WHERE 
    ic.city = 'New York'
    AND ic.state = 'NY'
    AND tp.total_premiums > 1000
    AND tc.total_claims > 5
    AND ac.average_claim_amount > 5000
GROUP BY 
    ic.customer_id,
    ic.first_name,
    ic.last_name,
    ic.date_of_birth,
    ic.address,
    ic.city,
    ic.state,
    ic.zip_code,
    ic.policy_id,
    ic.policy_type,
    ic.policy_start_date,
    ic.policy_end_date,
    ic.premium_amount,
    cp.claim_id,
    cp.claim_date,
    cp.claim_amount,
    cp.claim_status,
    tp.total_premiums,
    tc.total_claims,
    ac.average_claim_amount
HAVING 
    SUM(cp.claim_amount) > 10000
ORDER BY 
    ic.customer_id ASC;",319,744,1063,"['customers', 'policies', 'claims']","['customers', 'policies', 'claims']","['customers', 'policies', 'claims']","['customers', 'policies', 'claims']"
91,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    c.email,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_price) AS total_sales,
    AVG(DATEDIFF(o.order_date, c.date_of_birth)) AS avg_age_at_purchase,
    UPPER(p.product_name) AS product_name,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_items oi ON o.order_id = oi.order_id
JOIN 
    products p ON oi.product_id = p.product_id
JOIN 
    categories cat ON p.category_id = cat.category_id
JOIN 
    suppliers s ON p.supplier_id = s.supplier_id
JOIN 
    countries co ON c.country_id = co.country_id
JOIN 
    cities ci ON c.city_id = ci.city_id
JOIN 
    regions r ON ci.region_id = r.region_id
JOIN 
    continents con ON r.continent_id = con.continent_id
WHERE 
    con.continent_name = 'Europe'
    AND co.country_name = 'France'
    AND cat.category_name = 'Beach Holidays'
    AND s.supplier_name LIKE '%Travel%'
    AND o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
GROUP BY 
    c.customer_id,
    p.product_id
HAVING 
    total_sales > 1000
ORDER BY 
    total_sales DESC,
    total_orders ASC
LIMIT 100;",319,336,655,"['customers', 'orders', 'order_items', 'products', 'categories', 'suppliers', 'countries', 'cities', 'regions', 'continents']","['customers', 'orders', 'order_items', 'products', 'categories', 'suppliers', 'countries', 'cities', 'regions', 'continents']","['customers', 'orders', 'order_items', 'products', 'categories', 'suppliers', 'countries', 'cities', 'regions', 'continents']","['customers', 'orders', 'order_items', 'products', 'categories', 'suppliers', 'countries', 'cities', 'regions', 'continents']"
92,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(manufacturing['|'].products.product_name, ' - ', manufacturing['|'].products.product_code) AS Product,
    manufacturing['|'].products.product_category AS Category,
    manufacturing['|'].products.product_price AS Price,
    DATE_FORMAT(manufacturing['|'].orders.order_date, '%Y-%m-%d') AS OrderDate,
    manufacturing['|'].orders.order_quantity AS Quantity,
    CONCAT(manufacturing['|'].customers.first_name, ' ', manufacturing['|'].customers.last_name) AS CustomerName,
    UPPER(manufacturing['|'].customers.city) AS City,
    manufacturing['|'].customers.country AS Country,
    SUM(manufacturing['|'].orders.order_quantity * manufacturing['|'].products.product_price) AS TotalSales
FROM 
    manufacturing['|'].products
CROSS JOIN 
    manufacturing['|'].orders
CROSS JOIN 
    manufacturing['|'].customers
WHERE 
    manufacturing['|'].products.product_id = manufacturing['|'].orders.product_id
    AND manufacturing['|'].orders.customer_id = manufacturing['|'].customers.customer_id
    AND manufacturing['|'].orders.order_date >= '2021-01-01'
    AND manufacturing['|'].orders.order_date <= '2021-12-31'
GROUP BY 
    manufacturing['|'].products.product_name,
    manufacturing['|'].products.product_code,
    manufacturing['|'].products.product_category,
    manufacturing['|'].products.product_price,
    DATE_FORMAT(manufacturing['|'].orders.order_date, '%Y-%m-%d'),
    manufacturing['|'].customers.first_name,
    manufacturing['|'].customers.last_name,
    manufacturing['|'].customers.city,
    manufacturing['|'].customers.country
HAVING 
    COUNT(DISTINCT manufacturing['|'].orders.order_id) > 5
ORDER BY 
    TotalSales DESC;",329,384,713,"['manufacturing['|'].products', 'manufacturing['|'].orders', 'manufacturing['|'].customers']","['manufacturing['|'].products', 'manufacturing['|'].orders', 'manufacturing['|'].customers']","['manufacturing['|'].products', 'manufacturing['|'].orders', 'manufacturing['|'].customers']","['manufacturing['|'].products', 'manufacturing['|'].orders', 'manufacturing['|'].customers']"
93,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.product_name, ' - ', p.product_code) AS Product,
    c.category_name AS Category,
    s.supplier_name AS Supplier,
    SUM(o.quantity) AS TotalQuantity,
    SUM(o.quantity * o.unit_price) AS TotalRevenue,
    AVG(o.unit_price) AS AveragePrice,
    COUNT(DISTINCT o.order_id) AS TotalOrders
FROM
    pharmacy.products p
    INNER JOIN pharmacy.categories c ON p.category_id = c.category_id
    LEFT JOIN pharmacy.suppliers s ON p.supplier_id = s.supplier_id
    LEFT JOIN (
        SELECT 
            od.product_id,
            od.order_id,
            od.quantity,
            od.unit_price
        FROM
            pharmacy.order_details od
            INNER JOIN pharmacy.orders o ON od.order_id = o.order_id
        WHERE
            o.order_date >= '2021-01-01'
            AND o.order_date <= '2021-12-31'
    ) o ON p.product_id = o.product_id
GROUP BY
    p.product_name,
    p.product_code,
    c.category_name,
    s.supplier_name
HAVING
    TotalQuantity > 100
    AND TotalRevenue > 5000
ORDER BY
    TotalRevenue DESC;",317,261,578,"['pharmacy.products', 'pharmacy.categories', 'pharmacy.suppliers', 'pharmacy.order_details', 'pharmacy.orders']","['pharmacy.products', 'pharmacy.categories', 'pharmacy.suppliers', 'pharmacy.order_details', 'pharmacy.orders']","['pharmacy.products', 'pharmacy.categories', 'pharmacy.suppliers', 'pharmacy.order_details', 'pharmacy.orders']","['pharmacy.products', 'pharmacy.categories', 'pharmacy.suppliers', 'pharmacy.order_details', 'pharmacy.orders']"
94,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","WITH property_sales AS (
  SELECT
    p.property_id,
    p.property_name,
    p.property_type,
    p.property_location,
    s.sale_date,
    s.sale_price
  FROM
    real_estate.property AS p
  JOIN
    real_estate.sale AS s
  ON
    p.property_id = s.property_id
  WHERE
    p.property_type = 'House'
    AND s.sale_date >= '2021-01-01'
),

property_stats AS (
  SELECT
    property_type,
    COUNT(*) AS total_properties,
    AVG(sale_price) AS avg_sale_price
  FROM
    real_estate.property
  GROUP BY
    property_type
),

top_selling_agents AS (
  SELECT
    a.agent_id,
    a.agent_name,
    COUNT(*) AS total_sales
  FROM
    real_estate.agent AS a
  JOIN
    real_estate.sale AS s
  ON
    a.agent_id = s.agent_id
  GROUP BY
    a.agent_id,
    a.agent_name
  HAVING
    COUNT(*) > 10
),

property_analysis AS (
  SELECT
    ps.property_type,
    ps.total_properties,
    ps.avg_sale_price,
    tsa.agent_name,
    tsa.total_sales
  FROM
    property_stats AS ps
  JOIN
    top_selling_agents AS tsa
  ON
    ps.property_type = 'Apartment'
    AND ps.property_type = tsa.property_type
),

final_result AS (
  SELECT
    pa.property_type,
    pa.total_properties,
    pa.avg_sale_price,
    pa.agent_name,
    pa.total_sales,
    CONCAT('The average sale price of ', UPPER(pa.property_type), ' is $', pa.avg_sale_price) AS average_price_message
  FROM
    property_analysis AS pa
  WHERE
    pa.total_properties > 50
)

SELECT
  fr.property_type,
  fr.total_properties,
  fr.avg_sale_price,
  fr.agent_name,
  fr.total_sales,
  fr.average_price_message
FROM
  final_result AS fr
ORDER BY
  fr.total_sales DESC
LIMIT
  10;",316,450,766,"['real_estate.property', 'real_estate.sale', 'real_estate.agent']","['real_estate.property', 'real_estate.sale', 'real_estate.agent']","['real_estate.property', 'real_estate.sale', 'real_estate.agent']","['real_estate.property', 'real_estate.sale', 'real_estate.agent']"
95,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_property AS (
  SELECT
    property.id AS property_id,
    property.name AS property_name,
    property.address AS property_address,
    property.bedrooms AS property_bedrooms,
    property.bathrooms AS property_bathrooms,
    property.price AS property_price,
    property.sqft AS property_sqft,
    property.type AS property_type,
    property.status AS property_status,
    property.listing_date AS property_listing_date,
    property.agent_id AS property_agent_id,
    agent.name AS agent_name,
    agent.email AS agent_email,
    agent.phone AS agent_phone
  FROM
    real_estate.property
  LEFT JOIN
    real_estate.agent ON property.agent_id = agent.id
  WHERE
    property.status = 'available'
),
cte_property_stats AS (
  SELECT
    property_type,
    COUNT(*) AS property_count,
    AVG(property_price) AS avg_price,
    MAX(property_price) AS max_price,
    MIN(property_price) AS min_price
  FROM
    cte_property
  GROUP BY
    property_type
),
cte_agent_stats AS (
  SELECT
    agent_id,
    COUNT(*) AS property_count,
    SUM(property_price) AS total_sales
  FROM
    cte_property
  GROUP BY
    agent_id
),
cte_top_agents AS (
  SELECT
    agent_id,
    total_sales
  FROM
    cte_agent_stats
  WHERE
    total_sales > (
      SELECT
        AVG(total_sales)
      FROM
        cte_agent_stats
    )
),
cte_top_properties AS (
  SELECT
    property_id,
    property_name,
    property_address,
    property_bedrooms,
    property_bathrooms,
    property_price,
    property_sqft,
    property_type,
    property_status,
    property_listing_date,
    property_agent_id,
    agent_name,
    agent_email,
    agent_phone
  FROM
    cte_property
  WHERE
    property_id IN (
      SELECT
        property_id
      FROM
        cte_top_agents
    )
)
SELECT
  property_id,
  property_name,
  property_address,
  property_bedrooms,
  property_bathrooms,
  property_price,
  property_sqft,
  property_type,
  property_status,
  DATE_FORMAT(property_listing_date, '%Y-%m-%d') AS formatted_listing_date,
  CONCAT(agent_name, ' (', agent_email, ')') AS agent_info,
  CASE
    WHEN property_price > (
      SELECT
        AVG(property_price)
      FROM
        cte_property_stats
      WHERE
        property_type = 'house'
    ) THEN 'Expensive'
    ELSE 'Affordable'
  END AS price_category
FROM
  cte_top_properties
WHERE
  property_bedrooms >= 3
  AND property_bathrooms >= 2
  AND property_sqft >= (
    SELECT
      MIN(property_sqft)
    FROM
      cte_property_stats
    WHERE
      property_type = 'apartment'
  )
ORDER BY
  property_price DESC
LIMIT 10;",319,639,958,"[""real_estate.property"", ""real_estate.agent""]","[""real_estate.property"", ""real_estate.agent""]","[""real_estate.property"", ""real_estate.agent""]","[""real_estate.property"", ""real_estate.agent""]"
96,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    a.balance
  FROM 
    bank.customers c
  INNER JOIN 
    bank.accounts a ON c.customer_id = a.customer_id
  WHERE 
    c.age >= 18
    AND c.city = 'New York'
    AND a.balance > 1000
),
cte2 AS (
  SELECT 
    customer_name,
    account_number,
    balance,
    ROW_NUMBER() OVER (PARTITION BY customer_name ORDER BY balance DESC) AS row_num
  FROM 
    cte
)
SELECT 
  cte2.customer_name,
  cte2.account_number,
  cte2.balance,
  t.transaction_date,
  t.transaction_type,
  t.amount
FROM 
  cte2
INNER JOIN 
  bank.transactions t ON cte2.account_number = t.account_number
WHERE 
  t.transaction_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
  AND t.transaction_type IN ('Deposit', 'Withdrawal')
  AND t.amount > (
    SELECT 
      AVG(amount)
    FROM 
      bank.transactions
    WHERE 
      transaction_type = 'Deposit'
  )
  AND cte2.row_num <= 5
ORDER BY 
  cte2.customer_name,
  t.transaction_date DESC;",317,288,605,"['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']"
97,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ' ', a.zip_code) AS customer_address,
    t.trip_id,
    t.trip_name,
    t.trip_date,
    t.trip_duration,
    CONCAT(d.first_name, ' ', d.last_name) AS trip_guide,
    p.package_name,
    p.package_price,
    COUNT(DISTINCT r.reservation_id) AS total_reservations,
    SUM(r.total_price) AS total_revenue
FROM
    travel_agency.customers c
    JOIN travel_agency.addresses a ON c.address_id = a.address_id
    JOIN travel_agency.trips t ON c.customer_id = t.customer_id
    JOIN travel_agency.guides g ON t.guide_id = g.guide_id
    JOIN travel_agency.departments d ON g.department_id = d.department_id
    JOIN travel_agency.packages p ON t.package_id = p.package_id
    JOIN travel_agency.reservations r ON t.trip_id = r.trip_id
WHERE
    t.trip_date >= CURDATE()
    AND p.package_price > 1000
    AND d.department_name = 'Adventure'
GROUP BY
    c.customer_id,
    t.trip_id,
    p.package_id
HAVING
    total_reservations > 5
ORDER BY
    total_revenue DESC
LIMIT 10
CROSS JOIN
    (SELECT 
        COUNT(*) AS total_trips
    FROM
        travel_agency.trips) t2;",319,329,648,"['travel_agency.customers', 'travel_agency.addresses', 'travel_agency.trips', 'travel_agency.guides', 'travel_agency.departments', 'travel_agency.packages', 'travel_agency.reservations']","['travel_agency.customers', 'travel_agency.addresses', 'travel_agency.trips', 'travel_agency.guides', 'travel_agency.departments', 'travel_agency.packages', 'travel_agency.reservations']","['travel_agency.customers', 'travel_agency.addresses', 'travel_agency.trips', 'travel_agency.guides', 'travel_agency.departments', 'travel_agency.packages', 'travel_agency.reservations']","['travel_agency.customers', 'travel_agency.addresses', 'travel_agency.trips', 'travel_agency.guides', 'travel_agency.departments', 'travel_agency.packages', 'travel_agency.reservations']"
98,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an insurance company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(p.policy_id) AS total_policies
  FROM 
    insurance.customers c
  INNER JOIN 
    insurance.policies p ON c.customer_id = p.customer_id
  WHERE 
    c.customer_age >= 30
  GROUP BY 
    c.customer_id
  HAVING 
    total_policies > 5
),
cte2 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(c.customer_id) AS total_claims
  FROM 
    insurance.customers c
  INNER JOIN 
    insurance.claims cl ON c.customer_id = cl.customer_id
  WHERE 
    cl.claim_status = 'Approved'
  GROUP BY 
    c.customer_id
  HAVING 
    total_claims > 3
),
cte3 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    SUM(p.policy_premium) AS total_premium
  FROM 
    insurance.customers c
  INNER JOIN 
    insurance.policies p ON c.customer_id = p.customer_id
  WHERE 
    p.policy_start_date >= '2021-01-01'
  GROUP BY 
    c.customer_id
  HAVING 
    total_premium > 10000
)
SELECT 
  cte1.customer_name,
  cte1.total_policies,
  cte2.total_claims,
  cte3.total_premium,
  CONCAT('Premium per Policy: $', ROUND(cte3.total_premium / cte1.total_policies, 2)) AS avg_premium_per_policy
FROM 
  cte1
INNER JOIN 
  cte2 ON cte1.customer_name = cte2.customer_name
INNER JOIN 
  cte3 ON cte1.customer_name = cte3.customer_name
ORDER BY 
  cte1.total_policies DESC, cte2.total_claims DESC, cte3.total_premium DESC
LIMIT 10;",315,447,762,"['insurance.customers', 'insurance.policies', 'insurance.claims']","['insurance.customers', 'insurance.policies', 'insurance.claims']","['insurance.customers', 'insurance.policies', 'insurance.claims']","['insurance.customers', 'insurance.policies', 'insurance.claims']"
99,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_enrollment AS (
    SELECT
        student_id,
        COUNT(DISTINCT course_id) AS num_courses_enrolled
    FROM
        <database>.<schema>.enrollment
    GROUP BY
        student_id
    HAVING
        COUNT(DISTINCT course_id) >= 3
),
cte_average_grade AS (
    SELECT
        student_id,
        AVG(grade) AS average_grade
    FROM
        <schema>.grades
    GROUP BY
        student_id
),
cte_top_students AS (
    SELECT
        student_id,
        MAX(average_grade) AS max_average_grade
    FROM
        cte_average_grade
    GROUP BY
        student_id
),
cte_student_info AS (
    SELECT
        s.student_id,
        s.first_name,
        s.last_name,
        s.date_of_birth,
        c.course_name,
        e.num_courses_enrolled,
        g.average_grade
    FROM
        <table> s
        INNER JOIN <schema>.courses c ON s.student_id = c.student_id
        INNER JOIN cte_enrollment e ON s.student_id = e.student_id
        INNER JOIN cte_average_grade g ON s.student_id = g.student_id
        INNER JOIN cte_top_students t ON g.student_id = t.student_id
    WHERE
        s.date_of_birth >= '1995-01-01'
        AND c.course_name LIKE '%Math%'
        AND e.num_courses_enrolled >= 5
        AND g.average_grade >= 80
)
SELECT
    student_id,
    CONCAT(first_name, ' ', last_name) AS full_name,
    DATE_FORMAT(date_of_birth, '%Y-%m-%d') AS formatted_dob,
    course_name,
    num_courses_enrolled,
    average_grade,
    UPPER(course_name) AS upper_course_name,
    COUNT(DISTINCT course_name) AS num_distinct_courses
FROM
    cte_student_info
GROUP BY
    student_id,
    full_name,
    formatted_dob,
    course_name,
    num_courses_enrolled,
    average_grade
HAVING
    num_distinct_courses > 1
CROSS JOIN
    <database>.<schema>.teachers
ORDER BY
    student_id ASC,
    average_grade DESC;",316,472,788,"[""<database>.<schema>.enrollment"", ""<schema>.grades"", ""<table>"", ""<schema>.courses"", ""<database>.<schema>.teachers""]","[""<database>.<schema>.enrollment"", ""<schema>.grades"", ""<table>"", ""<schema>.courses"", ""<database>.<schema>.teachers""]","[""<database>.<schema>.enrollment"", ""<schema>.grades"", ""<table>"", ""<schema>.courses"", ""<database>.<schema>.teachers""]","[""<database>.<schema>.enrollment"", ""<schema>.grades"", ""<table>"", ""<schema>.courses"", ""<database>.<schema>.teachers""]"
100,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_patient AS (
    SELECT 
        p.patient_id,
        p.patient_name,
        p.date_of_birth,
        p.gender,
        p.address,
        p.phone_number,
        p.email
    FROM 
        healthcare_database.patients p
    WHERE 
        p.date_of_birth <= DATE_SUB(CURRENT_DATE(), INTERVAL 18 YEAR)
),

cte_appointment AS (
    SELECT 
        a.appointment_id,
        a.patient_id,
        a.appointment_date,
        a.appointment_time,
        a.doctor_id,
        a.department_id,
        a.reason_for_visit
    FROM 
        healthcare_database.appointments a
    INNER JOIN 
        cte_patient cp ON a.patient_id = cp.patient_id
    WHERE 
        a.appointment_date >= CURRENT_DATE()
),

cte_doctor AS (
    SELECT 
        d.doctor_id,
        d.doctor_name,
        d.specialty,
        d.department_id,
        d.years_of_experience,
        d.education
    FROM 
        healthcare_database.doctors d
),

cte_department AS (
    SELECT 
        dep.department_id,
        dep.department_name,
        dep.location,
        dep.head_doctor_id
    FROM 
        healthcare_database.departments dep
),

cte_prescription AS (
    SELECT 
        pr.prescription_id,
        pr.patient_id,
        pr.doctor_id,
        pr.prescription_date,
        pr.medication_name,
        pr.dosage,
        pr.frequency
    FROM 
        healthcare_database.prescriptions pr
    INNER JOIN 
        cte_patient cp ON pr.patient_id = cp.patient_id
),

cte_medication AS (
    SELECT 
        m.medication_id,
        m.medication_name,
        m.manufacturer,
        m.unit_price,
        m.expiry_date
    FROM 
        healthcare_database.medications m
),

cte_invoice AS (
    SELECT 
        i.invoice_id,
        i.patient_id,
        i.invoice_date,
        i.total_amount,
        i.payment_status
    FROM 
        healthcare_database.invoices i
    INNER JOIN 
        cte_patient cp ON i.patient_id = cp.patient_id
),

cte_payment AS (
    SELECT 
        p.payment_id,
        p.invoice_id,
        p.payment_date,
        p.payment_amount,
        p.payment_method
    FROM 
        healthcare_database.payments p
    INNER JOIN 
        cte_invoice ci ON p.invoice_id = ci.invoice_id
),

cte_test AS (
    SELECT 
        t.test_id,
        t.patient_id,
        t.test_date,
        t.test_type,
        t.result
    FROM 
        healthcare_database.tests t
    INNER JOIN 
        cte_patient cp ON t.patient_id = cp.patient_id
),

cte_diagnosis AS (
    SELECT 
        d.diagnosis_id,
        d.patient_id,
        d.doctor_id,
        d.diagnosis_date,
        d.diagnosis_description
    FROM 
        healthcare_database.diagnoses d
    INNER JOIN 
        cte_patient cp ON d.patient_id = cp.patient_id
),

cte_treatment AS (
    SELECT 
        tr.treatment_id,
        tr.patient_id,
        tr.doctor_id,
        tr.treatment_date,
        tr.treatment_description
    FROM 
        healthcare_database.treatments tr
    INNER JOIN 
        cte_patient cp ON tr.patient_id = cp.patient_id
),

cte_patient_summary AS (
    SELECT 
        cp.patient_id,
        cp.patient_name,
        cp.date_of_birth,
        cp.gender,
        cp.address,
        cp.phone_number,
        cp.email,
        COUNT(DISTINCT ca.appointment_id) AS total_appointments,
        COUNT(DISTINCT cpres.prescription_id) AS total_prescriptions,
        COUNT(DISTINCT ci.invoice_id) AS total_invoices,
        COUNT(DISTINCT cpay.payment_id) AS total_payments,
        COUNT(DISTINCT ctest.test_id) AS total_tests,
        COUNT(DISTINCT cdiag.diagnosis_id) AS total_diagnoses,
        COUNT(DISTINCT ctreat.treatment_id) AS total_treatments
    FROM 
        cte_patient cp
    LEFT JOIN 
        cte_appointment ca ON cp.patient_id = ca.patient_id
    LEFT JOIN 
        cte_prescription cpres ON cp.patient_id = cpres.patient_id
    LEFT JOIN 
        cte_invoice ci ON cp.patient_id = ci.patient_id
    LEFT JOIN 
        cte_payment cpay ON ci.invoice_id = cpay.invoice_id
    LEFT JOIN 
        cte_test ctest ON cp.patient_id = ctest.patient_id
    LEFT JOIN 
        cte_diagnosis cdiag ON cp.patient_id = cdiag.patient_id
    LEFT JOIN 
        cte_treatment ctreat ON cp.patient_id = ctreat.patient_id
    GROUP BY 
        cp.patient_id,
        cp.patient_name,
        cp.date_of_birth,
        cp.gender,
        cp.address,
        cp.phone_number,
        cp.email
    HAVING 
        total_appointments > 5
),

cte_doctor_summary AS (
    SELECT 
        cd.doctor_id,
        cd.doctor_name,
        cd.specialty,
        cd.department_id,
        cd.years_of_experience,
        cd.education,
        COUNT(DISTINCT ca.appointment_id) AS total_appointments,
        COUNT(DISTINCT cpres.prescription_id) AS total_prescriptions,
        COUNT(DISTINCT cdiag.diagnosis_id) AS total_diagnoses,
        COUNT(DISTINCT ctreat.treatment_id) AS total_treatments
    FROM 
        cte_doctor cd
    LEFT JOIN 
        cte_appointment ca ON cd.doctor_id = ca.doctor_id
    LEFT JOIN 
        cte_prescription cpres ON cd.doctor_id = cpres.doctor_id
    LEFT JOIN 
        cte_diagnosis cdiag ON cd.doctor_id = cdiag.doctor_id
    LEFT JOIN 
        cte_treatment ctreat ON cd.doctor_id = ctreat.doctor_id
    GROUP BY 
        cd.doctor_id,
        cd.doctor_name,
        cd.specialty,
        cd.department_id,
        cd.years_of_experience,
        cd.education
    HAVING 
        total_appointments > 10
),

cte_department_summary AS (
    SELECT 
        cdep.department_id,
        cdep.department_name,
        cdep.location,
        cdep.head_doctor_id,
        COUNT(DISTINCT cdoc.doctor_id) AS total_doctors,
        COUNT(DISTINCT ca.appointment_id) AS total_appointments,
        COUNT(DISTINCT cpres.prescription_id) AS total_prescriptions,
        COUNT(DISTINCT cdiag.diagnosis_id) AS total_diagnoses,
        COUNT(DISTINCT ctreat.treatment_id) AS total_treatments
    FROM 
        cte_department cdep
    LEFT JOIN 
        cte_doctor cdoc ON cdep.department_id = cdoc.department_id
    LEFT JOIN 
        cte_appointment ca ON cdep.department_id = ca.department_id
    LEFT JOIN 
        cte_prescription cpres ON cdep.department_id = cpres.department_id
    LEFT JOIN 
        cte_diagnosis cdiag ON cdep.department_id = cdiag.department_id
    LEFT JOIN 
        cte_treatment ctreat ON cdep.department_id = ctreat.department_id
    GROUP BY 
        cdep.department_id,
        cdep.department_name,
        cdep.location,
        cdep.head_doctor_id
    HAVING 
        total_doctors > 5
),

cte_medication_summary AS (
    SELECT 
        cmed.medication_id,
        cmed.medication_name,
        cmed.manufacturer,
        cmed.unit_price,
        cmed.expiry_date,
        COUNT(DISTINCT cpres.prescription_id) AS total_prescriptions
    FROM 
        cte_medication cmed
    LEFT JOIN 
        cte_prescription cpres ON cmed.medication_id = cpres.medication_id
    GROUP BY 
        cmed.medication_id,
        cmed.medication_name,
        cmed.manufacturer,
        cmed.unit_price,
        cmed.expiry_date
    HAVING 
        total_prescriptions > 100
)

SELECT 
    ps.patient_id,
    ps.patient_name,
    ps.date_of_birth,
    ps.gender,
    ps.address,
    ps.phone_number,
    ps.email,
    ds.department_name,
    ds.location,
    ds.total_doctors,
    ds.total_appointments,
    ds.total_prescriptions,
    ds.total_diagnoses,
    ds.total_treatments,
    ms.medication_name,
    ms.manufacturer,
    ms.unit_price,
    ms.expiry_date,
    ms.total_prescriptions
FROM 
    cte_patient_summary ps
LEFT JOIN 
    cte_department_summary ds ON ps.department_id = ds.department_id
LEFT JOIN 
    cte_medication_summary ms ON ps.medication_id = ms.medication_id
ORDER BY 
    ps.patient_id ASC;",325,1894,2219,"['healthcare_database.patients', 'healthcare_database.appointments', 'healthcare_database.doctors', 'healthcare_database.departments', 'healthcare_database.prescriptions', 'healthcare_database.medications', 'healthcare_database.invoices', 'healthcare_database.payments', 'healthcare_database.tests', 'healthcare_database.diagnoses', 'healthcare_database.treatments']","['healthcare_database.patients', 'healthcare_database.appointments', 'healthcare_database.doctors', 'healthcare_database.departments', 'healthcare_database.prescriptions', 'healthcare_database.medications', 'healthcare_database.invoices', 'healthcare_database.payments', 'healthcare_database.tests', 'healthcare_database.diagnoses', 'healthcare_database.treatments']","['healthcare_database.patients', 'healthcare_database.appointments', 'healthcare_database.doctors', 'healthcare_database.departments', 'healthcare_database.prescriptions', 'healthcare_database.medications', 'healthcare_database.invoices', 'healthcare_database.payments', 'healthcare_database.tests', 'healthcare_database.diagnoses', 'healthcare_database.treatments']","['healthcare_database.patients', 'healthcare_database.appointments', 'healthcare_database.doctors', 'healthcare_database.departments', 'healthcare_database.prescriptions', 'healthcare_database.medications', 'healthcare_database.invoices', 'healthcare_database.payments', 'healthcare_database.tests', 'healthcare_database.diagnoses', 'healthcare_database.treatments']"
101,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(cust.first_name, ' ', cust.last_name) AS customer_name,
    acc.account_number,
    acc.balance
  FROM 
    bank.customers AS cust
  JOIN 
    bank.accounts AS acc ON cust.customer_id = acc.customer_id
  WHERE 
    cust.country = 'USA'
),
cte2 AS (
  SELECT 
    customer_name,
    COUNT(*) AS num_transactions
  FROM 
    bank.transactions AS trans
  JOIN 
    cte1 ON trans.account_number = cte1.account_number
  WHERE 
    trans.transaction_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
  GROUP BY 
    customer_name
),
cte3 AS (
  SELECT 
    customer_name,
    SUM(trans.amount) AS total_amount
  FROM 
    bank.transactions AS trans
  JOIN 
    cte1 ON trans.account_number = cte1.account_number
  WHERE 
    trans.transaction_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
  GROUP BY 
    customer_name
),
cte4 AS (
  SELECT 
    customer_name,
    AVG(balance) AS avg_balance
  FROM 
    cte1
  GROUP BY 
    customer_name
)
SELECT 
  cte1.customer_name,
  cte1.account_number,
  cte1.balance,
  cte2.num_transactions,
  cte3.total_amount,
  cte4.avg_balance
FROM 
  cte1
JOIN 
  cte2 ON cte1.customer_name = cte2.customer_name
JOIN 
  cte3 ON cte1.customer_name = cte3.customer_name
JOIN 
  cte4 ON cte1.customer_name = cte4.customer_name
WHERE 
  cte1.balance > 10000
HAVING 
  cte2.num_transactions > 5
ORDER BY 
  cte3.total_amount DESC;",321,407,728,"['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']"
102,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_type,
        p.unit_price,
        SUM(o.quantity) AS total_quantity
    FROM
        energy_company.products p
    INNER JOIN
        energy_company.orders o ON p.product_id = o.product_id
    WHERE
        o.order_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_type,
        p.unit_price
),
cte2 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_type,
        p.unit_price,
        SUM(o.quantity) AS total_quantity
    FROM
        energy_company.products p
    INNER JOIN
        energy_company.orders o ON p.product_id = o.product_id
    WHERE
        o.order_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_type,
        p.unit_price
),
cte3 AS (
    SELECT 
        c.customer_id,
        c.customer_name,
        c.city,
        c.state,
        COUNT(o.order_id) AS total_orders
    FROM
        energy_company.customers c
    LEFT JOIN
        energy_company.orders o ON c.customer_id = o.customer_id
    WHERE
        c.state IN ('CA', 'TX', 'NY')
    GROUP BY
        c.customer_id,
        c.customer_name,
        c.city,
        c.state
)
SELECT 
    cte1.product_id,
    cte1.product_name,
    cte1.product_type,
    cte1.unit_price,
    cte1.total_quantity,
    cte2.total_quantity AS previous_total_quantity,
    cte3.customer_id,
    cte3.customer_name,
    cte3.city,
    cte3.state,
    cte3.total_orders
FROM
    cte1
LEFT JOIN
    cte2 ON cte1.product_id = cte2.product_id
LEFT JOIN
    cte3 ON cte1.product_id = cte3.customer_id
WHERE
    cte1.total_quantity > 100
HAVING
    cte3.total_orders > 5
ORDER BY
    cte1.product_id ASC,
    cte3.total_orders DESC;",319,486,805,"['energy_company.products', 'energy_company.orders', 'energy_company.customers']","['energy_company.products', 'energy_company.orders', 'energy_company.customers']","['energy_company.products', 'energy_company.orders', 'energy_company.customers']","['energy_company.products', 'energy_company.orders', 'energy_company.customers']"
103,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH
  cte_articles AS (
    SELECT
      a.article_id,
      a.title,
      a.author,
      a.publish_date,
      a.category_id,
      c.category_name
    FROM
      news.articles a
    JOIN
      news.categories c ON a.category_id = c.category_id
    WHERE
      a.publish_date >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
  ),
  cte_top_articles AS (
    SELECT
      article_id,
      title,
      author,
      publish_date,
      category_id,
      category_name,
      ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY publish_date DESC) AS rn
    FROM
      cte_articles
  ),
  cte_popular_categories AS (
    SELECT
      category_id,
      category_name,
      COUNT(*) AS article_count
    FROM
      cte_articles
    GROUP BY
      category_id,
      category_name
    HAVING
      COUNT(*) > 5
  ),
  cte_top_authors AS (
    SELECT
      author,
      COUNT(*) AS article_count
    FROM
      cte_articles
    GROUP BY
      author
    HAVING
      COUNT(*) > 3
  )
SELECT
  ta.title,
  ta.author,
  DATE_FORMAT(ta.publish_date, '%Y-%m-%d') AS formatted_publish_date,
  ta.category_name,
  pc.category_name AS popular_category,
  au.article_count AS author_article_count,
  pc.article_count AS popular_category_article_count
FROM
  cte_top_articles ta
JOIN
  cte_popular_categories pc ON ta.category_id = pc.category_id
JOIN
  cte_top_authors au ON ta.author = au.author
CROSS JOIN
  news.advertisements ad
WHERE
  ta.rn <= 5
ORDER BY
  ta.publish_date DESC;",318,389,707,"['news.articles', 'news.categories', 'cte_articles', 'cte_top_articles', 'cte_popular_categories', 'cte_top_authors', 'news.advertisements']","['news.articles', 'news.categories', 'cte_articles', 'cte_top_articles', 'cte_popular_categories', 'cte_top_authors', 'news.advertisements']","['news.articles', 'news.categories', 'cte_articles', 'cte_top_articles', 'cte_popular_categories', 'cte_top_authors', 'news.advertisements']","['news.articles', 'news.categories', 'cte_articles', 'cte_top_articles', 'cte_popular_categories', 'cte_top_authors', 'news.advertisements']"
104,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.product_price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.product_price) AS total_price
FROM 
    ecommerce.customers c
INNER JOIN 
    ecommerce.orders o ON c.customer_id = o.customer_id
LEFT JOIN 
    ecommerce.order_products op ON o.order_id = op.order_id
LEFT JOIN 
    ecommerce.products p ON op.product_id = p.product_id
WHERE 
    o.order_status = 'completed'
    AND YEAR(o.order_date) = 2021
    AND p.product_category IN ('electronics', 'clothing')
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id,
    p.product_name,
    p.product_price
HAVING 
    total_price > 1000
ORDER BY 
    total_price DESC;",327,213,540,"['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']","['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']","['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']","['ecommerce.customers', 'ecommerce.orders', 'ecommerce.order_products', 'ecommerce.products']"
105,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.product_category,
    p.product_price,
    s.supplier_name,
    s.supplier_country
  FROM
    products p
  INNER JOIN
    suppliers s ON p.supplier_id = s.supplier_id
  WHERE
    p.product_category = 'Electronics'
),

cte2 AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    c.customer_name,
    c.customer_country,
    oi.product_id,
    oi.quantity,
    oi.unit_price
  FROM
    orders o
  INNER JOIN
    customers c ON o.customer_id = c.customer_id
  INNER JOIN
    order_items oi ON o.order_id = oi.order_id
),

cte3 AS (
  SELECT 
    cte2.order_id,
    cte2.order_date,
    cte2.customer_id,
    cte2.customer_name,
    cte2.customer_country,
    cte2.product_id,
    cte2.quantity,
    cte2.unit_price,
    cte1.product_name,
    cte1.product_category,
    cte1.product_price,
    cte1.supplier_name,
    cte1.supplier_country,
    cte2.quantity * cte2.unit_price AS total_price
  FROM
    cte2
  INNER JOIN
    cte1 ON cte2.product_id = cte1.product_id
),

cte4 AS (
  SELECT 
    cte3.customer_id,
    cte3.customer_name,
    cte3.customer_country,
    COUNT(DISTINCT cte3.order_id) AS total_orders,
    SUM(cte3.total_price) AS total_sales
  FROM
    cte3
  GROUP BY
    cte3.customer_id,
    cte3.customer_name,
    cte3.customer_country
  HAVING
    total_sales > 10000
),

cte5 AS (
  SELECT 
    cte4.customer_id,
    cte4.customer_name,
    cte4.customer_country,
    cte4.total_orders,
    cte4.total_sales,
    ROW_NUMBER() OVER (PARTITION BY cte4.customer_country ORDER BY cte4.total_sales DESC) AS rank
  FROM
    cte4
),

cte6 AS (
  SELECT 
    cte5.customer_id,
    cte5.customer_name,
    cte5.customer_country,
    cte5.total_orders,
    cte5.total_sales,
    cte5.rank
  FROM
    cte5
  WHERE
    cte5.rank <= 10
),

cte7 AS (
  SELECT 
    cte6.customer_id,
    cte6.customer_name,
    cte6.customer_country,
    cte6.total_orders,
    cte6.total_sales,
    cte6.rank,
    CONCAT('Rank ', cte6.rank) AS rank_label
  FROM
    cte6
),

cte8 AS (
  SELECT 
    cte7.customer_id,
    cte7.customer_name,
    cte7.customer_country,
    cte7.total_orders,
    cte7.total_sales,
    cte7.rank,
    cte7.rank_label,
    CASE
      WHEN cte7.total_sales > 50000 THEN 'High'
      WHEN cte7.total_sales > 20000 THEN 'Medium'
      ELSE 'Low'
    END AS sales_category
  FROM
    cte7
),

cte9 AS (
  SELECT 
    cte8.customer_id,
    cte8.customer_name,
    cte8.customer_country,
    cte8.total_orders,
    cte8.total_sales,
    cte8.rank,
    cte8.rank_label,
    cte8.sales_category,
    UPPER(cte8.customer_country) AS uppercase_country
  FROM
    cte8
),

cte10 AS (
  SELECT 
    cte9.customer_id,
    cte9.customer_name,
    cte9.customer_country,
    cte9.total_orders,
    cte9.total_sales,
    cte9.rank,
    cte9.rank_label,
    cte9.sales_category,
    cte9.uppercase_country,
    DATE_FORMAT(cte9.rank_label, '%Y-%m-%d') AS formatted_rank_label
  FROM
    cte9
),

cte11 AS (
  SELECT 
    cte10.customer_id,
    cte10.customer_name,
    cte10.customer_country,
    cte10.total_orders,
    cte10.total_sales,
    cte10.rank,
    cte10.rank_label,
    cte10.sales_category,
    cte10.uppercase_country,
    cte10.formatted_rank_label,
    CASE
      WHEN cte10.sales_category = 'High' THEN cte10.total_sales * 0.1
      WHEN cte10.sales_category = 'Medium' THEN cte10.total_sales * 0.05
      ELSE cte10.total_sales * 0.02
    END AS discount_amount
  FROM
    cte10
),

cte12 AS (
  SELECT 
    cte11.customer_id,
    cte11.customer_name,
    cte11.customer_country,
    cte11.total_orders,
    cte11.total_sales,
    cte11.rank,
    cte11.rank_label,
    cte11.sales_category,
    cte11.uppercase_country,
    cte11.formatted_rank_label,
    cte11.discount_amount,
    cte11.total_sales - cte11.discount_amount AS discounted_sales
  FROM
    cte11
),

cte13 AS (
  SELECT 
    cte12.customer_id,
    cte12.customer_name,
    cte12.customer_country,
    cte12.total_orders,
    cte12.total_sales,
    cte12.rank,
    cte12.rank_label,
    cte12.sales_category,
    cte12.uppercase_country,
    cte12.formatted_rank_label,
    cte12.discount_amount,
    cte12.discounted_sales,
    CASE
      WHEN cte12.discounted_sales > 50000 THEN 'VIP'
      WHEN cte12.discounted_sales > 20000 THEN 'Preferred'
      ELSE 'Regular'
    END AS customer_type
  FROM
    cte12
)

SELECT 
  cte13.customer_id,
  cte13.customer_name,
  cte13.customer_country,
  cte13.total_orders,
  cte13.total_sales,
  cte13.rank,
  cte13.rank_label,
  cte13.sales_category,
  cte13.uppercase_country,
  cte13.formatted_rank_label,
  cte13.discount_amount,
  cte13.discounted_sales,
  cte13.customer_type
FROM
  cte13
WHERE
  cte13.customer_type = 'VIP'
ORDER BY
  cte13.total_sales DESC;",318,1473,1791,"['products', 'suppliers', 'orders', 'customers', 'order_items']","['products', 'suppliers', 'orders', 'customers', 'order_items']","['products', 'suppliers', 'orders', 'customers', 'order_items']","['products', 'suppliers', 'orders', 'customers', 'order_items']"
106,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    a.balance
  FROM 
    bank.customers AS c
  INNER JOIN 
    bank.accounts AS a ON c.customer_id = a.customer_id
  WHERE 
    c.city = 'New York'
    AND a.balance > 10000
),
cte2 AS (
  SELECT 
    cte.customer_name,
    cte.account_number,
    t.transaction_date,
    t.amount
  FROM 
    cte
  CROSS JOIN 
    bank.transactions AS t
  WHERE 
    t.account_number = cte.account_number
    AND t.transaction_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
),
cte3 AS (
  SELECT 
    cte2.customer_name,
    cte2.account_number,
    SUM(cte2.amount) AS total_transaction_amount
  FROM 
    cte2
  GROUP BY 
    cte2.customer_name,
    cte2.account_number
  HAVING 
    total_transaction_amount > 5000
),
cte4 AS (
  SELECT 
    cte3.customer_name,
    cte3.account_number,
    COUNT(*) AS num_transactions
  FROM 
    cte3
  GROUP BY 
    cte3.customer_name,
    cte3.account_number
),
cte5 AS (
  SELECT 
    cte4.customer_name,
    cte4.account_number,
    AVG(cte4.num_transactions) AS avg_num_transactions
  FROM 
    cte4
  GROUP BY 
    cte4.customer_name,
    cte4.account_number
),
cte6 AS (
  SELECT 
    cte5.customer_name,
    cte5.account_number,
    CASE 
      WHEN cte5.avg_num_transactions > 5 THEN 'High'
      WHEN cte5.avg_num_transactions > 3 THEN 'Medium'
      ELSE 'Low'
    END AS transaction_frequency
  FROM 
    cte5
),
cte7 AS (
  SELECT 
    cte6.customer_name,
    cte6.account_number,
    cte6.transaction_frequency,
    ROW_NUMBER() OVER (PARTITION BY cte6.transaction_frequency ORDER BY cte6.account_number) AS row_num
  FROM 
    cte6
),
cte8 AS (
  SELECT 
    cte7.customer_name,
    cte7.account_number,
    cte7.transaction_frequency
  FROM 
    cte7
  WHERE 
    cte7.row_num = 1
)
SELECT 
  cte8.customer_name,
  cte8.account_number,
  cte8.transaction_frequency
FROM 
  cte8
ORDER BY 
  cte8.customer_name ASC, 
  cte8.account_number ASC;",320,592,912,"['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']"
107,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_date,
    p.product_name,
    p.unit_price,
    SUM(od.quantity) AS total_quantity,
    SUM(od.quantity * p.unit_price) AS total_sales,
    AVG(p.unit_price) AS average_price,
    COUNT(DISTINCT o.order_id) AS total_orders
FROM 
    energy_company.customers c
JOIN 
    energy_company.orders o ON c.customer_id = o.customer_id
JOIN 
    energy_company.order_details od ON o.order_id = od.order_id
JOIN 
    energy_company.products p ON od.product_id = p.product_id
WHERE 
    o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
    AND p.category = 'Renewable Energy'
GROUP BY 
    c.customer_id,
    c.first_name,
    c.last_name,
    o.order_date,
    p.product_id,
    p.product_name,
    p.unit_price
HAVING 
    total_sales > 10000
ORDER BY 
    total_sales DESC
LIMIT 10
CROSS JOIN 
    (SELECT 
        COUNT(*) AS total_customers
    FROM 
        energy_company.customers) AS subquery1
LEFT JOIN 
    (SELECT 
        COUNT(*) AS total_products
    FROM 
        energy_company.products) AS subquery2 ON subquery1.total_customers = subquery2.total_products;",325,306,631,"['energy_company.customers', 'energy_company.orders', 'energy_company.order_details', 'energy_company.products']","['energy_company.customers', 'energy_company.orders', 'energy_company.order_details', 'energy_company.products']","['energy_company.customers', 'energy_company.orders', 'energy_company.order_details', 'energy_company.products']","['energy_company.customers', 'energy_company.orders', 'energy_company.order_details', 'energy_company.products']"
108,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a marketing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT
    c.customer_id,
    c.customer_name,
    CONCAT(c.customer_address, ', ', c.customer_city, ', ', c.customer_state) AS full_address,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.order_total) AS total_sales,
    AVG(o.order_total) AS average_sales,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_date
FROM
    marketing.customers c
JOIN
    marketing.orders o ON c.customer_id = o.customer_id
JOIN
    (
        SELECT
            customer_id,
            MAX(order_date) AS latest_order_date
        FROM
            marketing.orders
        GROUP BY
            customer_id
    ) latest ON o.customer_id = latest.customer_id AND o.order_date = latest.latest_order_date
WHERE
    c.customer_state = 'California'
    AND o.order_status = 'Completed'
    AND o.order_total > 1000
GROUP BY
    c.customer_id,
    c.customer_name,
    full_address
HAVING
    total_orders > 5
ORDER BY
    total_sales DESC;",314,229,543,"[""marketing.customers"", ""marketing.orders""]","[""marketing.customers"", ""marketing.orders""]","[""marketing.customers"", ""marketing.orders""]","[""marketing.customers"", ""marketing.orders""]"
109,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
         CONCAT(p.first_name, ' ', p.last_name) AS full_name,
         CASE WHEN p.gender = 'M' THEN 'Male' ELSE 'Female' END AS gender_description
  FROM patients p
  WHERE p.date_of_birth >= '1980-01-01'
),
cte2 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(d.first_name, ' ', d.last_name) AS doctor_name,
         CONCAT(p.first_name, ' ', p.last_name) AS patient_name
  FROM appointments a
  JOIN doctors d ON a.doctor_id = d.doctor_id
  JOIN patients p ON a.patient_id = p.patient_id
  WHERE a.appointment_date >= CURDATE()
),
cte3 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(d.first_name, ' ', d.last_name) AS doctor_name,
         CONCAT(p.first_name, ' ', p.last_name) AS patient_name,
         COUNT(*) AS total_prescriptions
  FROM appointments a
  JOIN doctors d ON a.doctor_id = d.doctor_id
  JOIN patients p ON a.patient_id = p.patient_id
  JOIN prescriptions pr ON a.appointment_id = pr.appointment_id
  WHERE a.appointment_date >= CURDATE()
  GROUP BY a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
           CONCAT(d.first_name, ' ', d.last_name), CONCAT(p.first_name, ' ', p.last_name)
),
cte4 AS (
  SELECT p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
         CONCAT(p.first_name, ' ', p.last_name) AS full_name,
         CASE WHEN p.gender = 'M' THEN 'Male' ELSE 'Female' END AS gender_description,
         COUNT(*) AS total_appointments
  FROM patients p
  JOIN appointments a ON p.patient_id = a.patient_id
  WHERE a.appointment_date >= CURDATE()
  GROUP BY p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
           CONCAT(p.first_name, ' ', p.last_name), CASE WHEN p.gender = 'M' THEN 'Male' ELSE 'Female' END
),
cte5 AS (
  SELECT p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
         CONCAT(p.first_name, ' ', p.last_name) AS full_name,
         CASE WHEN p.gender = 'M' THEN 'Male' ELSE 'Female' END AS gender_description,
         COUNT(*) AS total_prescriptions
  FROM patients p
  JOIN appointments a ON p.patient_id = a.patient_id
  JOIN prescriptions pr ON a.appointment_id = pr.appointment_id
  WHERE a.appointment_date >= CURDATE()
  GROUP BY p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
           CONCAT(p.first_name, ' ', p.last_name), CASE WHEN p.gender = 'M' THEN 'Male' ELSE 'Female' END
)
SELECT cte1.patient_id, cte1.patient_name, cte1.date_of_birth, cte1.gender, cte1.address, cte1.phone_number, 
       cte1.full_name, cte1.gender_description, cte4.total_appointments, cte5.total_prescriptions
FROM cte1
LEFT JOIN cte4 ON cte1.patient_id = cte4.patient_id
LEFT JOIN cte5 ON cte1.patient_id = cte5.patient_id
WHERE cte1.gender = 'F'
HAVING cte4.total_appointments > 5
ORDER BY cte1.patient_name ASC;",320,857,1177,"['patients', 'appointments', 'doctors', 'prescriptions']","['patients', 'appointments', 'doctors', 'prescriptions']","['patients', 'appointments', 'doctors', 'prescriptions']","['patients', 'appointments', 'doctors', 'prescriptions']"
110,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.product_name, ' - ', p.product_code) AS product_info,
    c.category_name AS product_category,
    s.supplier_name AS supplier,
    SUM(o.quantity) AS total_quantity_sold,
    SUM(o.quantity * o.unit_price) AS total_revenue,
    AVG(o.unit_price) AS average_price,
    COUNT(DISTINCT o.customer_id) AS unique_customers,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date
FROM
    pharmaceuticals.products p
    INNER JOIN pharmaceuticals.categories c ON p.category_id = c.category_id
    LEFT JOIN pharmaceuticals.suppliers s ON p.supplier_id = s.supplier_id
    LEFT JOIN (
        SELECT 
            od.product_id,
            od.order_id,
            od.quantity,
            od.unit_price,
            o.customer_id,
            o.order_date
        FROM
            pharmaceuticals.order_details od
            INNER JOIN pharmaceuticals.orders o ON od.order_id = o.order_id
        WHERE
            o.order_status = 'completed'
    ) o ON p.product_id = o.product_id
WHERE
    p.is_active = 1
GROUP BY
    p.product_id,
    c.category_id,
    s.supplier_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d')
HAVING
    total_quantity_sold > 100
ORDER BY
    total_revenue DESC;",319,293,612,"['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']"
111,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    COUNT(o.order_id) AS total_orders,
    SUM(p.price) AS total_sales,
    AVG(p.price) AS average_price,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_items oi ON o.order_id = oi.order_id
JOIN 
    products p ON oi.product_id = p.product_id
WHERE 
    c.city = 'New York'
    AND p.category = 'Apartment'
    AND o.order_date >= '2021-01-01'
GROUP BY 
    c.customer_id, c.first_name, c.last_name
HAVING 
    total_orders > 5
ORDER BY 
    total_sales DESC;",317,181,498,"[""customers"", ""orders"", ""order_items"", ""products""]","[""customers"", ""orders"", ""order_items"", ""products""]","[""customers"", ""orders"", ""order_items"", ""products""]","[""customers"", ""orders"", ""order_items"", ""products""]"
112,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a logistics company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    o.order_date,
    p.product_name,
    p.unit_price,
    SUM(od.quantity) AS total_quantity,
    SUM(od.quantity * p.unit_price) AS total_price
FROM 
    logistics.orders o
JOIN 
    logistics.customers c ON o.customer_id = c.customer_id
JOIN 
    logistics.order_details od ON o.order_id = od.order_id
JOIN 
    logistics.products p ON od.product_id = p.product_id
WHERE 
    o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
    AND c.country = 'United States'
    AND p.category = 'Electronics'
GROUP BY 
    c.first_name,
    c.last_name,
    o.order_id,
    o.order_date,
    p.product_name,
    p.unit_price
HAVING 
    COUNT(DISTINCT o.order_id) > 1
    AND SUM(od.quantity) > 10
ORDER BY 
    total_price DESC
LIMIT 100;",319,231,550,"['logistics.orders', 'logistics.customers', 'logistics.order_details', 'logistics.products']","['logistics.orders', 'logistics.customers', 'logistics.order_details', 'logistics.products']","['logistics.orders', 'logistics.customers', 'logistics.order_details', 'logistics.products']","['logistics.orders', 'logistics.customers', 'logistics.order_details', 'logistics.products']"
113,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.product_name, ' - ', p.product_code) AS product_info,
    c.category_name AS product_category,
    s.supplier_name AS supplier,
    SUM(o.quantity) AS total_quantity_sold,
    SUM(o.quantity * o.unit_price) AS total_revenue,
    AVG(o.unit_price) AS average_price,
    COUNT(DISTINCT o.customer_id) AS unique_customers,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date
FROM
    pharmaceuticals.products p
    JOIN pharmaceuticals.categories c ON p.category_id = c.category_id
    JOIN pharmaceuticals.suppliers s ON p.supplier_id = s.supplier_id
    JOIN (
        SELECT 
            od.product_id,
            od.order_id,
            od.quantity,
            od.unit_price,
            o.customer_id,
            o.order_date
        FROM
            pharmaceuticals.order_details od
            JOIN pharmaceuticals.orders o ON od.order_id = o.order_id
        WHERE
            o.order_status = 'completed'
    ) o ON p.product_id = o.product_id
WHERE
    p.is_active = 1
GROUP BY
    p.product_id,
    c.category_id,
    s.supplier_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d')
HAVING
    total_quantity_sold > 100
ORDER BY
    total_revenue DESC;",316,289,605,"['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']","['pharmaceuticals.products', 'pharmaceuticals.categories', 'pharmaceuticals.suppliers', 'pharmaceuticals.order_details', 'pharmaceuticals.orders']"
114,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an entertainment company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    COUNT(DISTINCT customer_id) AS unique_customers
  FROM 
    entertainment.sales
  WHERE 
    date >= '2021-01-01' AND date <= '2021-12-31'
  GROUP BY 
    month_year
),

cte2 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    COUNT(DISTINCT order_id) AS total_orders
  FROM 
    entertainment.orders
  WHERE 
    date >= '2021-01-01' AND date <= '2021-12-31'
  GROUP BY 
    month_year
),

cte3 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    SUM(total_price) AS total_sales
  FROM 
    entertainment.orders
  WHERE 
    date >= '2021-01-01' AND date <= '2021-12-31'
  GROUP BY 
    month_year
),

cte4 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    COUNT(DISTINCT customer_id) AS new_customers
  FROM 
    entertainment.customers
  WHERE 
    date_registered >= '2021-01-01' AND date_registered <= '2021-12-31'
  GROUP BY 
    month_year
),

cte5 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    COUNT(DISTINCT customer_id) AS returning_customers
  FROM 
    entertainment.customers
  WHERE 
    date_registered < '2021-01-01' AND last_purchase_date >= '2021-01-01' AND last_purchase_date <= '2021-12-31'
  GROUP BY 
    month_year
),

cte6 AS (
  SELECT 
    CONCAT(cast(year(date) as string), '-', cast(month(date) as string)) AS month_year,
    COUNT(DISTINCT customer_id) AS churned_customers
  FROM 
    entertainment.customers
  WHERE 
    date_registered < '2021-01-01' AND last_purchase_date < '2021-01-01'
  GROUP BY 
    month_year
)

SELECT 
  cte1.month_year,
  cte1.unique_customers,
  cte2.total_orders,
  cte3.total_sales,
  cte4.new_customers,
  cte5.returning_customers,
  cte6.churned_customers
FROM 
  cte1
JOIN 
  cte2 ON cte1.month_year = cte2.month_year
JOIN 
  cte3 ON cte1.month_year = cte3.month_year
JOIN 
  cte4 ON cte1.month_year = cte4.month_year
JOIN 
  cte5 ON cte1.month_year = cte5.month_year
JOIN 
  cte6 ON cte1.month_year = cte6.month_year
ORDER BY 
  cte1.month_year ASC;",327,696,1023,"['entertainment.sales', 'entertainment.orders', 'entertainment.customers']","['entertainment.sales', 'entertainment.orders', 'entertainment.customers']","['entertainment.sales', 'entertainment.orders', 'entertainment.customers']","['entertainment.sales', 'entertainment.orders', 'entertainment.customers']"
115,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT call_id) AS total_calls
    FROM 
        telecom.calls
    WHERE 
        DATE(call_date) >= '2021-01-01'
    GROUP BY 
        customer_id
    HAVING 
        COUNT(DISTINCT call_id) > 10
),
cte2 AS (
    SELECT 
        customer_id,
        SUM(call_duration) AS total_duration
    FROM 
        telecom.calls
    WHERE 
        DATE(call_date) >= '2021-01-01'
    GROUP BY 
        customer_id
),
cte3 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT sms_id) AS total_sms
    FROM 
        telecom.sms
    WHERE 
        DATE(sms_date) >= '2021-01-01'
    GROUP BY 
        customer_id
),
cte4 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT data_session_id) AS total_data_sessions
    FROM 
        telecom.data_sessions
    WHERE 
        DATE(session_date) >= '2021-01-01'
    GROUP BY 
        customer_id
),
cte5 AS (
    SELECT 
        customer_id,
        SUM(data_usage) AS total_data_usage
    FROM 
        telecom.data_sessions
    WHERE 
        DATE(session_date) >= '2021-01-01'
    GROUP BY 
        customer_id
),
cte6 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT purchase_id) AS total_purchases
    FROM 
        telecom.purchases
    WHERE 
        DATE(purchase_date) >= '2021-01-01'
    GROUP BY 
        customer_id
),
cte7 AS (
    SELECT 
        customer_id,
        SUM(purchase_amount) AS total_purchase_amount
    FROM 
        telecom.purchases
    WHERE 
        DATE(purchase_date) >= '2021-01-01'
    GROUP BY 
        customer_id
)
SELECT 
    c.customer_id,
    c.total_calls,
    d.total_duration,
    s.total_sms,
    ds.total_data_sessions,
    ds.total_data_usage,
    p.total_purchases,
    p.total_purchase_amount
FROM 
    cte1 c
JOIN 
    cte2 d ON c.customer_id = d.customer_id
JOIN 
    cte3 s ON c.customer_id = s.customer_id
JOIN 
    cte4 ds ON c.customer_id = ds.customer_id
JOIN 
    cte5 du ON c.customer_id = du.customer_id
JOIN 
    cte6 p ON c.customer_id = p.customer_id
JOIN 
    cte7 pa ON c.customer_id = pa.customer_id
ORDER BY 
    c.customer_id;",322,578,900,"['telecom.calls', 'telecom.sms', 'telecom.data_sessions', 'telecom.purchases']","['telecom.calls', 'telecom.sms', 'telecom.data_sessions', 'telecom.purchases']","['telecom.calls', 'telecom.sms', 'telecom.data_sessions', 'telecom.purchases']","['telecom.calls', 'telecom.sms', 'telecom.data_sessions', 'telecom.purchases']"
116,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_property AS (
    SELECT property_id, property_name, property_type, property_price
    FROM <database>.<schema>.property
    WHERE property_status = 'available'
),
cte_agent AS (
    SELECT agent_id, agent_name, agent_phone, agent_email
    FROM <schema>.agent
    WHERE agent_status = 'active'
),
cte_sale AS (
    SELECT property_id, agent_id, sale_date, sale_price
    FROM <table>
    WHERE sale_date >= '2021-01-01'
),
cte_total_sales AS (
    SELECT agent_id, SUM(sale_price) AS total_sales
    FROM cte_sale
    GROUP BY agent_id
),
cte_avg_price AS (
    SELECT property_type, AVG(property_price) AS avg_price
    FROM cte_property
    GROUP BY property_type
),
cte_top_agents AS (
    SELECT agent_id, COUNT(*) AS total_properties
    FROM cte_property
    GROUP BY agent_id
    HAVING total_properties > 5
),
cte_agent_performance AS (
    SELECT a.agent_id, a.agent_name, a.agent_phone, a.agent_email, COALESCE(ts.total_sales, 0) AS total_sales, COALESCE(ap.avg_price, 0) AS avg_price
    FROM cte_agent a
    LEFT JOIN cte_total_sales ts ON a.agent_id = ts.agent_id
    LEFT JOIN cte_avg_price ap ON a.agent_id = ap.agent_id
),
cte_top_performing_agents AS (
    SELECT agent_id, agent_name, agent_phone, agent_email, total_sales, avg_price
    FROM cte_agent_performance
    WHERE total_sales > 1000000 AND avg_price > 500000
),
cte_agent_ranking AS (
    SELECT agent_id, agent_name, agent_phone, agent_email, total_sales, avg_price,
        ROW_NUMBER() OVER (ORDER BY total_sales DESC, avg_price DESC) AS agent_rank
    FROM cte_agent_performance
),
cte_property_details AS (
    SELECT p.property_id, p.property_name, p.property_type, p.property_price, a.agent_name, a.agent_phone, a.agent_email
    FROM cte_property p
    LEFT JOIN cte_agent a ON p.agent_id = a.agent_id
),
cte_property_ranking AS (
    SELECT property_id, property_name, property_type, property_price,
        ROW_NUMBER() OVER (PARTITION BY property_type ORDER BY property_price DESC) AS property_rank
    FROM cte_property_details
),
cte_top_properties AS (
    SELECT property_id, property_name, property_type, property_price
    FROM cte_property_ranking
    WHERE property_rank <= 5
)
SELECT tp.property_name, tp.property_type, tp.property_price, ap.agent_name, ap.agent_phone, ap.agent_email
FROM cte_top_properties tp
JOIN cte_top_performing_agents ap ON tp.agent_id = ap.agent_id
JOIN cte_agent_ranking ar ON tp.agent_id = ar.agent_id
WHERE ar.agent_rank <= 3
ORDER BY tp.property_type, tp.property_price DESC;",314,649,963,"['<database>.<schema>.property', '<schema>.agent', '<table>']","['<database>.<schema>.property', '<schema>.agent', '<table>']","['<database>.<schema>.property', '<schema>.agent', '<table>']","['<database>.<schema>.property', '<schema>.agent', '<table>']"
117,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(manufacturing_orders.order_id, '-', manufacturing_orders.order_date) AS order_number,
    manufacturing_orders.order_status,
    manufacturing_orders.order_quantity,
    manufacturing_orders.order_quantity * manufacturing_products.unit_price AS total_price,
    manufacturing_products.product_name,
    manufacturing_products.product_category,
    manufacturing_suppliers.supplier_name,
    manufacturing_suppliers.supplier_country,
    manufacturing_customers.customer_name,
    manufacturing_customers.customer_city,
    manufacturing_customers.customer_state,
    manufacturing_customers.customer_country
FROM 
    manufacturing_orders
JOIN 
    manufacturing_products ON manufacturing_orders.product_id = manufacturing_products.product_id
JOIN 
    manufacturing_suppliers ON manufacturing_products.supplier_id = manufacturing_suppliers.supplier_id
JOIN 
    manufacturing_customers ON manufacturing_orders.customer_id = manufacturing_customers.customer_id
WHERE 
    manufacturing_orders.order_status = 'Completed'
    AND manufacturing_orders.order_date >= DATE_FORMAT(CURRENT_DATE(), '%Y-%m-01')
    AND manufacturing_orders.order_date < DATE_FORMAT(CURRENT_DATE() + INTERVAL 1 MONTH, '%Y-%m-01')
    AND manufacturing_products.product_category IN ('Electronics', 'Furniture')
GROUP BY 
    manufacturing_orders.order_id,
    manufacturing_orders.order_date,
    manufacturing_orders.order_status,
    manufacturing_orders.order_quantity,
    manufacturing_products.unit_price,
    manufacturing_products.product_name,
    manufacturing_products.product_category,
    manufacturing_suppliers.supplier_name,
    manufacturing_suppliers.supplier_country,
    manufacturing_customers.customer_name,
    manufacturing_customers.customer_city,
    manufacturing_customers.customer_state,
    manufacturing_customers.customer_country
HAVING 
    COUNT(DISTINCT manufacturing_orders.order_id) > 1
ORDER BY 
    total_price DESC
LIMIT 100;",319,353,672,"['manufacturing_orders', 'manufacturing_products', 'manufacturing_suppliers', 'manufacturing_customers']","['manufacturing_orders', 'manufacturing_products', 'manufacturing_suppliers', 'manufacturing_customers']","['manufacturing_orders', 'manufacturing_products', 'manufacturing_suppliers', 'manufacturing_customers']","['manufacturing_orders', 'manufacturing_products', 'manufacturing_suppliers', 'manufacturing_customers']"
118,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        p.product_price,
        SUM(o.order_quantity) AS total_quantity
    FROM 
        products p
    INNER JOIN 
        orders o ON p.product_id = o.product_id
    WHERE 
        p.product_category = 'Electronics'
    GROUP BY 
        p.product_id,
        p.product_name,
        p.product_category,
        p.product_price
    HAVING 
        total_quantity > 100
), cte2 AS (
    SELECT 
        cte1.product_id,
        cte1.product_name,
        cte1.product_category,
        cte1.product_price,
        cte1.total_quantity,
        SUM(s.shipment_quantity) AS total_shipment
    FROM 
        cte1
    LEFT JOIN 
        shipments s ON cte1.product_id = s.product_id
    GROUP BY 
        cte1.product_id,
        cte1.product_name,
        cte1.product_category,
        cte1.product_price,
        cte1.total_quantity
), cte3 AS (
    SELECT 
        cte2.product_id,
        cte2.product_name,
        cte2.product_category,
        cte2.product_price,
        cte2.total_quantity,
        cte2.total_shipment,
        CONCAT(cte2.product_name, ' - ', cte2.product_category) AS product_description
    FROM 
        cte2
    WHERE 
        cte2.total_shipment > 50
), cte4 AS (
    SELECT 
        cte3.product_id,
        cte3.product_name,
        cte3.product_category,
        cte3.product_price,
        cte3.total_quantity,
        cte3.total_shipment,
        cte3.product_description,
        UPPER(cte3.product_category) AS uppercase_category
    FROM 
        cte3
    WHERE 
        cte3.total_quantity > 200
), cte5 AS (
    SELECT 
        cte4.product_id,
        cte4.product_name,
        cte4.product_category,
        cte4.product_price,
        cte4.total_quantity,
        cte4.total_shipment,
        cte4.product_description,
        cte4.uppercase_category,
        DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date
    FROM 
        cte4
    INNER JOIN 
        orders o ON cte4.product_id = o.product_id
    WHERE 
        o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
), cte6 AS (
    SELECT 
        cte5.product_id,
        cte5.product_name,
        cte5.product_category,
        cte5.product_price,
        cte5.total_quantity,
        cte5.total_shipment,
        cte5.product_description,
        cte5.uppercase_category,
        cte5.formatted_order_date,
        COUNT(DISTINCT c.customer_id) AS unique_customers
    FROM 
        cte5
    LEFT JOIN 
        customers c ON cte5.product_id = c.product_id
    GROUP BY 
        cte5.product_id,
        cte5.product_name,
        cte5.product_category,
        cte5.product_price,
        cte5.total_quantity,
        cte5.total_shipment,
        cte5.product_description,
        cte5.uppercase_category,
        cte5.formatted_order_date
)
SELECT 
    cte6.product_id,
    cte6.product_name,
    cte6.product_category,
    cte6.product_price,
    cte6.total_quantity,
    cte6.total_shipment,
    cte6.product_description,
    cte6.uppercase_category,
    cte6.formatted_order_date,
    cte6.unique_customers,
    AVG(cte6.product_price) AS average_price
FROM 
    cte6
GROUP BY 
    cte6.product_id,
    cte6.product_name,
    cte6.product_category,
    cte6.product_price,
    cte6.total_quantity,
    cte6.total_shipment,
    cte6.product_description,
    cte6.uppercase_category,
    cte6.formatted_order_date
HAVING 
    unique_customers > 5
ORDER BY 
    average_price DESC;",316,927,1243,"['products', 'orders', 'shipments', 'customers']","['products', 'orders', 'shipments', 'customers']","['products', 'orders', 'shipments', 'customers']","['products', 'orders', 'shipments', 'customers']"
119,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    c.email,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_price) AS total_sales,
    AVG(DATEDIFF(o.order_date, c.date_of_birth)) AS avg_age_at_purchase,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    UPPER(p.product_name) AS product_name,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ', ', a.country) AS full_address
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_items oi ON o.order_id = oi.order_id
JOIN 
    products p ON oi.product_id = p.product_id
JOIN 
    addresses a ON c.address_id = a.address_id
WHERE 
    c.date_of_birth <= '1990-01-01'
    AND o.order_date >= '2020-01-01'
    AND p.category = 'Flight'
GROUP BY 
    c.customer_id,
    o.order_date,
    p.product_id
HAVING 
    total_sales > 1000
ORDER BY 
    total_sales DESC,
    avg_age_at_purchase ASC
LIMIT 100;",314,267,581,"['customers', 'orders', 'order_items', 'products', 'addresses']","['customers', 'orders', 'order_items', 'products', 'addresses']","['customers', 'orders', 'order_items', 'products', 'addresses']","['customers', 'orders', 'order_items', 'products', 'addresses']"
120,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_enrollment AS (
    SELECT
        s.student_id,
        s.student_name,
        c.course_id,
        c.course_name,
        e.enrollment_date
    FROM
        students s
        INNER JOIN enrollments e ON s.student_id = e.student_id
        INNER JOIN courses c ON e.course_id = c.course_id
    WHERE
        e.enrollment_date >= '2021-01-01'
),

cte_grades AS (
    SELECT
        e.student_id,
        e.course_id,
        g.grade
    FROM
        cte_enrollment e
        INNER JOIN grades g ON e.student_id = g.student_id AND e.course_id = g.course_id
    WHERE
        g.grade >= 70
),

cte_avg_grade AS (
    SELECT
        student_id,
        AVG(grade) AS avg_grade
    FROM
        cte_grades
    GROUP BY
        student_id
),

cte_top_students AS (
    SELECT
        a.student_id,
        a.student_name,
        a.course_id,
        a.course_name,
        a.enrollment_date,
        b.avg_grade
    FROM
        cte_enrollment a
        INNER JOIN cte_avg_grade b ON a.student_id = b.student_id
    WHERE
        b.avg_grade >= 90
),

cte_course_stats AS (
    SELECT
        c.course_id,
        c.course_name,
        COUNT(DISTINCT e.student_id) AS num_students,
        SUM(CASE WHEN g.grade >= 70 THEN 1 ELSE 0 END) AS num_passed,
        SUM(CASE WHEN g.grade < 70 THEN 1 ELSE 0 END) AS num_failed,
        AVG(g.grade) AS avg_grade
    FROM
        courses c
        LEFT JOIN enrollments e ON c.course_id = e.course_id
        LEFT JOIN grades g ON e.student_id = g.student_id AND e.course_id = g.course_id
    GROUP BY
        c.course_id,
        c.course_name
    HAVING
        num_students > 0
),

cte_student_rank AS (
    SELECT
        student_id,
        ROW_NUMBER() OVER (ORDER BY avg_grade DESC) AS rank
    FROM
        cte_avg_grade
),

cte_top_courses AS (
    SELECT
        course_id,
        course_name,
        avg_grade
    FROM
        cte_course_stats
    WHERE
        avg_grade >= 80
),

cte_student_course_rank AS (
    SELECT
        a.student_id,
        a.student_name,
        a.course_id,
        a.course_name,
        a.enrollment_date,
        b.rank
    FROM
        cte_enrollment a
        INNER JOIN cte_student_rank b ON a.student_id = b.student_id
    WHERE
        b.rank <= 10
),

cte_student_course_rank_top AS (
    SELECT
        a.student_id,
        a.student_name,
        a.course_id,
        a.course_name,
        a.enrollment_date,
        a.rank,
        b.avg_grade
    FROM
        cte_student_course_rank a
        INNER JOIN cte_course_stats b ON a.course_id = b.course_id
    WHERE
        b.avg_grade >= 80
),

cte_final_report AS (
    SELECT
        a.student_id,
        a.student_name,
        a.course_id,
        a.course_name,
        a.enrollment_date,
        a.rank,
        a.avg_grade,
        b.num_students,
        b.num_passed,
        b.num_failed
    FROM
        cte_student_course_rank_top a
        INNER JOIN cte_course_stats b ON a.course_id = b.course_id
)

SELECT
    f.student_id,
    f.student_name,
    f.course_id,
    f.course_name,
    f.enrollment_date,
    f.rank,
    f.avg_grade,
    f.num_students,
    f.num_passed,
    f.num_failed
FROM
    cte_final_report f
ORDER BY
    f.avg_grade DESC,
    f.num_students DESC,
    f.num_passed DESC,
    f.num_failed ASC
LIMIT 100;",324,854,1178,"['students', 'enrollments', 'courses', 'grades']","['students', 'enrollments', 'courses', 'grades']","['students', 'enrollments', 'courses', 'grades']","['students', 'enrollments', 'courses', 'grades']"
121,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ' ', a.zip_code) AS customer_address,
    COUNT(*) AS total_properties,
    SUM(p.price) AS total_sales,
    AVG(p.price) AS average_price,
    MAX(p.price) AS highest_price,
    MIN(p.price) AS lowest_price
FROM 
    real_estate.customers c
JOIN 
    real_estate.addresses a ON c.address_id = a.id
JOIN 
    real_estate.properties p ON c.id = p.customer_id
WHERE 
    c.status = 'active'
    AND p.status = 'sold'
    AND p.type = 'residential'
    AND p.bedrooms >= 3
    AND p.bathrooms >= 2
GROUP BY 
    c.id, a.id
HAVING 
    total_properties > 5
ORDER BY 
    total_sales DESC
LIMIT 10;",317,206,523,"['real_estate.customers', 'real_estate.addresses', 'real_estate.properties']","['real_estate.customers', 'real_estate.addresses', 'real_estate.properties']","['real_estate.customers', 'real_estate.addresses', 'real_estate.properties']","['real_estate.customers', 'real_estate.addresses', 'real_estate.properties']"
122,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a marketing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    o.order_id,
    o.order_date,
    o.total_price
  FROM
    marketing.customers AS c
  INNER JOIN
    marketing.orders AS o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'United States'
    AND o.order_status = 'completed'
),

cte2 AS (
  SELECT
    p.product_name,
    p.product_category,
    p.product_price,
    o.order_id
  FROM
    marketing.products AS p
  INNER JOIN
    marketing.order_items AS oi ON p.product_id = oi.product_id
  INNER JOIN
    cte1 AS c ON oi.order_id = c.order_id
),

cte3 AS (
  SELECT
    cte1.customer_name,
    cte1.order_date,
    SUM(cte2.product_price) AS total_spent
  FROM
    cte1
  LEFT JOIN
    cte2 ON cte1.order_id = cte2.order_id
  GROUP BY
    cte1.customer_name,
    cte1.order_date
),

cte4 AS (
  SELECT
    cte3.customer_name,
    COUNT(cte3.order_date) AS total_orders
  FROM
    cte3
  GROUP BY
    cte3.customer_name
),

cte5 AS (
  SELECT
    cte3.customer_name,
    AVG(cte3.total_spent) AS avg_spent
  FROM
    cte3
  GROUP BY
    cte3.customer_name
),

cte6 AS (
  SELECT
    cte3.customer_name,
    MAX(cte3.total_spent) AS max_spent
  FROM
    cte3
  GROUP BY
    cte3.customer_name
),

cte7 AS (
  SELECT
    cte3.customer_name,
    MIN(cte3.total_spent) AS min_spent
  FROM
    cte3
  GROUP BY
    cte3.customer_name
)

SELECT
  cte4.customer_name,
  cte4.total_orders,
  cte5.avg_spent,
  cte6.max_spent,
  cte7.min_spent
FROM
  cte4
LEFT JOIN
  cte5 ON cte4.customer_name = cte5.customer_name
LEFT JOIN
  cte6 ON cte4.customer_name = cte6.customer_name
LEFT JOIN
  cte7 ON cte4.customer_name = cte7.customer_name
ORDER BY
  cte4.total_orders DESC;",318,563,881,"['marketing.customers', 'marketing.orders', 'marketing.products', 'marketing.order_items']","['marketing.customers', 'marketing.orders', 'marketing.products', 'marketing.order_items']","['marketing.customers', 'marketing.orders', 'marketing.products', 'marketing.order_items']","['marketing.customers', 'marketing.orders', 'marketing.products', 'marketing.order_items']"
123,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a marketing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    c.customer_email
  FROM
    marketing.orders o
  INNER JOIN
    marketing.customers c ON o.customer_id = c.customer_id
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

cte_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_sales
  FROM
    cte_orders
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m')
),

cte_top_customers AS (
  SELECT
    customer_id,
    COUNT(DISTINCT order_id) AS total_orders
  FROM
    cte_orders
  GROUP BY
    customer_id
  HAVING
    COUNT(DISTINCT order_id) >= 5
),

cte_customer_activity AS (
  SELECT
    c.customer_id,
    CONCAT(c.customer_name, ' (', c.customer_email, ')') AS customer_info,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_price) AS total_spent
  FROM
    marketing.customers c
  LEFT JOIN
    marketing.orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_id IN (
      SELECT
        customer_id
      FROM
        cte_top_customers
    )
  GROUP BY
    c.customer_id,
    c.customer_name,
    c.customer_email
),

cte_campaign_performance AS (
  SELECT
    c.campaign_id,
    c.campaign_name,
    COUNT(DISTINCT s.order_id) AS total_orders,
    SUM(s.total_sales) AS total_sales
  FROM
    marketing.campaigns c
  LEFT JOIN
    cte_sales s ON c.campaign_id = s.campaign_id
  GROUP BY
    c.campaign_id,
    c.campaign_name
),

cte_top_campaigns AS (
  SELECT
    campaign_id,
    total_orders,
    total_sales,
    ROW_NUMBER() OVER (ORDER BY total_sales DESC) AS rank
  FROM
    cte_campaign_performance
),

cte_final AS (
  SELECT
    c.customer_info,
    c.total_orders,
    c.total_spent,
    t.campaign_name,
    t.total_orders AS campaign_orders,
    t.total_sales AS campaign_sales,
    t.rank
  FROM
    cte_customer_activity c
  LEFT JOIN
    cte_top_campaigns t ON c.customer_id = t.customer_id
)

SELECT
  customer_info,
  total_orders,
  total_spent,
  campaign_name,
  campaign_orders,
  campaign_sales,
  rank
FROM
  cte_final
WHERE
  rank <= 10
ORDER BY
  rank ASC;",318,624,942,"[""marketing.orders"", ""marketing.customers"", ""marketing.customers"", ""marketing.orders"", ""marketing.campaigns"", ""cte_sales"", ""cte_top_customers"", ""cte_customer_activity"", ""cte_campaign_performance"", ""cte_top_campaigns"", ""cte_final"", ""cte_final""]","[""marketing.orders"", ""marketing.customers"", ""marketing.customers"", ""marketing.orders"", ""marketing.campaigns"", ""cte_sales"", ""cte_top_customers"", ""cte_customer_activity"", ""cte_campaign_performance"", ""cte_top_campaigns"", ""cte_final"", ""cte_final""]","[""marketing.orders"", ""marketing.customers"", ""marketing.customers"", ""marketing.orders"", ""marketing.campaigns"", ""cte_sales"", ""cte_top_customers"", ""cte_customer_activity"", ""cte_campaign_performance"", ""cte_top_campaigns"", ""cte_final"", ""cte_final""]","[""marketing.orders"", ""marketing.customers"", ""marketing.customers"", ""marketing.orders"", ""marketing.campaigns"", ""cte_sales"", ""cte_top_customers"", ""cte_customer_activity"", ""cte_campaign_performance"", ""cte_top_campaigns"", ""cte_final"", ""cte_final""]"
124,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.unit_price,
    oi.quantity,
    oi.quantity * p.unit_price AS total_price
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_items oi ON o.order_id = oi.order_id
JOIN 
    products p ON oi.product_id = p.product_id
JOIN 
    categories cat ON p.category_id = cat.category_id
JOIN 
    suppliers s ON p.supplier_id = s.supplier_id
WHERE 
    cat.category_name = 'Electronics'
    AND s.country = 'USA'
    AND oi.quantity > 0
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id
HAVING 
    SUM(oi.quantity * p.unit_price) > 1000
ORDER BY 
    customer_name ASC,
    formatted_order_date DESC,
    total_price DESC
LIMIT 100;",319,232,551,"['customers', 'orders', 'order_items', 'products', 'categories', 'suppliers']","['customers', 'orders', 'order_items', 'products', 'categories', 'suppliers']","['customers', 'orders', 'order_items', 'products', 'categories', 'suppliers']","['customers', 'orders', 'order_items', 'products', 'categories', 'suppliers']"
125,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_students AS (
    SELECT s.student_id, s.student_name, s.date_of_birth, s.gender, s.address, s.city, s.state, s.country
    FROM education.students s
    WHERE s.country = 'United States'
),
cte_courses AS (
    SELECT c.course_id, c.course_name, c.course_description, c.course_credits, c.department_id
    FROM education.courses c
    WHERE c.department_id IN (
        SELECT d.department_id
        FROM education.departments d
        WHERE d.department_name = 'Computer Science'
    )
),
cte_enrollments AS (
    SELECT e.student_id, e.course_id, e.enrollment_date, e.grade
    FROM education.enrollments e
    WHERE e.grade >= 70
),
cte_departments AS (
    SELECT d.department_id, d.department_name, d.department_head, d.location, d.university_id
    FROM education.departments d
    WHERE d.university_id = (
        SELECT u.university_id
        FROM education.universities u
        WHERE u.university_name = 'Harvard University'
    )
),
cte_universities AS (
    SELECT u.university_id, u.university_name, u.university_location, u.foundation_year
    FROM education.universities u
    WHERE u.foundation_year < YEAR(CURRENT_DATE())
),
cte_top_students AS (
    SELECT s.student_id, s.student_name, AVG(e.grade) AS average_grade
    FROM cte_students s
    INNER JOIN cte_enrollments e ON s.student_id = e.student_id
    GROUP BY s.student_id, s.student_name
    HAVING AVG(e.grade) >= 90
),
cte_course_stats AS (
    SELECT c.course_id, c.course_name, COUNT(e.student_id) AS total_students, AVG(e.grade) AS average_grade
    FROM cte_courses c
    LEFT JOIN cte_enrollments e ON c.course_id = e.course_id
    GROUP BY c.course_id, c.course_name
),
cte_department_stats AS (
    SELECT d.department_id, d.department_name, COUNT(DISTINCT c.course_id) AS total_courses, COUNT(DISTINCT e.student_id) AS total_students
    FROM cte_departments d
    LEFT JOIN cte_courses c ON d.department_id = c.department_id
    LEFT JOIN cte_enrollments e ON c.course_id = e.course_id
    GROUP BY d.department_id, d.department_name
),
cte_university_stats AS (
    SELECT u.university_id, u.university_name, COUNT(DISTINCT d.department_id) AS total_departments, COUNT(DISTINCT c.course_id) AS total_courses, COUNT(DISTINCT e.student_id) AS total_students
    FROM cte_universities u
    LEFT JOIN cte_departments d ON u.university_id = d.university_id
    LEFT JOIN cte_courses c ON d.department_id = c.department_id
    LEFT JOIN cte_enrollments e ON c.course_id = e.course_id
    GROUP BY u.university_id, u.university_name
)
SELECT s.student_name, s.date_of_birth, s.gender, s.address, s.city, s.state, s.country,
    c.course_name, c.course_description, c.course_credits,
    e.enrollment_date, e.grade,
    d.department_name, d.department_head, d.location,
    u.university_name, u.university_location, u.foundation_year,
    ts.average_grade,
    cs.total_students, cs.average_grade,
    ds.total_courses, ds.total_students,
    us.total_departments, us.total_courses, us.total_students
FROM cte_students s
INNER JOIN cte_enrollments e ON s.student_id = e.student_id
INNER JOIN cte_courses c ON e.course_id = c.course_id
INNER JOIN cte_departments d ON c.department_id = d.department_id
INNER JOIN cte_universities u ON d.university_id = u.university_id
LEFT JOIN cte_top_students ts ON s.student_id = ts.student_id
LEFT JOIN cte_course_stats cs ON c.course_id = cs.course_id
LEFT JOIN cte_department_stats ds ON d.department_id = ds.department_id
LEFT JOIN cte_university_stats us ON u.university_id = us.university_id
CROSS JOIN (
    SELECT COUNT(*) AS total_students, AVG(e.grade) AS average_grade
    FROM cte_enrollments e
) overall_stats;",316,936,1252,"['education.students', 'education.courses', 'education.departments', 'education.enrollments', 'education.universities']","['education.students', 'education.courses', 'education.departments', 'education.enrollments', 'education.universities']","['education.students', 'education.courses', 'education.departments', 'education.enrollments', 'education.universities']","['education.students', 'education.courses', 'education.departments', 'education.enrollments', 'education.universities']"
126,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a retail company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.product_price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.product_price) AS total_sales
FROM 
    retail['|'].customers AS c
JOIN 
    retail.orders AS o ON c.customer_id = o.customer_id
JOIN 
    retail.products AS p ON p.product_id = op.product_id
JOIN 
    (
        SELECT 
            order_id,
            product_id,
            SUM(quantity) AS quantity
        FROM 
            retail.order_products
        GROUP BY 
            order_id,
            product_id
    ) AS op ON op.order_id = o.order_id
WHERE 
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
    AND p.product_category = 'Electronics'
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id
HAVING 
    total_sales > 1000
ORDER BY 
    total_sales DESC;",319,248,567,"['retail.customers', 'retail.orders', 'retail.products', 'retail.order_products']","['retail.customers', 'retail.orders', 'retail.products', 'retail.order_products']","['retail.customers', 'retail.orders', 'retail.products', 'retail.order_products']","['retail.customers', 'retail.orders', 'retail.products', 'retail.order_products']"
127,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(manufacturing_db['|'].products.product_name, ' - ', manufacturing_db['|'].products.product_code) AS Product,
    manufacturing_db['|'].products.category AS Category,
    manufacturing_db['|'].products.unit_price AS UnitPrice,
    SUM(manufacturing_db['|'].orders.quantity) AS TotalQuantity,
    SUM(manufacturing_db['|'].orders.quantity * manufacturing_db['|'].products.unit_price) AS TotalSales,
    AVG(manufacturing_db['|'].orders.quantity) AS AvgQuantity,
    COUNT(DISTINCT manufacturing_db['|'].orders.customer_id) AS TotalCustomers
FROM 
    manufacturing_db['|'].products
JOIN 
    manufacturing_db['|'].orders ON manufacturing_db['|'].products.product_id = manufacturing_db['|'].orders.product_id
JOIN 
    manufacturing_db['|'].customers ON manufacturing_db['|'].orders.customer_id = manufacturing_db['|'].customers.customer_id
WHERE 
    manufacturing_db['|'].products.category = 'Electronics'
    AND manufacturing_db['|'].orders.order_date >= DATE_FORMAT(CURRENT_DATE, '%Y-%m-01')
    AND manufacturing_db['|'].orders.order_date <= DATE_FORMAT(CURRENT_DATE, '%Y-%m-%d')
GROUP BY 
    manufacturing_db['|'].products.product_name,
    manufacturing_db['|'].products.product_code,
    manufacturing_db['|'].products.category,
    manufacturing_db['|'].products.unit_price
HAVING 
    TotalSales > 10000
ORDER BY 
    TotalSales DESC;",323,319,642,"['manufacturing_db.products', 'manufacturing_db.orders', 'manufacturing_db.customers']","['manufacturing_db.products', 'manufacturing_db.orders', 'manufacturing_db.customers']","['manufacturing_db.products', 'manufacturing_db.orders', 'manufacturing_db.customers']","['manufacturing_db.products', 'manufacturing_db.orders', 'manufacturing_db.customers']"
128,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT articles.article_id, articles.title, articles.author, articles.publish_date, articles.category_id, categories.category_name
    FROM news.articles
    INNER JOIN news.categories ON articles.category_id = categories.category_id
    WHERE articles.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)
),
cte2 AS (
    SELECT cte1.category_id, cte1.category_name, COUNT(DISTINCT cte1.article_id) AS total_articles
    FROM cte1
    GROUP BY cte1.category_id, cte1.category_name
    HAVING total_articles > 5
),
cte3 AS (
    SELECT cte1.author, COUNT(DISTINCT cte1.article_id) AS total_articles
    FROM cte1
    GROUP BY cte1.author
    HAVING total_articles > 3
),
cte4 AS (
    SELECT cte1.category_id, cte1.category_name, COUNT(DISTINCT cte1.article_id) AS total_articles
    FROM cte1
    INNER JOIN cte2 ON cte1.category_id = cte2.category_id
    GROUP BY cte1.category_id, cte1.category_name
    HAVING total_articles > 10
),
cte5 AS (
    SELECT cte1.author, COUNT(DISTINCT cte1.article_id) AS total_articles
    FROM cte1
    INNER JOIN cte3 ON cte1.author = cte3.author
    GROUP BY cte1.author
    HAVING total_articles > 5
)
SELECT cte1.title, cte1.author, cte1.publish_date, cte1.category_name, cte2.total_articles AS category_total_articles, cte3.total_articles AS author_total_articles
FROM cte1
INNER JOIN cte2 ON cte1.category_id = cte2.category_id
INNER JOIN cte3 ON cte1.author = cte3.author
INNER JOIN cte4 ON cte1.category_id = cte4.category_id
INNER JOIN cte5 ON cte1.author = cte5.author
WHERE cte1.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
ORDER BY cte1.publish_date DESC
LIMIT 10;",322,478,800,"['news.articles', 'news.categories']","['news.articles', 'news.categories']","['news.articles', 'news.categories']","['news.articles', 'news.categories']"
129,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        p.product_price,
        s.supplier_name,
        s.supplier_location
    FROM 
        manufacturing.products p
    JOIN 
        manufacturing.suppliers s ON p.supplier_id = s.supplier_id
    WHERE 
        p.product_category = 'Electronics'
),

cte2 AS (
    SELECT 
        o.order_id,
        o.order_date,
        o.customer_id,
        c.customer_name,
        c.customer_location,
        oi.product_id,
        oi.quantity,
        oi.unit_price
    FROM 
        manufacturing.orders o
    JOIN 
        manufacturing.customers c ON o.customer_id = c.customer_id
    JOIN 
        manufacturing.order_items oi ON o.order_id = oi.order_id
    WHERE 
        o.order_date >= '2021-01-01'
),

cte3 AS (
    SELECT 
        cte2.order_id,
        cte2.order_date,
        cte2.customer_id,
        cte2.customer_name,
        cte2.customer_location,
        cte2.product_id,
        cte2.quantity,
        cte2.unit_price,
        cte1.product_name,
        cte1.product_category,
        cte1.product_price,
        cte1.supplier_name,
        cte1.supplier_location
    FROM 
        cte2
    JOIN 
        cte1 ON cte2.product_id = cte1.product_id
),

cte4 AS (
    SELECT 
        cte3.order_id,
        cte3.order_date,
        cte3.customer_id,
        cte3.customer_name,
        cte3.customer_location,
        cte3.product_id,
        cte3.quantity,
        cte3.unit_price,
        cte3.product_name,
        cte3.product_category,
        cte3.product_price,
        cte3.supplier_name,
        cte3.supplier_location,
        cte3.quantity * cte3.unit_price AS total_price
    FROM 
        cte3
),

cte5 AS (
    SELECT 
        cte4.order_id,
        cte4.order_date,
        cte4.customer_id,
        cte4.customer_name,
        cte4.customer_location,
        cte4.product_id,
        cte4.quantity,
        cte4.unit_price,
        cte4.product_name,
        cte4.product_category,
        cte4.product_price,
        cte4.supplier_name,
        cte4.supplier_location,
        cte4.total_price,
        CASE
            WHEN cte4.total_price > 1000 THEN 'High'
            WHEN cte4.total_price > 500 THEN 'Medium'
            ELSE 'Low'
        END AS price_category
    FROM 
        cte4
),

cte6 AS (
    SELECT 
        cte5.customer_id,
        cte5.customer_name,
        cte5.customer_location,
        COUNT(DISTINCT cte5.order_id) AS order_count,
        SUM(cte5.total_price) AS total_sales
    FROM 
        cte5
    GROUP BY 
        cte5.customer_id,
        cte5.customer_name,
        cte5.customer_location
    HAVING 
        COUNT(DISTINCT cte5.order_id) > 2
),

cte7 AS (
    SELECT 
        cte6.customer_id,
        cte6.customer_name,
        cte6.customer_location,
        cte6.order_count,
        cte6.total_sales,
        CASE
            WHEN cte6.total_sales > 5000 THEN 'VIP'
            WHEN cte6.total_sales > 2000 THEN 'Preferred'
            ELSE 'Regular'
        END AS customer_type
    FROM 
        cte6
),

cte8 AS (
    SELECT 
        cte7.customer_id,
        cte7.customer_name,
        cte7.customer_location,
        cte7.order_count,
        cte7.total_sales,
        cte7.customer_type,
        ROW_NUMBER() OVER (PARTITION BY cte7.customer_type ORDER BY cte7.total_sales DESC) AS rank
    FROM 
        cte7
),

cte9 AS (
    SELECT 
        cte8.customer_id,
        cte8.customer_name,
        cte8.customer_location,
        cte8.order_count,
        cte8.total_sales,
        cte8.customer_type,
        cte8.rank
    FROM 
        cte8
    WHERE 
        cte8.rank <= 5
),

cte10 AS (
    SELECT 
        cte9.customer_id,
        cte9.customer_name,
        cte9.customer_location,
        cte9.order_count,
        cte9.total_sales,
        cte9.customer_type,
        cte9.rank,
        CONCAT(cte9.customer_name, ' - ', cte9.customer_location) AS customer_info
    FROM 
        cte9
)

SELECT 
    cte10.customer_id,
    cte10.customer_name,
    cte10.customer_location,
    cte10.order_count,
    cte10.total_sales,
    cte10.customer_type,
    cte10.rank,
    cte10.customer_info
FROM 
    cte10
ORDER BY 
    cte10.rank ASC;",327,1126,1453,"['manufacturing.products', 'manufacturing.suppliers', 'manufacturing.orders', 'manufacturing.customers', 'manufacturing.order_items']","['manufacturing.products', 'manufacturing.suppliers', 'manufacturing.orders', 'manufacturing.customers', 'manufacturing.order_items']","['manufacturing.products', 'manufacturing.suppliers', 'manufacturing.orders', 'manufacturing.customers', 'manufacturing.order_items']","['manufacturing.products', 'manufacturing.suppliers', 'manufacturing.orders', 'manufacturing.customers', 'manufacturing.order_items']"
130,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.price) AS total_price
FROM
    customers c
    CROSS JOIN orders o
    INNER JOIN order_products op ON o.order_id = op.order_id
    INNER JOIN products p ON op.product_id = p.product_id
    INNER JOIN categories cat ON p.category_id = cat.category_id
    INNER JOIN suppliers s ON p.supplier_id = s.supplier_id
    INNER JOIN (
        SELECT 
            o.order_id,
            COUNT(DISTINCT op.product_id) AS unique_products
        FROM
            orders o
            INNER JOIN order_products op ON o.order_id = op.order_id
        WHERE
            o.order_status = 'completed'
        GROUP BY
            o.order_id
        HAVING
            unique_products > 1
    ) subq ON o.order_id = subq.order_id
WHERE
    c.country = 'United States'
    AND s.country = 'China'
    AND cat.category_name = 'Electronics'
    AND p.price > 100
GROUP BY
    c.customer_id,
    o.order_id,
    p.product_id
HAVING
    total_quantity > 5
ORDER BY
    total_price DESC
LIMIT 10;",323,311,634,"['customers', 'orders', 'order_products', 'products', 'categories', 'suppliers']","['customers', 'orders', 'order_products', 'products', 'categories', 'suppliers']","['customers', 'orders', 'order_products', 'products', 'categories', 'suppliers']","['customers', 'orders', 'order_products', 'products', 'categories', 'suppliers']"
131,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT p.patient_id, p.patient_name, COUNT(*) AS num_visits
  FROM healthcare.patients p
  JOIN healthcare.visits v ON p.patient_id = v.patient_id
  WHERE v.visit_date >= '2021-01-01'
  GROUP BY p.patient_id, p.patient_name
  HAVING COUNT(*) > 5
),
cte2 AS (
  SELECT p.patient_id, p.patient_name, COUNT(*) AS num_prescriptions
  FROM healthcare.patients p
  JOIN healthcare.prescriptions pr ON p.patient_id = pr.patient_id
  WHERE pr.prescription_date >= '2021-01-01'
  GROUP BY p.patient_id, p.patient_name
  HAVING COUNT(*) > 3
),
cte3 AS (
  SELECT p.patient_id, p.patient_name, COUNT(*) AS num_tests
  FROM healthcare.patients p
  JOIN healthcare.tests t ON p.patient_id = t.patient_id
  WHERE t.test_date >= '2021-01-01'
  GROUP BY p.patient_id, p.patient_name
  HAVING COUNT(*) > 2
)
SELECT cte1.patient_id, cte1.patient_name, cte1.num_visits, cte2.num_prescriptions, cte3.num_tests
FROM cte1
JOIN cte2 ON cte1.patient_id = cte2.patient_id
JOIN cte3 ON cte1.patient_id = cte3.patient_id
ORDER BY cte1.num_visits DESC, cte2.num_prescriptions DESC, cte3.num_tests DESC
LIMIT 10;",327,338,665,"['healthcare.patients', 'healthcare.visits', 'healthcare.prescriptions', 'healthcare.tests']","['healthcare.patients', 'healthcare.visits', 'healthcare.prescriptions', 'healthcare.tests']","['healthcare.patients', 'healthcare.visits', 'healthcare.prescriptions', 'healthcare.tests']","['healthcare.patients', 'healthcare.visits', 'healthcare.prescriptions', 'healthcare.tests']"
132,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_name, ' - ', c.customer_id) AS customer_info,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    energy_company.customers c
  INNER JOIN 
    energy_company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
  GROUP BY 
    c.customer_name, c.customer_id
  HAVING 
    COUNT(DISTINCT o.order_id) > 5
),
cte2 AS (
  SELECT 
    p.product_name,
    SUM(op.quantity) AS total_quantity
  FROM 
    energy_company.products p
  LEFT JOIN 
    energy_company.order_products op ON p.product_id = op.product_id
  WHERE 
    p.category = 'Solar Panels'
  GROUP BY 
    p.product_name
  HAVING 
    SUM(op.quantity) > 100
),
cte3 AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.total_price,
    SUM(op.quantity * p.unit_price) AS total_revenue
  FROM 
    energy_company.orders o
  LEFT JOIN 
    energy_company.order_products op ON o.order_id = op.order_id
  INNER JOIN 
    energy_company.products p ON op.product_id = p.product_id
  WHERE 
    o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
  GROUP BY 
    o.order_id, o.order_date, o.total_price
  HAVING 
    SUM(op.quantity * p.unit_price) > 5000
),
cte4 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    energy_company.customers c
  LEFT JOIN 
    energy_company.orders o ON c.customer_id = o.customer_id
  WHERE 
    c.country = 'United States'
  GROUP BY 
    c.customer_id
  HAVING 
    COUNT(DISTINCT o.order_id) > 10
),
cte5 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    energy_company.customers c
  LEFT JOIN 
    energy_company.orders o ON c.customer_id = o.customer_id
  WHERE 
    c.country = 'Canada'
  GROUP BY 
    c.customer_id
  HAVING 
    COUNT(DISTINCT o.order_id) > 5
)
SELECT 
  cte1.customer_info,
  cte1.total_orders,
  cte2.product_name,
  cte2.total_quantity,
  DATE_FORMAT(cte3.order_date, '%Y-%m-%d') AS formatted_date,
  cte3.total_price,
  cte3.total_revenue,
  CASE 
    WHEN cte4.total_orders IS NULL THEN 'No'
    ELSE 'Yes'
  END AS has_us_orders,
  CASE 
    WHEN cte5.total_orders IS NULL THEN 'No'
    ELSE 'Yes'
  END AS has_canadian_orders
FROM 
  cte1
LEFT JOIN 
  cte2 ON 1 = 1
LEFT JOIN 
  cte3 ON cte1.total_orders = cte3.total_price
LEFT JOIN 
  cte4 ON cte1.customer_info = CONCAT(cte4.customer_id, ' - ', cte4.total_orders)
LEFT JOIN 
  cte5 ON cte1.customer_info = CONCAT(cte5.customer_id, ' - ', cte5.total_orders)
ORDER BY 
  cte1.total_orders DESC, cte2.total_quantity ASC, cte3.total_revenue DESC
LIMIT 100;",324,778,1102,"['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_products']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_products']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_products']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_products']"
133,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    o.order_id,
    o.order_date,
    o.total_price
  FROM 
    energy_company.customers AS c
  INNER JOIN 
    energy_company.orders AS o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
),
cte2 AS (
  SELECT 
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders
  FROM 
    cte1
  GROUP BY 
    customer_name
  HAVING 
    total_orders > 5
),
cte3 AS (
  SELECT 
    customer_name,
    SUM(total_price) AS total_sales
  FROM 
    cte1
  GROUP BY 
    customer_name
),
cte4 AS (
  SELECT 
    customer_name,
    COUNT(DISTINCT order_date) AS total_days
  FROM 
    cte1
  GROUP BY 
    customer_name
),
cte5 AS (
  SELECT 
    customer_name,
    AVG(total_price) AS avg_order_price
  FROM 
    cte1
  GROUP BY 
    customer_name
),
cte6 AS (
  SELECT 
    customer_name,
    DATE_FORMAT(order_date, '%Y-%m') AS order_month
  FROM 
    cte1
),
cte7 AS (
  SELECT 
    customer_name,
    COUNT(DISTINCT order_month) AS total_months
  FROM 
    cte6
  GROUP BY 
    customer_name
),
cte8 AS (
  SELECT 
    customer_name,
    MAX(total_price) AS max_order_price
  FROM 
    cte1
  GROUP BY 
    customer_name
),
cte9 AS (
  SELECT 
    customer_name,
    MIN(total_price) AS min_order_price
  FROM 
    cte1
  GROUP BY 
    customer_name
),
cte10 AS (
  SELECT 
    customer_name,
    UPPER(customer_name) AS uppercase_name
  FROM 
    cte1
),
cte11 AS (
  SELECT 
    customer_name,
    CONCAT('VIP - ', customer_name) AS vip_name
  FROM 
    cte1
  WHERE 
    total_price > 10000
),
cte12 AS (
  SELECT 
    customer_name,
    CASE 
      WHEN total_price > 5000 THEN 'High Value'
      WHEN total_price > 2000 THEN 'Medium Value'
      ELSE 'Low Value'
    END AS order_value_category
  FROM 
    cte1
),
cte13 AS (
  SELECT 
    customer_name,
    CASE 
      WHEN total_orders > 10 THEN 'Loyal Customer'
      WHEN total_orders > 5 THEN 'Regular Customer'
      ELSE 'New Customer'
    END AS customer_type
  FROM 
    cte2
),
cte14 AS (
  SELECT 
    customer_name,
    CASE 
      WHEN total_days > 30 THEN 'Frequent Buyer'
      WHEN total_days > 15 THEN 'Occasional Buyer'
      ELSE 'Infrequent Buyer'
    END AS buying_frequency
  FROM 
    cte4
)
SELECT 
  cte1.customer_name,
  cte1.order_id,
  cte1.order_date,
  cte1.total_price,
  cte2.total_orders,
  cte3.total_sales,
  cte4.total_days,
  cte5.avg_order_price,
  cte7.total_months,
  cte8.max_order_price,
  cte9.min_order_price,
  cte10.uppercase_name,
  cte11.vip_name,
  cte12.order_value_category,
  cte13.customer_type,
  cte14.buying_frequency
FROM 
  cte1
LEFT JOIN 
  cte2 ON cte1.customer_name = cte2.customer_name
LEFT JOIN 
  cte3 ON cte1.customer_name = cte3.customer_name
LEFT JOIN 
  cte4 ON cte1.customer_name = cte4.customer_name
LEFT JOIN 
  cte5 ON cte1.customer_name = cte5.customer_name
LEFT JOIN 
  cte7 ON cte1.customer_name = cte7.customer_name
LEFT JOIN 
  cte8 ON cte1.customer_name = cte8.customer_name
LEFT JOIN 
  cte9 ON cte1.customer_name = cte9.customer_name
LEFT JOIN 
  cte10 ON cte1.customer_name = cte10.customer_name
LEFT JOIN 
  cte11 ON cte1.customer_name = cte11.customer_name
LEFT JOIN 
  cte12 ON cte1.customer_name = cte12.customer_name
LEFT JOIN 
  cte13 ON cte1.customer_name = cte13.customer_name
LEFT JOIN 
  cte14 ON cte1.customer_name = cte14.customer_name;",321,1045,1366,"['energy_company.customers', 'energy_company.orders']","['energy_company.customers', 'energy_company.orders']","['energy_company.customers', 'energy_company.orders']","['energy_company.customers', 'energy_company.orders']"
134,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT property.id AS property_id,
         property.name AS property_name,
         property.address AS property_address,
         property.bedrooms AS property_bedrooms,
         property.bathrooms AS property_bathrooms,
         property.price AS property_price,
         agent.name AS agent_name,
         agent.email AS agent_email
  FROM real_estate.property
  JOIN real_estate.agent ON property.agent_id = agent.id
  WHERE property.status = 'available'
),
cte2 AS (
  SELECT property_id,
         COUNT(*) AS num_inquiries
  FROM real_estate.inquiry
  GROUP BY property_id
),
cte3 AS (
  SELECT property_id,
         AVG(rating) AS avg_rating
  FROM real_estate.review
  GROUP BY property_id
),
cte4 AS (
  SELECT property_id,
         COUNT(*) AS num_bookings
  FROM real_estate.booking
  GROUP BY property_id
),
cte5 AS (
  SELECT property_id,
         COUNT(*) AS num_visits
  FROM real_estate.visit
  GROUP BY property_id
),
cte6 AS (
  SELECT property_id,
         COUNT(*) AS num_contracts
  FROM real_estate.contract
  GROUP BY property_id
),
cte7 AS (
  SELECT property_id,
         COUNT(*) AS num_payments
  FROM real_estate.payment
  GROUP BY property_id
),
cte8 AS (
  SELECT property_id,
         SUM(amount) AS total_payments
  FROM real_estate.payment
  GROUP BY property_id
),
cte9 AS (
  SELECT property_id,
         COUNT(*) AS num_complaints
  FROM real_estate.complaint
  GROUP BY property_id
),
cte10 AS (
  SELECT property_id,
         COUNT(*) AS num_repairs
  FROM real_estate.repair
  GROUP BY property_id
),
cte11 AS (
  SELECT property_id,
         COUNT(*) AS num_inspections
  FROM real_estate.inspection
  GROUP BY property_id
),
cte12 AS (
  SELECT property_id,
         COUNT(*) AS num_appraisals
  FROM real_estate.appraisal
  GROUP BY property_id
),
cte13 AS (
  SELECT property_id,
         COUNT(*) AS num_listings
  FROM real_estate.listing
  GROUP BY property_id
),
cte14 AS (
  SELECT property_id,
         COUNT(*) AS num_contracts
  FROM real_estate.contract
  GROUP BY property_id
),
cte15 AS (
  SELECT property_id,
         COUNT(*) AS num_documents
  FROM real_estate.document
  GROUP BY property_id
),
cte16 AS (
  SELECT property_id,
         COUNT(*) AS num_photos
  FROM real_estate.photo
  GROUP BY property_id
),
cte17 AS (
  SELECT property_id,
         COUNT(*) AS num_videos
  FROM real_estate.video
  GROUP BY property_id
),
cte18 AS (
  SELECT property_id,
         COUNT(*) AS num_floorplans
  FROM real_estate.floorplan
  GROUP BY property_id
),
cte19 AS (
  SELECT property_id,
         COUNT(*) AS num_virtual_tours
  FROM real_estate.virtual_tour
  GROUP BY property_id
),
cte20 AS (
  SELECT property_id,
         COUNT(*) AS num_reviews
  FROM real_estate.review
  GROUP BY property_id
),
cte21 AS (
  SELECT property_id,
         COUNT(*) AS num_ratings
  FROM real_estate.rating
  GROUP BY property_id
),
cte22 AS (
  SELECT property_id,
         COUNT(*) AS num_likes
  FROM real_estate.like
  GROUP BY property_id
),
cte23 AS (
  SELECT property_id,
         COUNT(*) AS num_dislikes
  FROM real_estate.dislike
  GROUP BY property_id
),
cte24 AS (
  SELECT property_id,
         COUNT(*) AS num_favorites
  FROM real_estate.favorite
  GROUP BY property_id
),
cte25 AS (
  SELECT property_id,
         COUNT(*) AS num_shares
  FROM real_estate.share
  GROUP BY property_id
),
cte26 AS (
  SELECT property_id,
         COUNT(*) AS num_comments
  FROM real_estate.comment
  GROUP BY property_id
),
cte27 AS (
  SELECT property_id,
         COUNT(*) AS num_inquiries
  FROM real_estate.inquiry
  GROUP BY property_id
),
cte28 AS (
  SELECT property_id,
         COUNT(*) AS num_offers
  FROM real_estate.offer
  GROUP BY property_id
),
cte29 AS (
  SELECT property_id,
         COUNT(*) AS num_sales
  FROM real_estate.sale
  GROUP BY property_id
),
cte30 AS (
  SELECT property_id,
         COUNT(*) AS num_rentals
  FROM real_estate.rental
  GROUP BY property_id
),
cte31 AS (
  SELECT property_id,
         COUNT(*) AS num_leases
  FROM real_estate.lease
  GROUP BY property_id
),
cte32 AS (
  SELECT property_id,
         COUNT(*) AS num_tenants
  FROM real_estate.tenant
  GROUP BY property_id
),
cte33 AS (
  SELECT property_id,
         COUNT(*) AS num_owners
  FROM real_estate.owner
  GROUP BY property_id
),
cte34 AS (
  SELECT property_id,
         COUNT(*) AS num_agents
  FROM real_estate.agent
  GROUP BY property_id
),
cte35 AS (
  SELECT property_id,
         COUNT(*) AS num_managers
  FROM real_estate.manager
  GROUP BY property_id
),
cte36 AS (
  SELECT property_id,
         COUNT(*) AS num_investors
  FROM real_estate.investor
  GROUP BY property_id
),
cte37 AS (
  SELECT property_id,
         COUNT(*) AS num_lenders
  FROM real_estate.lender
  GROUP BY property_id
),
cte38 AS (
  SELECT property_id,
         COUNT(*) AS num_insurers
  FROM real_estate.insurer
  GROUP BY property_id
),
cte39 AS (
  SELECT property_id,
         COUNT(*) AS num_appraisers
  FROM real_estate.appraiser
  GROUP BY property_id
),
cte40 AS (
  SELECT property_id,
         COUNT(*) AS num_contractors
  FROM real_estate.contractor
  GROUP BY property_id
),
cte41 AS (
  SELECT property_id,
         COUNT(*) AS num_lawyers
  FROM real_estate.lawyer
  GROUP BY property_id
),
cte42 AS (
  SELECT property_id,
         COUNT(*) AS num_accountants
  FROM real_estate.accountant
  GROUP BY property_id
),
cte43 AS (
  SELECT property_id,
         COUNT(*) AS num_architects
  FROM real_estate.architect
  GROUP BY property_id
),
cte44 AS (
  SELECT property_id,
         COUNT(*) AS num_surveyors
  FROM real_estate.surveyor
  GROUP BY property_id
),
cte45 AS (
  SELECT property_id,
         COUNT(*) AS num_interior_designers
  FROM real_estate.interior_designer
  GROUP BY property_id
),
cte46 AS (
  SELECT property_id,
         COUNT(*) AS num_stagers
  FROM real_estate.stager
  GROUP BY property_id
),
cte47 AS (
  SELECT property_id,
         COUNT(*) AS num_movers
  FROM real_estate.mover
  GROUP BY property_id
),
cte48 AS (
  SELECT property_id,
         COUNT(*) AS num_cleaners
  FROM real_estate.cleaner
  GROUP BY property_id
),
cte49 AS (
  SELECT property_id,
         COUNT(*) AS num_gardeners
  FROM real_estate.gardener
  GROUP BY property_id
),
cte50 AS (
  SELECT property_id,
         COUNT(*) AS num_petsitters
  FROM real_estate.petsitter
  GROUP BY property_id
),
cte51 AS (
  SELECT property_id,
         COUNT(*) AS num_security
  FROM real_estate.security
  GROUP BY property_id
),
cte52 AS (
  SELECT property_id,
         COUNT(*) AS num_concierge
  FROM real_estate.concierge
  GROUP BY property_id
),
cte53 AS (
  SELECT property_id,
         COUNT(*) AS num_cleaning_services
  FROM real_estate.cleaning_service
  GROUP BY property_id
),
cte54 AS (
  SELECT property_id,
         COUNT(*) AS num_maintenance_services
  FROM real_estate.maintenance_service
  GROUP BY property_id
),
cte55 AS (
  SELECT property_id,
         COUNT(*) AS num_repair_services
  FROM real_estate.repair_service
  GROUP BY property_id
),
cte56 AS (
  SELECT property_id,
         COUNT(*) AS num_landscaping_services
  FROM real_estate.landscaping_service
  GROUP BY property_id
),
cte57 AS (
  SELECT property_id,
         COUNT(*) AS num_painting_services
  FROM real_estate.painting_service
  GROUP BY property_id
),
cte58 AS (
  SELECT property_id,
         COUNT(*) AS num_plumbing_services
  FROM real_estate.plumbing_service
  GROUP BY property_id
),
cte59 AS (
  SELECT property_id,
         COUNT(*) AS num_electrical_services
  FROM real_estate.electrical_service
  GROUP BY property_id
),
cte60 AS (
  SELECT property_id,
         COUNT(*) AS num_hvac_services
  FROM real_estate.hvac_service
  GROUP BY property_id
),
cte61 AS (
  SELECT property_id,
         COUNT(*) AS num_roofing_services
  FROM real_estate.roofing_service
  GROUP BY property_id
),
cte62 AS (
  SELECT property_id,
         COUNT(*) AS num_carpentry_services
  FROM real_estate.carpentry_service
  GROUP BY property_id
),
cte63 AS (
  SELECT property_id,
         COUNT(*) AS num_flooring_services
  FROM real_estate.flooring_service
  GROUP BY property_id
),
cte64 AS (
  SELECT property_id,
         COUNT(*) AS num_appliance_services
  FROM real_estate.appliance_service
  GROUP BY property_id
),
cte65 AS (
  SELECT property_id,
         COUNT(*) AS num_window_services
  FROM real_estate.window_service
  GROUP BY property_id
),
cte66 AS (
  SELECT property_id,
         COUNT(*) AS num_door_services
  FROM real_estate.door_service
  GROUP BY property_id
),
cte67 AS (
  SELECT property_id,
         COUNT(*) AS num_locksmith_services
  FROM real_estate.locksmith_service
  GROUP BY property_id
),
cte68 AS (
  SELECT property_id,
         COUNT(*) AS num_landscapers
  FROM real_estate.landscaper
  GROUP BY property_id
),
cte69 AS (
  SELECT property_id,
         COUNT(*) AS num_pavers
  FROM real_estate.paver
  GROUP BY property_id
),
cte70 AS (
  SELECT property_id,
         COUNT(*) AS num_fence_services
  FROM real_estate.fence_service
  GROUP BY property_id
),
cte71 AS (
  SELECT property_id,
         COUNT(*) AS num_pool_services
  FROM real_estate.pool_service
  GROUP BY property_id
),
cte72 AS (
  SELECT property_id,
         COUNT(*) AS num_garage_services
  FROM real_estate.garage_service
  GROUP BY property_id
),
cte73 AS (
  SELECT property_id,
         COUNT(*) AS num_home_services
  FROM real_estate.home_service
  GROUP BY property_id
),
cte74 AS (
  SELECT property_id,
         COUNT(*) AS num_pest_control_services
  FROM real_estate.pest_control_service
  GROUP BY property_id
),
cte75 AS (
  SELECT property_id,
         COUNT(*) AS num_security_services
  FROM real_estate.security_service
  GROUP BY property_id
),
cte76 AS (
  SELECT property_id,
         COUNT(*) AS num_smart_home_services
  FROM real_estate.smart_home_service
  GROUP BY property_id
),
cte77 AS (
  SELECT property_id,
         COUNT(*) AS num_interior_design_services
  FROM real_estate.interior_design_service
  GROUP BY property_id
),
cte78 AS (
  SELECT property_id,
         COUNT(*) AS num_staging_services
  FROM real_estate.staging_service
  GROUP BY property_id
),
cte79 AS (
  SELECT property_id,
         COUNT(*) AS num_moving_services
  FROM real_estate.moving_service
  GROUP BY property_id
),
cte80 AS (
  SELECT property_id,
         COUNT(*) AS num_cleaning_services
  FROM real_estate.cleaning_service
  GROUP BY property_id
),
cte81 AS (
  SELECT property_id,
         COUNT(*) AS num_gardening_services
  FROM real_estate.gardening_service
  GROUP BY property_id
),
cte82 AS (
  SELECT property_id,
         COUNT(*) AS num_petsitting_services
  FROM real_estate.petsitting_service
  GROUP BY property_id
),
cte83 AS (
  SELECT property_id,
         COUNT(*) AS num_property_management_services
  FROM real_estate.property_management_service
  GROUP BY property_id
),
cte84 AS (
  SELECT property_id,
         COUNT(*) AS num_construction_services
  FROM real_estate.construction_service
  GROUP BY property_id
),
cte85 AS (
  SELECT property_id,
         COUNT(*) AS num_renovation_services
  FROM real_estate.renovation_service
  GROUP BY property_id
),
cte86 AS (
  SELECT property_id,
         COUNT(*) AS num_demolition_services
  FROM real_estate.demolition_service
  GROUP BY property_id
),
cte87 AS (
  SELECT property_id,
         COUNT(*) AS num_architectural_services
  FROM real_estate.architectural_service
  GROUP BY property_id
),
cte88 AS (
  SELECT property_id,
         COUNT(*) AS num_surveying_services
  FROM real_estate.surveying_service
  GROUP BY property_id
),
cte89 AS (
  SELECT property_id,
         COUNT(*) AS num_interior_design_services
  FROM real_estate.interior_design_service
  GROUP BY property_id
),
cte90 AS (
  SELECT property_id,
         COUNT(*) AS num_property_styling_services
  FROM real_estate.property_styling_service
  GROUP BY property_id
),
cte91 AS (
  SELECT property_id,
         COUNT(*) AS num_property_staging_services
  FROM real_estate.property_staging_service
  GROUP BY property_id
),
cte92 AS (
  SELECT property_id,
         COUNT(*) AS num_property_cleaning_services
  FROM real_estate.property_cleaning_service
  GROUP BY property_id
),
cte93 AS (
  SELECT property_id,
         COUNT(*) AS num_property_maintenance_services
  FROM real_estate.property_maintenance_service
  GROUP BY property_id
),
cte94 AS (
  SELECT property_id,
         COUNT(*) AS num_property_repair_services
  FROM real_estate.property_repair_service
  GROUP BY property_id
),
cte95 AS (
  SELECT property_id,
         COUNT(*) AS num_property_landscaping_services
  FROM real_estate.property_landscaping_service
  GROUP BY property_id
),
cte96 AS (
  SELECT property_id,
         COUNT(*) AS num_property_painting_services
  FROM real_estate.property_painting_service
  GROUP BY property_id
),
cte97 AS (
  SELECT property_id,
         COUNT(*) AS num_property_plumbing_services
  FROM real_estate.property_plumbing_service
  GROUP BY property_id
),
cte98 AS (
  SELECT property_id,
         COUNT(*) AS num_property_electrical_services
  FROM real_estate.property_electrical_service
  GROUP BY property_id
),
cte99 AS (
  SELECT property_id,
         COUNT(*) AS num_property_hvac_services
  FROM real_estate.property_hvac_service
  GROUP BY property_id
),
cte100 AS (
  SELECT property_id,
         COUNT(*) AS num_property_roofing_services
  FROM real_estate.property_roofing_service
  GROUP BY property_id
),
cte101 AS (
  SELECT property_id,
         COUNT(*) AS num_property_carpentry_services
  FROM real_estate.property_carpentry_service
  GROUP BY property_id
),
cte102 AS (
  SELECT property_id,
         COUNT(*) AS num_property_flooring_services
  FROM real_estate.property_flooring_service
  GROUP BY property_id
),
cte103 AS (
  SELECT property_id,
         COUNT(*) AS num_property_appliance_services
  FROM real_estate.property_appliance_service
  GROUP BY property_id
),
cte104 AS (
  SELECT property_id,
         COUNT(*) AS num_property_window_services
  FROM real_estate.property_window_service
  GROUP BY property_id
),
cte105 AS (
  SELECT property_id,
         COUNT(*) AS num_property_door_services
  FROM real_estate.property_door_service
  GROUP BY property_id
),
cte106 AS (
  SELECT property_id,
         COUNT(*) AS num_property_locksmith_services
  FROM real_estate.property_locksmith_service
  GROUP BY property_id
),
cte107 AS (
  SELECT property_id,
         COUNT(*) AS num_property_landscapers
  FROM real_estate.property_landscaper
  GROUP BY property_id
),
cte108 AS (
  SELECT property_id,
         COUNT(*) AS num_property_pavers
  FROM real",321,3777,4098,"[""real_estate.property"", ""real_estate.agent"", ""real_estate.inquiry"", ""real_estate.review"", ""real_estate.booking"", ""real_estate.visit"", ""real_estate.contract"", ""real_estate.payment"", ""real_estate.complaint"", ""real_estate.repair"", ""real_estate.inspection"", ""real_estate.appraisal"", ""real_estate.listing"", ""real_estate.document"", ""real_estate.photo"", ""real_estate.video"", ""real_estate.floorplan"", ""real_estate.virtual_tour"", ""real_estate.rating"", ""real_estate.like"", ""real_estate.dislike"", ""real_estate.favorite"", ""real_estate.share"", ""real_estate.comment"", ""real_estate.offer"", ""real_estate.sale"", ""real_estate.rental"", ""real_estate.lease"", ""real_estate.tenant"", ""real_estate.owner"", ""real_estate.manager","[""real_estate.property"", ""real_estate.agent"", ""real_estate.inquiry"", ""real_estate.review"", ""real_estate.booking"", ""real_estate.visit"", ""real_estate.contract"", ""real_estate.payment"", ""real_estate.complaint"", ""real_estate.repair"", ""real_estate.inspection"", ""real_estate.appraisal"", ""real_estate.listing"", ""real_estate.document"", ""real_estate.photo"", ""real_estate.video"", ""real_estate.floorplan"", ""real_estate.virtual_tour"", ""real_estate.rating"", ""real_estate.like"", ""real_estate.dislike"", ""real_estate.favorite"", ""real_estate.share"", ""real_estate.comment"", ""real_estate.offer"", ""real_estate.sale"", ""real_estate.rental"", ""real_estate.lease"", ""real_estate.tenant"", ""real_estate.owner"", ""real_estate.manager","[""real_estate.property"", ""real_estate.agent"", ""real_estate.inquiry"", ""real_estate.review"", ""real_estate.booking"", ""real_estate.visit"", ""real_estate.contract"", ""real_estate.payment"", ""real_estate.complaint"", ""real_estate.repair"", ""real_estate.inspection"", ""real_estate.appraisal"", ""real_estate.listing"", ""real_estate.document"", ""real_estate.photo"", ""real_estate.video"", ""real_estate.floorplan"", ""real_estate.virtual_tour"", ""real_estate.rating"", ""real_estate.like"", ""real_estate.dislike"", ""real_estate.favorite"", ""real_estate.share"", ""real_estate.comment"", ""real_estate.offer"", ""real_estate.sale"", ""real_estate.rental"", ""real_estate.lease"", ""real_estate.tenant"", ""real_estate.owner"", ""real_estate.manager","[""real_estate.property"", ""real_estate.agent"", ""real_estate.inquiry"", ""real_estate.review"", ""real_estate.booking"", ""real_estate.visit"", ""real_estate.contract"", ""real_estate.payment"", ""real_estate.complaint"", ""real_estate.repair"", ""real_estate.inspection"", ""real_estate.appraisal"", ""real_estate.listing"", ""real_estate.document"", ""real_estate.photo"", ""real_estate.video"", ""real_estate.floorplan"", ""real_estate.virtual_tour"", ""real_estate.rating"", ""real_estate.like"", ""real_estate.dislike"", ""real_estate.favorite"", ""real_estate.share"", ""real_estate.comment"", ""real_estate.offer"", ""real_estate.sale"", ""real_estate.rental"", ""real_estate.lease"", ""real_estate.tenant"", ""real_estate.owner"", ""real_estate.manager"
135,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    a.balance,
    t.transaction_date,
    t.transaction_type,
    t.amount
FROM 
    bank.customers AS c
JOIN 
    bank.accounts AS a ON c.customer_id = a.customer_id
JOIN 
    bank.transactions AS t ON a.account_id = t.account_id
JOIN 
    bank.branches AS b ON a.branch_id = b.branch_id
JOIN 
    bank.employees AS e ON b.manager_id = e.employee_id
WHERE 
    c.age >= 18
    AND t.transaction_date >= '2021-01-01'
    AND t.transaction_date <= '2021-12-31'
    AND e.department = 'Operations'
GROUP BY 
    c.customer_id,
    a.account_id,
    t.transaction_id
HAVING 
    SUM(t.amount) > 1000
ORDER BY 
    c.last_name ASC,
    c.first_name ASC,
    t.transaction_date DESC
LIMIT 100
CROSS JOIN 
    (SELECT 
        COUNT(*) AS total_customers,
        AVG(a.balance) AS average_balance
    FROM 
        bank.customers AS c
    JOIN 
        bank.accounts AS a ON c.customer_id = a.customer_id
    WHERE 
        c.age >= 18) AS stats;",318,282,600,"['bank.customers', 'bank.accounts', 'bank.transactions', 'bank.branches', 'bank.employees']","['bank.customers', 'bank.accounts', 'bank.transactions', 'bank.branches', 'bank.employees']","['bank.customers', 'bank.accounts', 'bank.transactions', 'bank.branches', 'bank.employees']","['bank.customers', 'bank.accounts', 'bank.transactions', 'bank.branches', 'bank.employees']"
136,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an insurance company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_insured_customers AS (
    SELECT 
        c.customer_id,
        c.first_name,
        c.last_name,
        c.date_of_birth,
        c.address,
        c.city,
        c.state,
        c.zip_code,
        p.policy_id,
        p.policy_type,
        p.policy_start_date,
        p.policy_end_date,
        p.premium_amount
    FROM 
        customers c
    INNER JOIN 
        policies p ON c.customer_id = p.customer_id
    WHERE 
        p.policy_start_date <= CURDATE()
        AND p.policy_end_date >= CURDATE()
),
cte_claimed_policies AS (
    SELECT 
        p.policy_id,
        p.claim_id,
        p.claim_date,
        p.claim_amount,
        p.claim_status
    FROM 
        policies p
    INNER JOIN 
        claims c ON p.policy_id = c.policy_id
    WHERE 
        c.claim_date BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 YEAR) AND CURDATE()
),
cte_total_premiums AS (
    SELECT 
        customer_id,
        SUM(premium_amount) AS total_premiums
    FROM 
        policies
    WHERE 
        policy_start_date <= CURDATE()
        AND policy_end_date >= CURDATE()
    GROUP BY 
        customer_id
),
cte_total_claims AS (
    SELECT 
        customer_id,
        COUNT(claim_id) AS total_claims
    FROM 
        cte_claimed_policies
    GROUP BY 
        customer_id
),
cte_average_claim_amount AS (
    SELECT 
        customer_id,
        AVG(claim_amount) AS average_claim_amount
    FROM 
        cte_claimed_policies
    GROUP BY 
        customer_id
)
SELECT 
    ic.customer_id,
    ic.first_name,
    ic.last_name,
    ic.date_of_birth,
    ic.address,
    ic.city,
    ic.state,
    ic.zip_code,
    ic.policy_id,
    ic.policy_type,
    ic.policy_start_date,
    ic.policy_end_date,
    ic.premium_amount,
    cp.claim_id,
    cp.claim_date,
    cp.claim_amount,
    cp.claim_status,
    tp.total_premiums,
    tc.total_claims,
    aca.average_claim_amount
FROM 
    cte_insured_customers ic
LEFT JOIN 
    cte_claimed_policies cp ON ic.policy_id = cp.policy_id
LEFT JOIN 
    cte_total_premiums tp ON ic.customer_id = tp.customer_id
LEFT JOIN 
    cte_total_claims tc ON ic.customer_id = tc.customer_id
LEFT JOIN 
    cte_average_claim_amount aca ON ic.customer_id = aca.customer_id
WHERE 
    ic.state = 'California'
    AND ic.zip_code LIKE '9%'
    AND tp.total_premiums > 10000
    AND tc.total_claims > 5
GROUP BY 
    ic.customer_id,
    ic.policy_id,
    cp.claim_id,
    tp.total_premiums,
    tc.total_claims,
    aca.average_claim_amount
HAVING 
    SUM(cp.claim_amount) > 5000
ORDER BY 
    ic.customer_id ASC,
    ic.policy_id ASC,
    cp.claim_id ASC;",316,683,999,"['customers', 'policies', 'claims']","['customers', 'policies', 'claims']","['customers', 'policies', 'claims']","['customers', 'policies', 'claims']"
137,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_name, ' - ', c.customer_id) AS customer_info,
    COUNT(o.order_id) AS total_orders
  FROM 
    energy_company.customers c
  JOIN 
    energy_company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
  GROUP BY 
    c.customer_name, c.customer_id
  HAVING 
    COUNT(o.order_id) > 5
),
cte2 AS (
  SELECT 
    p.product_name,
    SUM(od.quantity) AS total_quantity
  FROM 
    energy_company.products p
  JOIN 
    energy_company.order_details od ON p.product_id = od.product_id
  WHERE 
    p.category = 'Renewable Energy'
  GROUP BY 
    p.product_name
),
cte3 AS (
  SELECT 
    o.order_id,
    o.order_date,
    SUM(od.quantity * p.price) AS total_revenue
  FROM 
    energy_company.orders o
  JOIN 
    energy_company.order_details od ON o.order_id = od.order_id
  JOIN 
    energy_company.products p ON od.product_id = p.product_id
  WHERE 
    o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
  GROUP BY 
    o.order_id, o.order_date
),
cte4 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_unique_orders
  FROM 
    energy_company.customers c
  JOIN 
    energy_company.orders o ON c.customer_id = o.customer_id
  WHERE 
    c.country = 'United States'
  GROUP BY 
    c.customer_id
),
cte5 AS (
  SELECT 
    c.customer_id,
    SUM(p.price * od.quantity) AS total_spending
  FROM 
    energy_company.customers c
  JOIN 
    energy_company.orders o ON c.customer_id = o.customer_id
  JOIN 
    energy_company.order_details od ON o.order_id = od.order_id
  JOIN 
    energy_company.products p ON od.product_id = p.product_id
  WHERE 
    c.country = 'Canada'
  GROUP BY 
    c.customer_id
)
SELECT 
  cte1.customer_info,
  cte1.total_orders,
  cte2.product_name,
  cte2.total_quantity,
  DATE_FORMAT(cte3.order_date, '%Y-%m-%d') AS formatted_date,
  cte3.total_revenue,
  cte4.total_unique_orders,
  cte5.total_spending
FROM 
  cte1
JOIN 
  cte2 ON cte1.total_orders = cte2.total_quantity
JOIN 
  cte3 ON cte1.total_orders = cte3.total_revenue
JOIN 
  cte4 ON cte1.customer_info = CONCAT(cte4.customer_id, ' - ', cte4.total_unique_orders)
JOIN 
  cte5 ON cte1.customer_info = CONCAT(cte5.customer_id, ' - ', cte5.total_spending)
ORDER BY 
  cte1.total_orders DESC, cte3.total_revenue ASC
LIMIT 10;",321,679,1000,"['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_details']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_details']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_details']","['energy_company.customers', 'energy_company.orders', 'energy_company.products', 'energy_company.order_details']"
138,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_enrollment AS (
    SELECT
        student_id,
        COUNT(DISTINCT course_id) AS num_courses_enrolled
    FROM
        <database>.<schema>.enrollment
    GROUP BY
        student_id
    HAVING
        COUNT(DISTINCT course_id) >= 3
),
cte_average_grade AS (
    SELECT
        student_id,
        AVG(grade) AS average_grade
    FROM
        <schema>.<table>
    WHERE
        grade IS NOT NULL
    GROUP BY
        student_id
),
cte_top_students AS (
    SELECT
        student_id,
        average_grade
    FROM
        cte_average_grade
    WHERE
        average_grade >= 90
),
cte_student_rank AS (
    SELECT
        student_id,
        ROW_NUMBER() OVER (ORDER BY average_grade DESC) AS rank
    FROM
        cte_average_grade
),
cte_course_rank AS (
    SELECT
        course_id,
        ROW_NUMBER() OVER (ORDER BY COUNT(student_id) DESC) AS rank
    FROM
        <table>
    GROUP BY
        course_id
),
cte_course_enrollment AS (
    SELECT
        course_id,
        COUNT(DISTINCT student_id) AS num_students_enrolled
    FROM
        <database>.<schema>.enrollment
    GROUP BY
        course_id
),
cte_course_stats AS (
    SELECT
        course_id,
        num_students_enrolled,
        rank
    FROM
        cte_course_enrollment
    JOIN
        cte_course_rank USING (course_id)
),
cte_student_course_stats AS (
    SELECT
        student_id,
        course_id,
        grade,
        ROW_NUMBER() OVER (PARTITION BY student_id ORDER BY grade DESC) AS rank
    FROM
        <table>
    WHERE
        grade IS NOT NULL
),
cte_student_course_rank AS (
    SELECT
        student_id,
        course_id,
        rank
    FROM
        cte_student_course_stats
    WHERE
        rank <= 3
),
cte_student_course_info AS (
    SELECT
        student_id,
        course_id,
        grade,
        rank,
        num_students_enrolled,
        rank AS course_rank
    FROM
        cte_student_course_rank
    JOIN
        cte_course_stats USING (course_id)
),
cte_student_info AS (
    SELECT
        student_id,
        num_courses_enrolled,
        average_grade,
        rank AS student_rank
    FROM
        cte_enrollment
    JOIN
        cte_student_rank USING (student_id)
)
SELECT
    s.student_id,
    s.num_courses_enrolled,
    s.average_grade,
    s.student_rank,
    sc.course_id,
    sc.grade,
    sc.rank AS course_rank,
    sc.num_students_enrolled
FROM
    cte_student_info s
JOIN
    cte_student_course_info sc USING (student_id)
JOIN
    cte_top_students ts USING (student_id)
WHERE
    s.student_rank <= 10
    AND sc.course_rank <= 5
ORDER BY
    s.student_rank,
    sc.course_rank",313,657,970,"['<database>.<schema>.enrollment', '<schema>.<table>', '<table>', '<database>.<schema>.enrollment']","['<database>.<schema>.enrollment', '<schema>.<table>', '<table>', '<database>.<schema>.enrollment']","['<database>.<schema>.enrollment', '<schema>.<table>', '<table>', '<database>.<schema>.enrollment']","['<database>.<schema>.enrollment', '<schema>.<table>', '<table>', '<database>.<schema>.enrollment']"
139,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity) AS total_quantity_sold
    FROM
        pharmacy.sales s
    INNER JOIN
        pharmacy.products p ON s.product_id = p.product_id
    WHERE
        s.sale_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_quantity_sold > 100
),
cte2 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity * p.unit_price) AS total_revenue
    FROM
        pharmacy.sales s
    INNER JOIN
        pharmacy.products p ON s.product_id = p.product_id
    WHERE
        s.sale_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_revenue > 5000
),
cte3 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        COUNT(DISTINCT s.customer_id) AS unique_customers
    FROM
        pharmacy.sales s
    INNER JOIN
        pharmacy.products p ON s.product_id = p.product_id
    WHERE
        s.sale_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        unique_customers > 50
)
SELECT 
    cte1.product_id,
    cte1.product_name,
    cte1.product_category,
    cte1.total_quantity_sold,
    cte2.total_revenue,
    cte3.unique_customers,
    CONCAT('Category: ', UPPER(cte1.product_category)) AS category_label,
    DATE_FORMAT(NOW(), '%Y-%m-%d') AS current_date
FROM
    cte1
LEFT JOIN
    cte2 ON cte1.product_id = cte2.product_id
LEFT JOIN
    cte3 ON cte1.product_id = cte3.product_id
ORDER BY
    cte1.total_quantity_sold DESC,
    cte2.total_revenue DESC,
    cte3.unique_customers DESC
LIMIT 10;",316,490,806,"['pharmacy.sales', 'pharmacy.products']","['pharmacy.sales', 'pharmacy.products']","['pharmacy.sales', 'pharmacy.products']","['pharmacy.sales', 'pharmacy.products']"
140,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_articles AS (
  SELECT a.article_id, a.title, a.author, a.publish_date, a.category_id, c.category_name
  FROM articles a
  JOIN categories c ON a.category_id = c.category_id
  WHERE a.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)
),
cte_top_articles AS (
  SELECT article_id, title, author, publish_date, category_id, category_name
  FROM cte_articles
  ORDER BY views DESC
  LIMIT 10
),
cte_comments AS (
  SELECT article_id, COUNT(*) AS total_comments
  FROM comments
  GROUP BY article_id
),
cte_avg_rating AS (
  SELECT article_id, AVG(rating) AS avg_rating
  FROM ratings
  GROUP BY article_id
),
cte_author_stats AS (
  SELECT a.author, COUNT(DISTINCT a.article_id) AS total_articles, COUNT(DISTINCT c.comment_id) AS total_comments
  FROM articles a
  LEFT JOIN comments c ON a.article_id = c.article_id
  GROUP BY a.author
),
cte_category_stats AS (
  SELECT c.category_name, COUNT(DISTINCT a.article_id) AS total_articles, SUM(r.total_comments) AS total_comments
  FROM categories c
  LEFT JOIN cte_articles a ON c.category_id = a.category_id
  LEFT JOIN cte_comments r ON a.article_id = r.article_id
  GROUP BY c.category_name
),
cte_popular_authors AS (
  SELECT author, total_articles, total_comments
  FROM cte_author_stats
  WHERE total_articles >= 5
  ORDER BY total_comments DESC
  LIMIT 5
),
cte_popular_categories AS (
  SELECT category_name, total_articles, total_comments
  FROM cte_category_stats
  WHERE total_articles >= 10
  ORDER BY total_articles DESC
  LIMIT 5
)
SELECT ta.title, ta.author, ta.publish_date, ta.category_name, ta.total_comments, ar.avg_rating
FROM cte_top_articles ta
JOIN cte_avg_rating ar ON ta.article_id = ar.article_id
LEFT JOIN cte_comments c ON ta.article_id = c.article_id
WHERE ta.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)
  AND ta.total_comments >= 10
  AND ar.avg_rating >= 4.5
  AND ta.author IN (
    SELECT author
    FROM cte_popular_authors
  )
  AND ta.category_name IN (
    SELECT category_name
    FROM cte_popular_categories
  )
ORDER BY ta.publish_date DESC, ta.total_comments DESC
LIMIT 20;",319,551,870,"['articles', 'categories', 'comments', 'ratings']","['articles', 'categories', 'comments', 'ratings']","['articles', 'categories', 'comments', 'ratings']","['articles', 'categories', 'comments', 'ratings']"
141,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for an insurance company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ' ', a.zip_code) AS customer_address,
    p.policy_number,
    p.policy_type,
    p.policy_start_date,
    p.policy_end_date,
    SUM(cl.claim_amount) AS total_claim_amount,
    COUNT(cl.claim_number) AS total_claims
FROM 
    insurance.customers AS c
JOIN 
    insurance.policies AS p ON c.customer_id = p.customer_id
JOIN 
    insurance.claims AS cl ON p.policy_number = cl.policy_number
JOIN 
    insurance.addresses AS a ON c.address_id = a.address_id
WHERE 
    p.policy_start_date >= '2021-01-01' AND p.policy_end_date <= '2021-12-31'
GROUP BY 
    c.customer_id, p.policy_number
HAVING 
    total_claim_amount > 10000
ORDER BY 
    total_claim_amount DESC, total_claims ASC;",316,217,533,"['insurance.customers', 'insurance.policies', 'insurance.claims', 'insurance.addresses']","['insurance.customers', 'insurance.policies', 'insurance.claims', 'insurance.addresses']","['insurance.customers', 'insurance.policies', 'insurance.claims', 'insurance.addresses']","['insurance.customers', 'insurance.policies', 'insurance.claims', 'insurance.addresses']"
142,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.unit_price,
    oi.quantity,
    oi.quantity * p.unit_price AS total_price
FROM 
    sales.customers c
JOIN 
    sales.orders o ON c.customer_id = o.customer_id
JOIN 
    sales.order_items oi ON o.order_id = oi.order_id
JOIN 
    inventory.products p ON oi.product_id = p.product_id
JOIN 
    inventory.suppliers s ON p.supplier_id = s.supplier_id
JOIN 
    finance.payments pay ON o.order_id = pay.order_id
WHERE 
    c.city = 'New York'
    AND s.country = 'USA'
    AND pay.payment_status = 'completed'
    AND oi.quantity > 0
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id
HAVING 
    COUNT(DISTINCT oi.product_id) > 1
ORDER BY 
    customer_name ASC,
    formatted_order_date DESC,
    total_price DESC
LIMIT 100;",321,247,568,"['sales.customers', 'sales.orders', 'sales.order_items', 'inventory.products', 'inventory.suppliers', 'finance.payments']","['sales.customers', 'sales.orders', 'sales.order_items', 'inventory.products', 'inventory.suppliers', 'finance.payments']","['sales.customers', 'sales.orders', 'sales.order_items', 'inventory.products', 'inventory.suppliers', 'finance.payments']","['sales.customers', 'sales.orders', 'sales.order_items', 'inventory.products', 'inventory.suppliers', 'finance.payments']"
143,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_sales AS (
  SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    p.product_name,
    p.unit_price
  FROM
    sales.orders o
  JOIN
    sales.customers c ON o.customer_id = c.customer_id
  JOIN
    sales.order_items oi ON o.order_id = oi.order_id
  JOIN
    sales.products p ON oi.product_id = p.product_id
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

cte_top_customers AS (
  SELECT
    customer_id,
    customer_name,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_spent
  FROM
    cte_sales
  GROUP BY
    customer_id,
    customer_name
  HAVING
    COUNT(DISTINCT order_id) >= 5
),

cte_top_products AS (
  SELECT
    product_id,
    product_name,
    SUM(unit_price) AS total_revenue
  FROM
    cte_sales
  GROUP BY
    product_id,
    product_name
  HAVING
    SUM(unit_price) >= 10000
),

cte_monthly_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_revenue
  FROM
    cte_sales
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m')
),

cte_sales_summary AS (
  SELECT
    '2021' AS year,
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_price) AS total_revenue
  FROM
    cte_sales
),

cte_sales_growth AS (
  SELECT
    s1.year,
    s1.total_revenue AS current_year_revenue,
    s2.total_revenue AS previous_year_revenue,
    (s1.total_revenue - s2.total_revenue) / s2.total_revenue * 100 AS revenue_growth
  FROM
    cte_sales_summary s1
  JOIN
    cte_sales_summary s2 ON s1.year = CAST(s2.year AS INT) - 1
),

cte_top_customers_growth AS (
  SELECT
    tc.customer_id,
    tc.customer_name,
    tc.total_orders AS current_year_orders,
    tc.total_spent AS current_year_spent,
    tc.total_orders - tc_previous.total_orders AS order_growth,
    tc.total_spent - tc_previous.total_spent AS spent_growth
  FROM
    cte_top_customers tc
  JOIN
    cte_top_customers tc_previous ON tc.customer_id = tc_previous.customer_id
),

cte_top_products_growth AS (
  SELECT
    tp.product_id,
    tp.product_name,
    tp.total_revenue AS current_year_revenue,
    tp.total_revenue - tp_previous.total_revenue AS revenue_growth
  FROM
    cte_top_products tp
  JOIN
    cte_top_products tp_previous ON tp.product_id = tp_previous.product_id
)

SELECT
  c.customer_id,
  c.customer_name,
  c.total_orders,
  c.total_spent,
  c.order_growth,
  c.spent_growth,
  p.product_id,
  p.product_name,
  p.total_revenue,
  p.revenue_growth,
  ms.month,
  ms.total_orders AS monthly_orders,
  ms.total_revenue AS monthly_revenue,
  sg.year,
  sg.current_year_revenue,
  sg.previous_year_revenue,
  sg.revenue_growth
FROM
  cte_top_customers_growth c
JOIN
  cte_top_products_growth p ON c.customer_id = p.product_id
JOIN
  cte_monthly_sales ms ON c.customer_id = ms.month
JOIN
  cte_sales_growth sg ON c.customer_id = sg.year
ORDER BY
  c.total_spent DESC,
  p.total_revenue DESC,
  ms.month ASC,
  sg.year ASC
LIMIT 100;",322,867,1189,"['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']","['sales.orders', 'sales.customers', 'sales.order_items', 'sales.products']"
144,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an entertainment company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
        o.order_id,
        o.order_date,
        o.total_price
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    WHERE 
        o.order_date >= '2021-01-01'
),
cte2 AS (
    SELECT 
        p.product_name,
        p.product_category,
        oi.order_id,
        oi.quantity,
        oi.unit_price
    FROM 
        products p
    INNER JOIN 
        order_items oi ON p.product_id = oi.product_id
),
cte3 AS (
    SELECT 
        cte1.customer_name,
        cte1.order_id,
        cte1.order_date,
        cte1.total_price,
        cte2.product_name,
        cte2.product_category,
        cte2.quantity,
        cte2.unit_price,
        cte2.quantity * cte2.unit_price AS subtotal
    FROM 
        cte1
    LEFT JOIN 
        cte2 ON cte1.order_id = cte2.order_id
),
cte4 AS (
    SELECT 
        cte3.customer_name,
        cte3.order_id,
        cte3.order_date,
        cte3.total_price,
        cte3.product_category,
        SUM(cte3.subtotal) AS category_total
    FROM 
        cte3
    GROUP BY 
        cte3.customer_name,
        cte3.order_id,
        cte3.order_date,
        cte3.total_price,
        cte3.product_category
),
cte5 AS (
    SELECT 
        cte4.customer_name,
        cte4.order_id,
        cte4.order_date,
        cte4.total_price,
        cte4.product_category,
        cte4.category_total,
        MAX(cte4.category_total) OVER (PARTITION BY cte4.customer_name) AS max_category_total
    FROM 
        cte4
),
cte6 AS (
    SELECT 
        cte5.customer_name,
        cte5.order_id,
        cte5.order_date,
        cte5.total_price,
        cte5.product_category,
        cte5.category_total,
        cte5.max_category_total,
        CASE 
            WHEN cte5.category_total = cte5.max_category_total THEN 'Yes'
            ELSE 'No'
        END AS is_highest_category_total
    FROM 
        cte5
),
cte7 AS (
    SELECT 
        cte6.customer_name,
        cte6.order_id,
        cte6.order_date,
        cte6.total_price,
        cte6.product_category,
        cte6.category_total,
        cte6.max_category_total,
        cte6.is_highest_category_total,
        ROW_NUMBER() OVER (PARTITION BY cte6.customer_name ORDER BY cte6.order_date DESC) AS rn
    FROM 
        cte6
),
cte8 AS (
    SELECT 
        cte7.customer_name,
        cte7.order_id,
        cte7.order_date,
        cte7.total_price,
        cte7.product_category,
        cte7.category_total,
        cte7.max_category_total,
        cte7.is_highest_category_total
    FROM 
        cte7
    WHERE 
        cte7.rn = 1
)
SELECT 
    cte8.customer_name,
    cte8.order_id,
    DATE_FORMAT(cte8.order_date, '%Y-%m-%d') AS formatted_order_date,
    cte8.total_price,
    cte8.product_category,
    cte8.category_total,
    cte8.max_category_total,
    cte8.is_highest_category_total
FROM 
    cte8
WHERE 
    cte8.total_price >= 1000
HAVING 
    cte8.category_total > 500
ORDER BY 
    cte8.customer_name ASC,
    cte8.order_date DESC;",316,855,1171,"['customers', 'orders', 'products', 'order_items']","['customers', 'orders', 'products', 'order_items']","['customers', 'orders', 'products', 'order_items']","['customers', 'orders', 'products', 'order_items']"
145,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT p.patient_id, p.patient_name, COUNT(DISTINCT a.appointment_id) AS num_appointments
  FROM healthcare.patients p
  JOIN healthcare.appointments a ON p.patient_id = a.patient_id
  WHERE a.appointment_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY p.patient_id, p.patient_name
  HAVING num_appointments > 5
),
cte2 AS (
  SELECT d.doctor_id, d.doctor_name, COUNT(DISTINCT a.appointment_id) AS num_appointments
  FROM healthcare.doctors d
  JOIN healthcare.appointments a ON d.doctor_id = a.doctor_id
  WHERE a.appointment_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY d.doctor_id, d.doctor_name
  HAVING num_appointments > 10
),
cte3 AS (
  SELECT p.patient_id, p.patient_name, COUNT(DISTINCT m.medication_id) AS num_medications
  FROM healthcare.patients p
  JOIN healthcare.prescriptions pr ON p.patient_id = pr.patient_id
  JOIN healthcare.medications m ON pr.medication_id = m.medication_id
  WHERE pr.prescription_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY p.patient_id, p.patient_name
  HAVING num_medications > 3
)
SELECT cte1.patient_id, cte1.patient_name, cte2.doctor_name, cte3.num_medications
FROM cte1
CROSS JOIN cte2
LEFT JOIN cte3 ON cte1.patient_id = cte3.patient_id
WHERE cte1.num_appointments > 7
ORDER BY cte1.patient_name ASC, cte2.doctor_name DESC
LIMIT 100;",321,390,711,"['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.prescriptions', 'healthcare.medications']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.prescriptions', 'healthcare.medications']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.prescriptions', 'healthcare.medications']","['healthcare.patients', 'healthcare.appointments', 'healthcare.doctors', 'healthcare.prescriptions', 'healthcare.medications']"
146,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.unit_price,
    oi.quantity,
    oi.quantity * p.unit_price AS total_price
FROM 
    shop.customers c
INNER JOIN 
    shop.orders o ON c.customer_id = o.customer_id
LEFT JOIN 
    shop.order_items oi ON o.order_id = oi.order_id
LEFT JOIN 
    shop.products p ON oi.product_id = p.product_id
WHERE 
    o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
    AND p.category_id IN (
        SELECT 
            category_id
        FROM 
            shop.categories
        WHERE 
            category_name = 'Electronics'
    )
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id
HAVING 
    COUNT(DISTINCT oi.product_id) > 1
ORDER BY 
    total_price DESC
LIMIT 100;",322,232,554,"['shop.customers', 'shop.orders', 'shop.order_items', 'shop.products', 'shop.categories']","['shop.customers', 'shop.orders', 'shop.order_items', 'shop.products', 'shop.categories']","['shop.customers', 'shop.orders', 'shop.order_items', 'shop.products', 'shop.categories']","['shop.customers', 'shop.orders', 'shop.order_items', 'shop.products', 'shop.categories']"
147,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_type,
        p.product_price,
        SUM(o.quantity) AS total_quantity
    FROM 
        energy_company.products p
    JOIN 
        energy_company.orders o ON p.product_id = o.product_id
    WHERE 
        o.order_date >= '2021-01-01'
    GROUP BY 
        p.product_id,
        p.product_name,
        p.product_type,
        p.product_price
    HAVING 
        total_quantity > 100
), cte2 AS (
    SELECT 
        c.customer_id,
        c.customer_name,
        c.customer_type,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        energy_company.customers c
    JOIN 
        energy_company.orders o ON c.customer_id = o.customer_id
    WHERE 
        c.customer_type = 'Business'
    GROUP BY 
        c.customer_id,
        c.customer_name,
        c.customer_type
    HAVING 
        total_orders > 5
), cte3 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_type,
        AVG(o.quantity) AS avg_quantity
    FROM 
        energy_company.products p
    JOIN 
        energy_company.orders o ON p.product_id = o.product_id
    WHERE 
        p.product_type = 'Solar Panels'
    GROUP BY 
        p.product_id,
        p.product_name,
        p.product_type
), cte4 AS (
    SELECT 
        c.customer_id,
        c.customer_name,
        c.customer_type,
        SUM(o.total_price) AS total_sales
    FROM 
        energy_company.customers c
    JOIN 
        energy_company.orders o ON c.customer_id = o.customer_id
    WHERE 
        o.order_date >= '2021-01-01'
    GROUP BY 
        c.customer_id,
        c.customer_name,
        c.customer_type
), cte5 AS (
    SELECT 
        c.customer_id,
        c.customer_name,
        c.customer_type,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        energy_company.customers c
    JOIN 
        energy_company.orders o ON c.customer_id = o.customer_id
    WHERE 
        o.order_date >= '2021-01-01'
    GROUP BY 
        c.customer_id,
        c.customer_name,
        c.customer_type
), cte6 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_type,
        SUM(o.quantity) AS total_quantity
    FROM 
        energy_company.products p
    JOIN 
        energy_company.orders o ON p.product_id = o.product_id
    WHERE 
        p.product_type = 'Wind Turbines'
    GROUP BY 
        p.product_id,
        p.product_name,
        p.product_type
), cte7 AS (
    SELECT 
        c.customer_id,
        c.customer_name,
        c.customer_type,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
        energy_company.customers c
    JOIN 
        energy_company.orders o ON c.customer_id = o.customer_id
    WHERE 
        c.customer_type = 'Residential'
    GROUP BY 
        c.customer_id,
        c.customer_name,
        c.customer_type
)
SELECT 
    cte1.product_id,
    cte1.product_name,
    cte1.product_type,
    cte1.product_price,
    cte1.total_quantity,
    cte2.customer_id,
    cte2.customer_name,
    cte2.customer_type,
    cte2.total_orders,
    cte3.avg_quantity,
    cte4.total_sales,
    cte5.total_orders,
    cte6.total_quantity,
    cte7.total_orders
FROM 
    cte1
JOIN 
    cte2 ON cte1.product_id = cte2.customer_id
JOIN 
    cte3 ON cte1.product_id = cte3.product_id
JOIN 
    cte4 ON cte2.customer_id = cte4.customer_id
JOIN 
    cte5 ON cte2.customer_id = cte5.customer_id
JOIN 
    cte6 ON cte1.product_id = cte6.product_id
JOIN 
    cte7 ON cte2.customer_id = cte7.customer_id
WHERE 
    cte1.total_quantity > 500
    AND cte2.total_orders > 10
    AND cte3.avg_quantity > 50
    AND cte4.total_sales > 10000
    AND cte5.total_orders > 20
    AND cte6.total_quantity > 200
    AND cte7.total_orders > 30;",321,993,1314,"['energy_company.products', 'energy_company.orders', 'energy_company.customers']","['energy_company.products', 'energy_company.orders', 'energy_company.customers']","['energy_company.products', 'energy_company.orders', 'energy_company.customers']","['energy_company.products', 'energy_company.orders', 'energy_company.customers']"
148,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    CONCAT(a.street, ', ', a.city, ', ', a.state) AS customer_address,
    t.trip_id,
    t.trip_name,
    t.trip_date,
    t.trip_duration,
    t.trip_price,
    COUNT(DISTINCT b.booking_id) AS total_bookings,
    SUM(p.price) AS total_revenue
FROM
    travel_agency.customers c
JOIN
    travel_agency.addresses a ON c.address_id = a.address_id
JOIN
    travel_agency.bookings b ON c.customer_id = b.customer_id
JOIN
    travel_agency.trips t ON b.trip_id = t.trip_id
JOIN
    travel_agency.prices p ON t.trip_id = p.trip_id
WHERE
    t.trip_date >= '2022-01-01'
    AND t.trip_date <= '2022-12-31'
    AND t.trip_duration >= 7
    AND t.trip_price >= 1000
GROUP BY
    c.customer_id,
    t.trip_id,
    t.trip_name,
    t.trip_date,
    t.trip_duration,
    t.trip_price
HAVING
    COUNT(DISTINCT b.booking_id) >= 2
    AND SUM(p.price) >= 5000
ORDER BY
    t.trip_date DESC,
    total_revenue DESC
LIMIT 100;",328,295,623,"['travel_agency.customers', 'travel_agency.addresses', 'travel_agency.bookings', 'travel_agency.trips', 'travel_agency.prices']","['travel_agency.customers', 'travel_agency.addresses', 'travel_agency.bookings', 'travel_agency.trips', 'travel_agency.prices']","['travel_agency.customers', 'travel_agency.addresses', 'travel_agency.bookings', 'travel_agency.trips', 'travel_agency.prices']","['travel_agency.customers', 'travel_agency.addresses', 'travel_agency.bookings', 'travel_agency.trips', 'travel_agency.prices']"
149,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(manufacturing_orders.order_id, '-', manufacturing_orders.order_date) AS order_number,
    manufacturing_orders.order_status,
    manufacturing_orders.order_quantity,
    manufacturing_orders.order_price,
    manufacturing_orders.order_quantity * manufacturing_orders.order_price AS total_amount,
    CONCAT(customers.first_name, ' ', customers.last_name) AS customer_name,
    customers.email,
    CONCAT(employees.first_name, ' ', employees.last_name) AS employee_name,
    employees.department,
    products.product_name,
    products.product_category,
    suppliers.supplier_name,
    suppliers.supplier_country
FROM 
    manufacturing_orders
JOIN 
    customers ON manufacturing_orders.customer_id = customers.customer_id
JOIN 
    employees ON manufacturing_orders.employee_id = employees.employee_id
JOIN 
    products ON manufacturing_orders.product_id = products.product_id
JOIN 
    suppliers ON products.supplier_id = suppliers.supplier_id
WHERE 
    manufacturing_orders.order_status = 'Completed'
    AND manufacturing_orders.order_date >= DATE_FORMAT(CURRENT_DATE(), '%Y-%m-01')
    AND manufacturing_orders.order_date <= DATE_FORMAT(CURRENT_DATE(), '%Y-%m-%d')
    AND employees.department = 'Production'
    AND products.product_category IN ('Electronics', 'Automotive')
GROUP BY 
    manufacturing_orders.order_id,
    manufacturing_orders.order_date,
    manufacturing_orders.order_status,
    manufacturing_orders.order_quantity,
    manufacturing_orders.order_price,
    customers.first_name,
    customers.last_name,
    customers.email,
    employees.first_name,
    employees.last_name,
    employees.department,
    products.product_name,
    products.product_category,
    suppliers.supplier_name,
    suppliers.supplier_country
HAVING 
    COUNT(DISTINCT manufacturing_orders.order_id) > 1
ORDER BY 
    total_amount DESC;",324,361,685,"[""manufacturing_orders"", ""customers"", ""employees"", ""products"", ""suppliers""]","[""manufacturing_orders"", ""customers"", ""employees"", ""products"", ""suppliers""]","[""manufacturing_orders"", ""customers"", ""employees"", ""products"", ""suppliers""]","[""manufacturing_orders"", ""customers"", ""employees"", ""products"", ""suppliers""]"
150,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price
  FROM 
    manufacturing.orders o
  WHERE 
    o.order_date >= '2021-01-01'
),
cte_customers AS (
  SELECT 
    c.customer_id,
    c.customer_name,
    c.city,
    c.state
  FROM 
    manufacturing.customers c
  WHERE 
    c.state IN ('CA', 'NY')
),
cte_products AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.category,
    p.unit_price
  FROM 
    manufacturing.products p
  WHERE 
    p.category = 'Electronics'
),
cte_order_details AS (
  SELECT 
    od.order_id,
    od.product_id,
    od.quantity,
    od.unit_price
  FROM 
    manufacturing.order_details od
),
cte_sales AS (
  SELECT 
    o.order_id,
    o.order_date,
    c.customer_name,
    p.product_name,
    od.quantity,
    od.unit_price,
    (od.quantity * od.unit_price) AS total_sales
  FROM 
    cte_orders o
    JOIN cte_customers c ON o.customer_id = c.customer_id
    JOIN cte_order_details od ON o.order_id = od.order_id
    JOIN cte_products p ON od.product_id = p.product_id
),
cte_monthly_sales AS (
  SELECT 
    DATE_FORMAT(s.order_date, '%Y-%m') AS month,
    SUM(s.total_sales) AS monthly_total_sales
  FROM 
    cte_sales s
  GROUP BY 
    DATE_FORMAT(s.order_date, '%Y-%m')
),
cte_top_customers AS (
  SELECT 
    s.customer_name,
    SUM(s.total_sales) AS total_sales
  FROM 
    cte_sales s
  GROUP BY 
    s.customer_name
  HAVING 
    SUM(s.total_sales) > 10000
),
cte_category_sales AS (
  SELECT 
    p.category,
    SUM(s.total_sales) AS total_sales
  FROM 
    cte_sales s
    JOIN cte_products p ON s.product_name = p.product_name
  GROUP BY 
    p.category
),
cte_average_price AS (
  SELECT 
    p.category,
    AVG(p.unit_price) AS average_price
  FROM 
    cte_products p
  GROUP BY 
    p.category
)
SELECT 
  ms.month,
  tc.customer_name,
  cs.category,
  cs.total_sales,
  ap.average_price
FROM 
  cte_monthly_sales ms
  JOIN cte_top_customers tc ON ms.month = tc.month
  JOIN cte_category_sales cs ON ms.month = cs.month
  JOIN cte_average_price ap ON cs.category = ap.category
ORDER BY 
  ms.month ASC, cs.total_sales DESC;",318,605,923,"['manufacturing.orders', 'manufacturing.customers', 'manufacturing.products', 'manufacturing.order_details']","['manufacturing.orders', 'manufacturing.customers', 'manufacturing.products', 'manufacturing.order_details']","['manufacturing.orders', 'manufacturing.customers', 'manufacturing.products', 'manufacturing.order_details']","['manufacturing.orders', 'manufacturing.customers', 'manufacturing.products', 'manufacturing.order_details']"
151,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT_WS(' ', UPPER(employees.first_name), UPPER(employees.last_name)) AS full_name,
    departments.department_name,
    products.product_name,
    SUM(orders.quantity) AS total_quantity,
    AVG(orders.unit_price) AS average_price,
    DATE_FORMAT(orders.order_date, '%Y-%m-%d') AS formatted_date
FROM 
    manufacturing['|'].employees AS employees
JOIN 
    manufacturing['|'].departments AS departments ON employees.department_id = departments.department_id
JOIN 
    manufacturing['|'].orders AS orders ON employees.employee_id = orders.employee_id
JOIN 
    manufacturing['|'].products AS products ON orders.product_id = products.product_id
WHERE 
    employees.hire_date >= '2020-01-01'
    AND departments.department_name = 'Production'
    AND products.category = 'Electronics'
GROUP BY 
    employees.employee_id,
    departments.department_id,
    products.product_id
HAVING 
    total_quantity > 100
ORDER BY 
    full_name ASC,
    departments.department_name DESC,
    total_quantity DESC
LIMIT 100;",319,226,545,"['manufacturing.employees', 'manufacturing.departments', 'manufacturing.orders', 'manufacturing.products']","['manufacturing.employees', 'manufacturing.departments', 'manufacturing.orders', 'manufacturing.products']","['manufacturing.employees', 'manufacturing.departments', 'manufacturing.orders', 'manufacturing.products']","['manufacturing.employees', 'manufacturing.departments', 'manufacturing.orders', 'manufacturing.products']"
152,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    a.balance
  FROM 
    customers c
  INNER JOIN 
    accounts a ON c.customer_id = a.customer_id
  WHERE 
    a.balance > 1000
),
cte2 AS (
  SELECT 
    t.transaction_id,
    t.account_number,
    t.transaction_date,
    t.amount,
    CASE 
      WHEN t.amount > 500 THEN 'Large Transaction'
      ELSE 'Small Transaction'
    END AS transaction_type
  FROM 
    transactions t
  INNER JOIN 
    cte1 ON t.account_number = cte1.account_number
  WHERE 
    t.transaction_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
),
cte3 AS (
  SELECT 
    cte2.account_number,
    COUNT(DISTINCT cte2.transaction_id) AS num_transactions
  FROM 
    cte2
  GROUP BY 
    cte2.account_number
  HAVING 
    num_transactions > 5
),
cte4 AS (
  SELECT 
    cte1.customer_name,
    cte1.account_number,
    cte1.balance,
    cte3.num_transactions
  FROM 
    cte1
  INNER JOIN 
    cte3 ON cte1.account_number = cte3.account_number
),
cte5 AS (
  SELECT 
    cte4.customer_name,
    cte4.account_number,
    cte4.balance,
    cte4.num_transactions,
    CASE 
      WHEN cte4.balance > 10000 THEN 'High Balance'
      WHEN cte4.balance > 5000 THEN 'Medium Balance'
      ELSE 'Low Balance'
    END AS balance_category
  FROM 
    cte4
),
cte6 AS (
  SELECT 
    cte5.customer_name,
    cte5.account_number,
    cte5.balance,
    cte5.num_transactions,
    cte5.balance_category,
    CASE 
      WHEN cte5.num_transactions > 10 THEN 'Active Customer'
      ELSE 'Inactive Customer'
    END AS customer_status
  FROM 
    cte5
),
cte7 AS (
  SELECT 
    cte6.customer_name,
    cte6.account_number,
    cte6.balance,
    cte6.num_transactions,
    cte6.balance_category,
    cte6.customer_status,
    ROW_NUMBER() OVER (PARTITION BY cte6.balance_category ORDER BY cte6.balance DESC) AS rank
  FROM 
    cte6
),
cte8 AS (
  SELECT 
    cte7.customer_name,
    cte7.account_number,
    cte7.balance,
    cte7.num_transactions,
    cte7.balance_category,
    cte7.customer_status
  FROM 
    cte7
  WHERE 
    cte7.rank <= 3
)
SELECT 
  cte8.customer_name,
  cte8.account_number,
  cte8.balance,
  cte8.num_transactions,
  cte8.balance_category,
  cte8.customer_status
FROM 
  cte8
ORDER BY 
  cte8.balance_category ASC, cte8.balance DESC;",317,686,1003,"['customers', 'accounts', 'transactions']","['customers', 'accounts', 'transactions']","['customers', 'accounts', 'transactions']","['customers', 'accounts', 'transactions']"
153,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    o.order_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
  GROUP BY
    c.customer_id
  HAVING
    total_orders > 5
)
SELECT
  cte.customer_name,
  cte.total_orders,
  SUM(p.price) AS total_spent,
  AVG(p.price) AS average_spent,
  COUNT(DISTINCT h.hotel_id) AS total_hotels_visited
FROM
  cte
INNER JOIN
  order_items oi ON cte.customer_id = oi.customer_id
INNER JOIN
  products p ON oi.product_id = p.product_id
LEFT JOIN
  hotel_bookings hb ON cte.customer_id = hb.customer_id
LEFT JOIN
  hotels h ON hb.hotel_id = h.hotel_id
GROUP BY
  cte.customer_id
HAVING
  total_spent > 1000
ORDER BY
  total_spent DESC
LIMIT
  10;",313,259,572,"['customers', 'orders', 'order_items', 'products', 'hotel_bookings', 'hotels']","['customers', 'orders', 'order_items', 'products', 'hotel_bookings', 'hotels']","['customers', 'orders', 'order_items', 'products', 'hotel_bookings', 'hotels']","['customers', 'orders', 'order_items', 'products', 'hotel_bookings', 'hotels']"
154,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.price) AS total_price
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_products op ON o.order_id = op.order_id
JOIN 
    products p ON op.product_id = p.product_id
JOIN 
    categories cat ON p.category_id = cat.category_id
JOIN 
    suppliers s ON p.supplier_id = s.supplier_id
WHERE 
    cat.category_name = 'Electronics'
    AND s.country = 'USA'
    AND o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id
HAVING 
    total_quantity > 5
ORDER BY 
    total_price DESC
LIMIT 10
CROSS JOIN 
    (SELECT COUNT(*) AS total_orders FROM orders) t
WHERE 
    t.total_orders > 1000;",318,261,579,"['customers', 'orders', 'order_products', 'products', 'categories', 'suppliers']","['customers', 'orders', 'order_products', 'products', 'categories', 'suppliers']","['customers', 'orders', 'order_products', 'products', 'categories', 'suppliers']","['customers', 'orders', 'order_products', 'products', 'categories', 'suppliers']"
155,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a bank.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    a.account_number,
    a.balance,
    t.transaction_date,
    t.transaction_type,
    t.amount
FROM 
    bank.customers AS c
CROSS JOIN 
    bank.accounts AS a
LATERAL JOIN 
    (
        SELECT 
            transaction_date,
            transaction_type,
            amount,
            account_id
        FROM 
            bank.transactions AS t
        WHERE 
            t.account_id = a.account_id
        ORDER BY 
            transaction_date DESC
        LIMIT 1
    ) AS t
WHERE 
    c.customer_id = a.customer_id
    AND a.balance > 1000
    AND t.transaction_type = 'debit'
GROUP BY 
    c.customer_id,
    a.account_id,
    t.transaction_id
HAVING 
    SUM(t.amount) > 500
ORDER BY 
    c.last_name ASC,
    c.first_name ASC,
    a.account_number ASC;",321,205,526,"['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']","['bank.customers', 'bank.accounts', 'bank.transactions']"
156,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    COUNT(o.order_id) AS total_orders,
    SUM(p.price) AS total_sales,
    AVG(p.price) AS average_price,
    MAX(p.price) AS highest_price,
    MIN(p.price) AS lowest_price
FROM 
    real_estate.customers AS c
INNER JOIN 
    real_estate.orders AS o ON c.customer_id = o.customer_id
LEFT JOIN 
    real_estate.properties AS p ON o.property_id = p.property_id
LEFT JOIN 
    real_estate.agents AS a ON p.agent_id = a.agent_id
WHERE 
    c.city = 'New York'
    AND a.specialty = 'Residential'
    AND p.status = 'Sold'
GROUP BY 
    c.customer_id, c.first_name, c.last_name
HAVING 
    total_sales > 100000
ORDER BY 
    total_sales DESC;",320,196,516,"['real_estate.customers', 'real_estate.orders', 'real_estate.properties', 'real_estate.agents']","['real_estate.customers', 'real_estate.orders', 'real_estate.properties', 'real_estate.agents']","['real_estate.customers', 'real_estate.orders', 'real_estate.properties', 'real_estate.agents']","['real_estate.customers', 'real_estate.orders', 'real_estate.properties', 'real_estate.agents']"
157,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a retail company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH
  cte1 AS (
    SELECT
      CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
      o.order_id,
      o.order_date,
      o.order_status
    FROM
      sales.customers c
    JOIN
      sales.orders o ON c.customer_id = o.customer_id
    WHERE
      o.order_status = 'completed'
      AND o.order_date >= '2021-01-01'
  ),
  cte2 AS (
    SELECT
      p.product_name,
      p.product_category,
      oi.order_id,
      oi.quantity,
      oi.unit_price
    FROM
      inventory.products p
    JOIN
      sales.order_items oi ON p.product_id = oi.product_id
  ),
  cte3 AS (
    SELECT
      cte1.customer_name,
      cte1.order_id,
      cte1.order_date,
      cte1.order_status,
      cte2.product_name,
      cte2.product_category,
      cte2.quantity,
      cte2.unit_price,
      cte2.quantity * cte2.unit_price AS total_price
    FROM
      cte1
    JOIN
      cte2 ON cte1.order_id = cte2.order_id
  )
SELECT
  cte3.customer_name,
  DATE_FORMAT(cte3.order_date, '%Y-%m-%d') AS formatted_order_date,
  COUNT(DISTINCT cte3.order_id) AS total_orders,
  SUM(cte3.quantity) AS total_quantity,
  SUM(cte3.total_price) AS total_sales
FROM
  cte3
WHERE
  cte3.product_category = 'Electronics'
GROUP BY
  cte3.customer_name,
  formatted_order_date
HAVING
  total_sales > 1000
ORDER BY
  total_sales DESC;",315,387,702,"['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']","['sales.customers', 'sales.orders', 'inventory.products', 'sales.order_items']"
158,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a real estate business.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(properties.address, ', ', properties.city, ', ', properties.state) AS full_address,
    properties.bedrooms,
    properties.bathrooms,
    properties.square_feet,
    properties.list_price,
    AVG(sales.price) AS average_sale_price,
    COUNT(DISTINCT agents.agent_id) AS unique_agents_sold,
    CONCAT(agents.first_name, ' ', agents.last_name) AS agent_name,
    CONCAT(sellers.first_name, ' ', sellers.last_name) AS seller_name
FROM
    real_estate.properties
CROSS JOIN
    real_estate.agents
CROSS JOIN
    real_estate.sellers
CROSS JOIN
    real_estate.sales
LATERAL JOIN
    (SELECT 
        property_id,
            COUNT(*) AS total_sales
    FROM
        real_estate.sales
    GROUP BY property_id
    HAVING total_sales > 5) AS high_sales_properties ON properties.property_id = high_sales_properties.property_id
WHERE
    properties.list_price > 500000
        AND properties.bedrooms >= 3
        AND properties.bathrooms >= 2
        AND properties.square_feet >= 2000
        AND sellers.seller_id = properties.seller_id
        AND agents.agent_id = sales.agent_id
GROUP BY properties.property_id
HAVING average_sale_price > 1000000
ORDER BY properties.list_price DESC;",326,288,614,"['real_estate.properties', 'real_estate.agents', 'real_estate.sellers', 'real_estate.sales']","['real_estate.properties', 'real_estate.agents', 'real_estate.sellers', 'real_estate.sales']","['real_estate.properties', 'real_estate.agents', 'real_estate.sellers', 'real_estate.sales']","['real_estate.properties', 'real_estate.agents', 'real_estate.sellers', 'real_estate.sales']"
159,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a company in the energy sector.

The resulting output should strictly be the SQL query without any surrounding text.","WITH
  cte1 AS (
    SELECT
      CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
      o.order_date,
      o.total_price
    FROM
      energy_company.customers AS c
    JOIN
      energy_company.orders AS o ON c.customer_id = o.customer_id
    WHERE
      o.order_date >= '2021-01-01'
      AND o.order_date <= '2021-12-31'
  ),
  cte2 AS (
    SELECT
      customer_name,
      DATE_FORMAT(order_date, '%Y-%m') AS order_month,
      SUM(total_price) AS total_sales
    FROM
      cte1
    GROUP BY
      customer_name,
      order_month
  ),
  cte3 AS (
    SELECT
      customer_name,
      COUNT(DISTINCT order_month) AS active_months
    FROM
      cte2
    GROUP BY
      customer_name
    HAVING
      COUNT(DISTINCT order_month) >= 6
  )
SELECT
  cte3.customer_name,
  cte3.active_months,
  COUNT(DISTINCT cte2.order_month) AS total_months,
  AVG(cte2.total_sales) AS average_sales,
  MAX(cte2.total_sales) AS max_sales
FROM
  cte3
JOIN
  cte2 ON cte3.customer_name = cte2.customer_name
GROUP BY
  cte3.customer_name,
  cte3.active_months
HAVING
  COUNT(DISTINCT cte2.order_month) >= 6
ORDER BY
  average_sales DESC
LIMIT
  10;",323,348,671,"['energy_company.customers', 'energy_company.orders']","['energy_company.customers', 'energy_company.orders']","['energy_company.customers', 'energy_company.orders']","['energy_company.customers', 'energy_company.orders']"
160,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(u.first_name, ' ', u.last_name) AS full_name,
    a.article_title,
    a.article_date,
    c.category_name,
    COUNT(DISTINCT c.comment_id) AS total_comments,
    SUM(a.article_views) AS total_views
FROM 
    users u
JOIN 
    articles a ON u.user_id = a.author_id
JOIN 
    categories c ON a.category_id = c.category_id
JOIN 
    (
        SELECT 
            article_id,
            MAX(comment_date) AS latest_comment_date
        FROM 
            comments
        GROUP BY 
            article_id
    ) AS latest_comments ON a.article_id = latest_comments.article_id
JOIN 
    (
        SELECT 
            article_id,
            COUNT(*) AS total_likes
        FROM 
            likes
        GROUP BY 
            article_id
    ) AS article_likes ON a.article_id = article_likes.article_id
WHERE 
    a.article_status = 'published'
    AND a.article_date >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
    AND a.article_views > 1000
    AND c.category_name IN ('Politics', 'Entertainment')
GROUP BY 
    u.user_id,
    a.article_id,
    c.category_id
HAVING 
    total_comments > 10
ORDER BY 
    total_views DESC
LIMIT 10;",319,277,596,"['users', 'articles', 'categories', 'comments', 'likes']","['users', 'articles', 'categories', 'comments', 'likes']","['users', 'articles', 'categories', 'comments', 'likes']","['users', 'articles', 'categories', 'comments', 'likes']"
161,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.product_name, ' - ', p.product_code) AS Product,
    c.category_name AS Category,
    s.supplier_name AS Supplier,
    SUM(o.quantity) AS TotalQuantity,
    AVG(o.unit_price) AS AveragePrice,
    COUNT(DISTINCT o.order_id) AS TotalOrders,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS OrderDate,
    UPPER(u.username) AS UserName
FROM
    pharmaceutical_company.products p
    JOIN pharmaceutical_company.categories c ON p.category_id = c.category_id
    JOIN pharmaceutical_company.suppliers s ON p.supplier_id = s.supplier_id
    JOIN pharmaceutical_company.orders o ON p.product_id = o.product_id
    JOIN pharmaceutical_company.users u ON o.user_id = u.user_id
WHERE
    p.product_status = 'Active'
    AND c.category_name IN ('Antibiotics', 'Painkillers')
    AND s.supplier_country = 'United States'
    AND o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
GROUP BY
    p.product_name,
    c.category_name,
    s.supplier_name,
    DATE_FORMAT(o.order_date, '%Y-%m-%d'),
    UPPER(u.username)
HAVING
    TotalQuantity > 100
    AND AveragePrice < 50
ORDER BY
    TotalOrders DESC,
    Product ASC;",321,291,612,"['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']","['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']","['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']","['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']"
162,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    kusto['travel_db'].customers c
  INNER JOIN
    kusto['travel_db'].orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'United States'
  GROUP BY
    c.customer_id, c.customer_first_name, c.customer_last_name
  HAVING
    COUNT(DISTINCT o.order_id) > 5
),
cte2 AS (
  SELECT
    p.product_name,
    SUM(op.quantity) AS total_quantity
  FROM
    products p
  INNER JOIN
    order_products op ON p.product_id = op.product_id
  WHERE
    p.product_category = 'Flights'
  GROUP BY
    p.product_id, p.product_name
  HAVING
    SUM(op.quantity) > 100
),
cte3 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'France'
  GROUP BY
    c.customer_id
),
cte4 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Germany'
  GROUP BY
    c.customer_id
),
cte5 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Italy'
  GROUP BY
    c.customer_id
),
cte6 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Spain'
  GROUP BY
    c.customer_id
),
cte7 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'United Kingdom'
  GROUP BY
    c.customer_id
),
cte8 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'United States'
  GROUP BY
    c.customer_id
),
cte9 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Canada'
  GROUP BY
    c.customer_id
),
cte10 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Australia'
  GROUP BY
    c.customer_id
),
cte11 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'New Zealand'
  GROUP BY
    c.customer_id
),
cte12 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Japan'
  GROUP BY
    c.customer_id
),
cte13 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'China'
  GROUP BY
    c.customer_id
),
cte14 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'India'
  GROUP BY
    c.customer_id
),
cte15 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Brazil'
  GROUP BY
    c.customer_id
),
cte16 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Argentina'
  GROUP BY
    c.customer_id
),
cte17 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Mexico'
  GROUP BY
    c.customer_id
),
cte18 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'South Africa'
  GROUP BY
    c.customer_id
),
cte19 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Egypt'
  GROUP BY
    c.customer_id
),
cte20 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Morocco'
  GROUP BY
    c.customer_id
),
cte21 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Kenya'
  GROUP BY
    c.customer_id
),
cte22 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Nigeria'
  GROUP BY
    c.customer_id
),
cte23 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Russia'
  GROUP BY
    c.customer_id
),
cte24 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Germany'
  GROUP BY
    c.customer_id
),
cte25 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'France'
  GROUP BY
    c.customer_id
),
cte26 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Italy'
  GROUP BY
    c.customer_id
),
cte27 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Spain'
  GROUP BY
    c.customer_id
),
cte28 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'United Kingdom'
  GROUP BY
    c.customer_id
),
cte29 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'United States'
  GROUP BY
    c.customer_id
),
cte30 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Canada'
  GROUP BY
    c.customer_id
),
cte31 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Australia'
  GROUP BY
    c.customer_id
),
cte32 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'New Zealand'
  GROUP BY
    c.customer_id
),
cte33 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Japan'
  GROUP BY
    c.customer_id
),
cte34 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'China'
  GROUP BY
    c.customer_id
),
cte35 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'India'
  GROUP BY
    c.customer_id
),
cte36 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Brazil'
  GROUP BY
    c.customer_id
),
cte37 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Argentina'
  GROUP BY
    c.customer_id
),
cte38 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Mexico'
  GROUP BY
    c.customer_id
),
cte39 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'South Africa'
  GROUP BY
    c.customer_id
),
cte40 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Egypt'
  GROUP BY
    c.customer_id
),
cte41 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Morocco'
  GROUP BY
    c.customer_id
),
cte42 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Kenya'
  GROUP BY
    c.customer_id
),
cte43 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Nigeria'
  GROUP BY
    c.customer_id
),
cte44 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Russia'
  GROUP BY
    c.customer_id
),
cte45 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Germany'
  GROUP BY
    c.customer_id
),
cte46 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'France'
  GROUP BY
    c.customer_id
),
cte47 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Italy'
  GROUP BY
    c.customer_id
),
cte48 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Spain'
  GROUP BY
    c.customer_id
),
cte49 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'United Kingdom'
  GROUP BY
    c.customer_id
),
cte50 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'United States'
  GROUP BY
    c.customer_id
),
cte51 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Canada'
  GROUP BY
    c.customer_id
),
cte52 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'Australia'
  GROUP BY
    c.customer_id
),
cte53 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
",321,3777,4098,"[""kusto['travel_db'].customers"", ""kusto['travel_db'].orders"", ""products"", ""order_products"", ""customers"", ""orders""]","[""kusto['travel_db'].customers"", ""kusto['travel_db'].orders"", ""products"", ""order_products"", ""customers"", ""orders""]","[""kusto['travel_db'].customers"", ""kusto['travel_db'].orders"", ""products"", ""order_products"", ""customers"", ""orders""]","[""kusto['travel_db'].customers"", ""kusto['travel_db'].orders"", ""products"", ""order_products"", ""customers"", ""orders""]"
163,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a retail company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_date,
    p.product_name,
    SUM(od.quantity) AS total_quantity,
    SUM(od.quantity * od.unit_price) AS total_revenue
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_details od ON o.order_id = od.order_id
JOIN 
    products p ON od.product_id = p.product_id
WHERE 
    o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
    AND p.category = 'Electronics'
GROUP BY 
    c.customer_id, o.order_date, p.product_id
HAVING 
    total_quantity > 10
ORDER BY 
    total_revenue DESC
LIMIT 100
CROSS JOIN 
    (SELECT 
        AVG(total_revenue) AS avg_revenue
    FROM 
        (SELECT 
            SUM(od.quantity * od.unit_price) AS total_revenue
        FROM 
            orders o
        JOIN 
            order_details od ON o.order_id = od.order_id
        WHERE 
            o.order_date >= '2021-01-01' AND o.order_date <= '2021-12-31'
        GROUP BY 
            o.order_id) subquery) avg_revenue_subquery;",317,286,603,"['customers', 'orders', 'order_details', 'products']","['customers', 'orders', 'order_details', 'products']","['customers', 'orders', 'order_details', 'products']","['customers', 'orders', 'order_details', 'products']"
164,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a logistics company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    c.customer_address
  FROM 
    logistics.orders o
  JOIN 
    logistics.customers c ON o.customer_id = c.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

cte_shipments AS (
  SELECT 
    s.shipment_id,
    s.order_id,
    s.shipment_date,
    s.shipment_status,
    s.carrier_id,
    c.carrier_name,
    c.carrier_address
  FROM 
    logistics.shipments s
  JOIN 
    logistics.carriers c ON s.carrier_id = c.carrier_id
),

cte_products AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.category_id,
    c.category_name,
    p.unit_price
  FROM 
    logistics.products p
  JOIN 
    logistics.categories c ON p.category_id = c.category_id
),

cte_order_items AS (
  SELECT 
    oi.order_id,
    oi.product_id,
    oi.quantity,
    oi.unit_price,
    oi.discount
  FROM 
    logistics.order_items oi
),

cte_shipment_items AS (
  SELECT 
    si.shipment_id,
    si.product_id,
    si.quantity
  FROM 
    logistics.shipment_items si
),

cte_total_sales AS (
  SELECT 
    o.customer_id,
    SUM(o.total_price) AS total_sales
  FROM 
    cte_orders o
  GROUP BY 
    o.customer_id
),

cte_average_quantity AS (
  SELECT 
    oi.product_id,
    AVG(oi.quantity) AS average_quantity
  FROM 
    cte_order_items oi
  GROUP BY 
    oi.product_id
),

cte_shipment_status_counts AS (
  SELECT 
    s.shipment_status,
    COUNT(s.shipment_id) AS shipment_count
  FROM 
    cte_shipments s
  GROUP BY 
    s.shipment_status
),

cte_top_customers AS (
  SELECT 
    o.customer_id,
    SUM(o.total_price) AS total_spent
  FROM 
    cte_orders o
  GROUP BY 
    o.customer_id
  HAVING 
    SUM(o.total_price) > (
      SELECT 
        AVG(total_sales)
      FROM 
        cte_total_sales
    )
),

cte_product_sales AS (
  SELECT 
    p.product_id,
    SUM(oi.quantity) AS total_quantity
  FROM 
    cte_products p
  JOIN 
    cte_order_items oi ON p.product_id = oi.product_id
  GROUP BY 
    p.product_id
),

cte_shipment_summary AS (
  SELECT 
    s.shipment_id,
    s.shipment_date,
    s.shipment_status,
    s.carrier_id,
    c.carrier_name,
    COUNT(si.product_id) AS total_items
  FROM 
    cte_shipments s
  JOIN 
    cte_carriers c ON s.carrier_id = c.carrier_id
  JOIN 
    cte_shipment_items si ON s.shipment_id = si.shipment_id
  GROUP BY 
    s.shipment_id,
    s.shipment_date,
    s.shipment_status,
    s.carrier_id,
    c.carrier_name
),

cte_category_sales AS (
  SELECT 
    c.category_id,
    c.category_name,
    SUM(oi.quantity) AS total_quantity
  FROM 
    cte_categories c
  JOIN 
    cte_products p ON c.category_id = p.category_id
  JOIN 
    cte_order_items oi ON p.product_id = oi.product_id
  GROUP BY 
    c.category_id,
    c.category_name
),

cte_customer_shipments AS (
  SELECT 
    o.customer_id,
    COUNT(DISTINCT s.shipment_id) AS total_shipments
  FROM 
    cte_orders o
  JOIN 
    cte_shipments s ON o.order_id = s.order_id
  GROUP BY 
    o.customer_id
),

cte_shipment_duration AS (
  SELECT 
    s.shipment_id,
    DATEDIFF(s.shipment_date, o.order_date) AS duration
  FROM 
    cte_shipments s
  JOIN 
    cte_orders o ON s.order_id = o.order_id
),

cte_shipment_duration_stats AS (
  SELECT 
    MIN(duration) AS min_duration,
    MAX(duration) AS max_duration,
    AVG(duration) AS avg_duration
  FROM 
    cte_shipment_duration
),

cte_shipment_carrier_stats AS (
  SELECT 
    c.carrier_id,
    c.carrier_name,
    COUNT(s.shipment_id) AS total_shipments
  FROM 
    cte_carriers c
  JOIN 
    cte_shipments s ON c.carrier_id = s.carrier_id
  GROUP BY 
    c.carrier_id,
    c.carrier_name
),

cte_shipment_status_duration AS (
  SELECT 
    s.shipment_status,
    AVG(DATEDIFF(s.shipment_date, o.order_date)) AS avg_duration
  FROM 
    cte_shipments s
  JOIN 
    cte_orders o ON s.order_id = o.order_id
  GROUP BY 
    s.shipment_status
),

cte_shipment_status_duration_stats AS (
  SELECT 
    MIN(avg_duration) AS min_avg_duration,
    MAX(avg_duration) AS max_avg_duration,
    AVG(avg_duration) AS avg_avg_duration
  FROM 
    cte_shipment_status_duration
)

SELECT 
  c.customer_name,
  c.customer_address,
  COUNT(DISTINCT o.order_id) AS total_orders,
  COUNT(DISTINCT s.shipment_id) AS total_shipments,
  SUM(o.total_price) AS total_sales,
  AVG(oi.quantity) AS average_quantity,
  MIN(s.shipment_date) AS first_shipment_date,
  MAX(s.shipment_date) AS last_shipment_date,
  MIN(s.shipment_status) AS first_shipment_status,
  MAX(s.shipment_status) AS last_shipment_status,
  MIN(si.quantity) AS min_shipment_quantity,
  MAX(si.quantity) AS max_shipment_quantity,
  AVG(si.quantity) AS avg_shipment_quantity,
  MIN(duration) AS min_shipment_duration,
  MAX(duration) AS max_shipment_duration,
  AVG(duration) AS avg_shipment_duration
FROM 
  cte_orders o
JOIN 
  cte_customers c ON o.customer_id = c.customer_id
LEFT JOIN 
  cte_shipments s ON o.order_id = s.order_id
LEFT JOIN 
  cte_order_items oi ON o.order_id = oi.order_id
LEFT JOIN 
  cte_shipment_items si ON s.shipment_id = si.shipment_id
LEFT JOIN 
  cte_shipment_duration d ON s.shipment_id = d.shipment_id
GROUP BY 
  c.customer_name,
  c.customer_address",318,1480,1798,"['logistics.orders', 'logistics.customers', 'logistics.shipments', 'logistics.carriers', 'logistics.products', 'logistics.categories', 'logistics.order_items', 'logistics.shipment_items']","['logistics.orders', 'logistics.customers', 'logistics.shipments', 'logistics.carriers', 'logistics.products', 'logistics.categories', 'logistics.order_items', 'logistics.shipment_items']","['logistics.orders', 'logistics.customers', 'logistics.shipments', 'logistics.carriers', 'logistics.products', 'logistics.categories', 'logistics.order_items', 'logistics.shipment_items']","['logistics.orders', 'logistics.customers', 'logistics.shipments', 'logistics.carriers', 'logistics.products', 'logistics.categories', 'logistics.order_items', 'logistics.shipment_items']"
165,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT
    CONCAT(cust.first_name, ' ', cust.last_name) AS customer_name,
    cust.email,
    COUNT(DISTINCT ord.order_id) AS total_orders
  FROM
    travel_db.customers AS cust
  INNER JOIN
    travel_db.orders AS ord
  ON
    cust.customer_id = ord.customer_id
  WHERE
    cust.country = 'United States'
  GROUP BY
    cust.customer_id,
    cust.first_name,
    cust.last_name,
    cust.email
  HAVING
    total_orders > 5
),
cte2 AS (
  SELECT
    CONCAT(cust.first_name, ' ', cust.last_name) AS customer_name,
    COUNT(DISTINCT hot.hotel_id) AS total_hotels
  FROM
    travel_db.customers AS cust
  INNER JOIN
    travel_db.orders AS ord
  ON
    cust.customer_id = ord.customer_id
  INNER JOIN
    travel_db.hotel_bookings AS hot
  ON
    ord.order_id = hot.order_id
  WHERE
    hot.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY
    cust.customer_id,
    cust.first_name,
    cust.last_name
),
cte3 AS (
  SELECT
    CONCAT(cust.first_name, ' ', cust.last_name) AS customer_name,
    COUNT(DISTINCT flt.flight_id) AS total_flights
  FROM
    travel_db.customers AS cust
  INNER JOIN
    travel_db.orders AS ord
  ON
    cust.customer_id = ord.customer_id
  INNER JOIN
    travel_db.flight_bookings AS flt
  ON
    ord.order_id = flt.order_id
  WHERE
    flt.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY
    cust.customer_id,
    cust.first_name,
    cust.last_name
)
SELECT
  cte1.customer_name,
  cte1.email,
  cte1.total_orders,
  cte2.total_hotels,
  cte3.total_flights
FROM
  cte1
INNER JOIN
  cte2
ON
  cte1.customer_name = cte2.customer_name
INNER JOIN
  cte3
ON
  cte1.customer_name = cte3.customer_name
WHERE
  cte1.total_orders > 10
  AND cte2.total_hotels > 3
  AND cte3.total_flights > 5
ORDER BY
  cte1.total_orders DESC,
  cte2.total_hotels DESC,
  cte3.total_flights DESC;",328,561,889,"['travel_db.customers', 'travel_db.orders', 'travel_db.hotel_bookings', 'travel_db.flight_bookings']","['travel_db.customers', 'travel_db.orders', 'travel_db.hotel_bookings', 'travel_db.flight_bookings']","['travel_db.customers', 'travel_db.orders', 'travel_db.hotel_bookings', 'travel_db.flight_bookings']","['travel_db.customers', 'travel_db.orders', 'travel_db.hotel_bookings', 'travel_db.flight_bookings']"
166,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an insurance company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(p.policy_id) AS total_policies
  FROM 
    insurance.company_customers c
  JOIN 
    insurance.policies p ON c.customer_id = p.customer_id
  WHERE 
    p.policy_status = 'active'
  GROUP BY 
    c.customer_id
  HAVING 
    total_policies > 5
),
cte2 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(c.claim_id) AS total_claims
  FROM 
    insurance.company_customers c
  JOIN 
    insurance.claims cl ON c.customer_id = cl.customer_id
  WHERE 
    cl.claim_status = 'approved'
  GROUP BY 
    c.customer_id
  HAVING 
    total_claims > 10
),
cte3 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    SUM(p.policy_premium) AS total_premium
  FROM 
    insurance.company_customers c
  JOIN 
    insurance.policies p ON c.customer_id = p.customer_id
  WHERE 
    p.policy_status = 'active'
  GROUP BY 
    c.customer_id
  HAVING 
    total_premium > 50000
)
SELECT 
  CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
  c.customer_email,
  c.customer_phone,
  c.customer_address,
  cte1.total_policies,
  cte2.total_claims,
  cte3.total_premium
FROM 
  insurance.company_customers c
JOIN 
  cte1 ON c.customer_name = cte1.customer_name
JOIN 
  cte2 ON c.customer_name = cte2.customer_name
JOIN 
  cte3 ON c.customer_name = cte3.customer_name
WHERE 
  c.customer_status = 'active'
ORDER BY 
  c.customer_name ASC;",320,434,754,"['insurance.company_customers', 'insurance.policies', 'insurance.claims']","['insurance.company_customers', 'insurance.policies', 'insurance.claims']","['insurance.company_customers', 'insurance.policies', 'insurance.claims']","['insurance.company_customers', 'insurance.policies', 'insurance.claims']"
167,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an insurance company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_insured_customers AS (
    SELECT 
        c.customer_id,
        c.first_name,
        c.last_name,
        c.date_of_birth,
        c.address,
        c.city,
        c.state,
        c.zip_code,
        p.policy_id,
        p.policy_type,
        p.policy_start_date,
        p.policy_end_date,
        p.premium_amount
    FROM 
        insurance_db.customers c
    INNER JOIN 
        insurance_db.policies p ON c.customer_id = p.customer_id
    WHERE 
        p.policy_start_date <= CURRENT_DATE
        AND p.policy_end_date >= CURRENT_DATE
),
cte_claimed_policies AS (
    SELECT 
        p.policy_id,
        p.claim_id,
        p.claim_date,
        p.claim_amount,
        p.claim_status
    FROM 
        insurance_db.policies p
    INNER JOIN 
        insurance_db.claims c ON p.policy_id = c.policy_id
    WHERE 
        c.claim_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
),
cte_total_premiums AS (
    SELECT 
        customer_id,
        SUM(premium_amount) AS total_premiums
    FROM 
        cte_insured_customers
    GROUP BY 
        customer_id
),
cte_total_claims AS (
    SELECT 
        customer_id,
        COUNT(claim_id) AS total_claims
    FROM 
        cte_claimed_policies
    GROUP BY 
        customer_id
),
cte_customer_summary AS (
    SELECT 
        ic.customer_id,
        ic.first_name,
        ic.last_name,
        ic.date_of_birth,
        ic.address,
        ic.city,
        ic.state,
        ic.zip_code,
        ic.policy_id,
        ic.policy_type,
        ic.policy_start_date,
        ic.policy_end_date,
        ic.premium_amount,
        cp.total_claims,
        tp.total_premiums
    FROM 
        cte_insured_customers ic
    LEFT JOIN 
        cte_total_claims cp ON ic.customer_id = cp.customer_id
    LEFT JOIN 
        cte_total_premiums tp ON ic.customer_id = tp.customer_id
),
cte_top_customers AS (
    SELECT 
        customer_id,
        first_name,
        last_name,
        total_premiums,
        total_claims,
        ROW_NUMBER() OVER (ORDER BY total_premiums DESC, total_claims DESC) AS rank
    FROM 
        cte_customer_summary
)
SELECT 
    tc.customer_id,
    tc.first_name,
    tc.last_name,
    tc.date_of_birth,
    tc.address,
    tc.city,
    tc.state,
    tc.zip_code,
    tc.policy_id,
    tc.policy_type,
    tc.policy_start_date,
    tc.policy_end_date,
    tc.premium_amount,
    tc.total_claims,
    tc.total_premiums,
    tc.rank
FROM 
    cte_top_customers tc
WHERE 
    tc.rank <= 10
ORDER BY 
    tc.rank ASC;",322,631,953,"['insurance_db.customers', 'insurance_db.policies', 'insurance_db.claims']","['insurance_db.customers', 'insurance_db.policies', 'insurance_db.claims']","['insurance_db.customers', 'insurance_db.policies', 'insurance_db.claims']","['insurance_db.customers', 'insurance_db.policies', 'insurance_db.claims']"
168,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(o.order_id) AS total_orders
  FROM
    travel_agency.customers c
  INNER JOIN
    travel_agency.orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'USA'
  GROUP BY
    c.customer_id
  HAVING
    total_orders > 5
),
cte2 AS (
  SELECT
    p.package_id,
    p.package_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.order_price) AS total_revenue
  FROM
    travel_agency.packages p
  LEFT JOIN
    travel_agency.orders o ON p.package_id = o.package_id
  WHERE
    p.package_type = 'Adventure'
    AND o.order_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
  GROUP BY
    p.package_id
  HAVING
    total_orders > 10
),
cte3 AS (
  SELECT
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    travel_agency.customers c
  LEFT JOIN
    travel_agency.orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'France'
  GROUP BY
    c.customer_id
  HAVING
    total_orders > 3
),
cte4 AS (
  SELECT
    p.package_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM
    travel_agency.packages p
  LEFT JOIN
    travel_agency.orders o ON p.package_id = o.package_id
  WHERE
    p.package_type = 'Luxury'
    AND o.order_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
  GROUP BY
    p.package_id
  HAVING
    total_orders > 5
)
SELECT
  cte1.customer_name,
  cte2.package_name,
  cte2.total_orders,
  cte2.total_revenue,
  cte3.total_orders AS france_total_orders,
  cte4.total_orders AS luxury_total_orders
FROM
  cte1
CROSS JOIN
  cte2
LEFT JOIN
  cte3 ON cte1.customer_id = cte3.customer_id
LEFT JOIN
  cte4 ON cte2.package_id = cte4.package_id
WHERE
  cte1.total_orders > 7
  AND cte2.total_orders > 15
ORDER BY
  cte2.total_revenue DESC;",316,560,876,"['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages']","['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages']","['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages']","['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages']"
169,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    c.customer_email
  FROM 
    ecommerce.orders o
  JOIN 
    ecommerce.customers c ON o.customer_id = c.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
),

cte_order_items AS (
  SELECT 
    oi.order_id,
    oi.product_id,
    oi.quantity,
    oi.unit_price,
    p.product_name,
    p.category_id,
    c.category_name
  FROM 
    ecommerce.order_items oi
  JOIN 
    ecommerce.products p ON oi.product_id = p.product_id
  JOIN 
    ecommerce.categories c ON p.category_id = c.category_id
),

cte_category_sales AS (
  SELECT 
    c.category_name,
    SUM(oi.quantity * oi.unit_price) AS total_sales
  FROM 
    cte_order_items oi
  JOIN 
    cte_orders o ON oi.order_id = o.order_id
  JOIN 
    ecommerce.categories c ON oi.category_id = c.category_id
  GROUP BY 
    c.category_name
),

cte_customer_sales AS (
  SELECT 
    o.customer_id,
    c.customer_name,
    SUM(o.total_price) AS total_sales
  FROM 
    cte_orders o
  JOIN 
    ecommerce.customers c ON o.customer_id = c.customer_id
  GROUP BY 
    o.customer_id,
    c.customer_name
),

cte_top_customers AS (
  SELECT 
    customer_id,
    customer_name,
    total_sales,
    ROW_NUMBER() OVER (ORDER BY total_sales DESC) AS rank
  FROM 
    cte_customer_sales
),

cte_top_categories AS (
  SELECT 
    category_name,
    total_sales,
    ROW_NUMBER() OVER (ORDER BY total_sales DESC) AS rank
  FROM 
    cte_category_sales
),

cte_top_products AS (
  SELECT 
    product_name,
    SUM(quantity) AS total_quantity,
    ROW_NUMBER() OVER (ORDER BY SUM(quantity) DESC) AS rank
  FROM 
    cte_order_items
  GROUP BY 
    product_name
)

SELECT 
  o.order_id,
  o.order_date,
  o.customer_id,
  o.total_price,
  c.customer_name,
  c.customer_email,
  oi.product_id,
  oi.quantity,
  oi.unit_price,
  p.product_name,
  p.category_id,
  c.category_name,
  cs.total_sales AS customer_total_sales,
  cp.total_sales AS category_total_sales,
  tp.total_quantity AS product_total_quantity
FROM 
  cte_orders o
JOIN 
  cte_order_items oi ON o.order_id = oi.order_id
JOIN 
  ecommerce.customers c ON o.customer_id = c.customer_id
JOIN 
  ecommerce.products p ON oi.product_id = p.product_id
JOIN 
  ecommerce.categories c ON p.category_id = c.category_id
JOIN 
  cte_customer_sales cs ON o.customer_id = cs.customer_id
JOIN 
  cte_category_sales cp ON c.category_name = cp.category_name
JOIN 
  cte_top_customers tc ON o.customer_id = tc.customer_id
JOIN 
  cte_top_categories tcat ON c.category_name = tcat.category_name
JOIN 
  cte_top_products tp ON p.product_name = tp.product_name
WHERE 
  tc.rank <= 10
  AND tcat.rank <= 5
  AND tp.rank <= 3
HAVING 
  customer_total_sales > 1000
  AND category_total_sales > 5000
  AND product_total_quantity > 100
CROSS JOIN 
  ecommerce.shipping_methods sm
ORDER BY 
  o.order_date DESC, 
  oi.quantity DESC;",319,791,1110,"['ecommerce.orders', 'ecommerce.customers', 'ecommerce.order_items', 'ecommerce.products', 'ecommerce.categories']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.order_items', 'ecommerce.products', 'ecommerce.categories']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.order_items', 'ecommerce.products', 'ecommerce.categories']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.order_items', 'ecommerce.products', 'ecommerce.categories']"
170,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an entertainment company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    entertainment.company.customers c
  JOIN 
    entertainment.company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
  GROUP BY 
    c.customer_id
  HAVING 
    total_orders >= 3
),
cte2 AS (
  SELECT 
    p.product_name,
    SUM(op.quantity) AS total_quantity
  FROM 
    entertainment.company.products p
  JOIN 
    entertainment.company.order_products op ON p.product_id = op.product_id
  WHERE 
    p.category = 'Movies'
  GROUP BY 
    p.product_id
  HAVING 
    total_quantity > 100
),
cte3 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    entertainment.company.customers c
  JOIN 
    entertainment.company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
  GROUP BY 
    c.customer_id
),
cte4 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    entertainment.company.customers c
  JOIN 
    entertainment.company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
  GROUP BY 
    c.customer_id
),
cte5 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    entertainment.company.customers c
  JOIN 
    entertainment.company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
  GROUP BY 
    c.customer_id
),
cte6 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    entertainment.company.customers c
  JOIN 
    entertainment.company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
  GROUP BY 
    c.customer_id
)
SELECT 
  cte1.customer_name,
  cte2.product_name,
  cte3.total_orders,
  cte4.total_orders,
  cte5.total_orders,
  cte6.total_orders
FROM 
  cte1
JOIN 
  cte2 ON cte1.total_orders = cte2.total_quantity
JOIN 
  cte3 ON cte1.customer_name = cte3.customer_id
JOIN 
  cte4 ON cte1.customer_name = cte4.customer_id
JOIN 
  cte5 ON cte1.customer_name = cte5.customer_id
JOIN 
  cte6 ON cte1.customer_name = cte6.customer_id
ORDER BY 
  cte1.customer_name ASC, 
  cte2.product_name DESC
LIMIT 100;",315,670,985,"['entertainment.company.customers', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.order_products']","['entertainment.company.customers', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.order_products']","['entertainment.company.customers', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.order_products']","['entertainment.company.customers', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.order_products']"
171,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.unit_price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.unit_price) AS total_price
FROM
    sales.customers c
INNER JOIN
    sales.orders o ON c.customer_id = o.customer_id
LEFT JOIN
    inventory.order_products op ON o.order_id = op.order_id
LEFT JOIN
    inventory.products p ON op.product_id = p.product_id
WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
    AND p.category = 'Electronics'
GROUP BY
    c.customer_id,
    o.order_id,
    p.product_id
HAVING
    total_price > 1000
ORDER BY
    total_price DESC;",326,206,532,"['sales.customers', 'sales.orders', 'inventory.order_products', 'inventory.products']","['sales.customers', 'sales.orders', 'inventory.order_products', 'inventory.products']","['sales.customers', 'sales.orders', 'inventory.order_products', 'inventory.products']","['sales.customers', 'sales.orders', 'inventory.order_products', 'inventory.products']"
172,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH
    cte_orders AS (
        SELECT
            o.order_id,
            o.order_date,
            o.customer_id,
            o.total_price
        FROM
            ecommerce.orders o
        WHERE
            o.order_date >= '2021-01-01'
    ),
    cte_customers AS (
        SELECT
            c.customer_id,
            c.customer_name,
            c.city,
            c.state
        FROM
            ecommerce.customers c
    ),
    cte_products AS (
        SELECT
            p.product_id,
            p.product_name,
            p.category,
            p.unit_price
        FROM
            ecommerce.products p
    ),
    cte_order_items AS (
        SELECT
            oi.order_id,
            oi.product_id,
            oi.quantity,
            oi.unit_price
        FROM
            ecommerce.order_items oi
    )
SELECT
    c.customer_name,
    c.city,
    c.state,
    COUNT(DISTINCT o.order_id) AS TotalOrders,
    SUM(oi.quantity) AS TotalItems,
    SUM(oi.quantity * oi.unit_price) AS TotalRevenue
FROM
    cte_customers c
    LEFT JOIN cte_orders o ON c.customer_id = o.customer_id
    LEFT JOIN cte_order_items oi ON o.order_id = oi.order_id
    LEFT JOIN cte_products p ON oi.product_id = p.product_id
WHERE
    p.category = 'Electronics'
    AND o.order_date >= '2021-01-01'
GROUP BY
    c.customer_name,
    c.city,
    c.state
HAVING
    COUNT(DISTINCT o.order_id) > 2
ORDER BY
    TotalRevenue DESC;",319,348,667,"['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products', 'ecommerce.order_items']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products', 'ecommerce.order_items']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products', 'ecommerce.order_items']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products', 'ecommerce.order_items']"
173,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <database>.<schema>.<table> or <database>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a news site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_articles AS (
  SELECT a.article_id, a.title, a.author, a.publish_date, a.category_id, c.category_name
  FROM articles a
  JOIN categories c ON a.category_id = c.category_id
  WHERE a.publish_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)
),
cte_top_articles AS (
  SELECT article_id, title, author, publish_date, category_id, category_name
  FROM cte_articles
  ORDER BY views DESC
  LIMIT 10
),
cte_comments AS (
  SELECT article_id, COUNT(*) AS total_comments
  FROM comments
  GROUP BY article_id
),
cte_avg_rating AS (
  SELECT article_id, AVG(rating) AS avg_rating
  FROM ratings
  GROUP BY article_id
),
cte_author_stats AS (
  SELECT a.author, COUNT(DISTINCT a.article_id) AS total_articles, COUNT(DISTINCT c.comment_id) AS total_comments
  FROM articles a
  LEFT JOIN comments c ON a.article_id = c.article_id
  GROUP BY a.author
),
cte_category_stats AS (
  SELECT c.category_name, COUNT(DISTINCT a.article_id) AS total_articles, SUM(r.total_comments) AS total_comments
  FROM categories c
  LEFT JOIN cte_articles a ON c.category_id = a.category_id
  LEFT JOIN cte_comments r ON a.article_id = r.article_id
  GROUP BY c.category_name
),
cte_monthly_stats AS (
  SELECT DATE_FORMAT(a.publish_date, '%Y-%m') AS month, COUNT(DISTINCT a.article_id) AS total_articles, SUM(r.total_comments) AS total_comments
  FROM cte_articles a
  LEFT JOIN cte_comments r ON a.article_id = r.article_id
  GROUP BY month
),
cte_popular_authors AS (
  SELECT a.author, COUNT(DISTINCT a.article_id) AS total_articles, SUM(r.total_comments) AS total_comments
  FROM cte_articles a
  LEFT JOIN cte_comments r ON a.article_id = r.article_id
  GROUP BY a.author
  HAVING total_articles >= 5 AND total_comments >= 100
),
cte_popular_categories AS (
  SELECT c.category_name, COUNT(DISTINCT a.article_id) AS total_articles, SUM(r.total_comments) AS total_comments
  FROM cte_articles a
  LEFT JOIN cte_comments r ON a.article_id = r.article_id
  GROUP BY c.category_name
  HAVING total_articles >= 10 AND total_comments >= 500
)
SELECT ta.title, ta.author, ta.publish_date, ta.category_name, ta.total_comments, ar.avg_rating, au.total_articles, au.total_comments, cs.total_articles, cs.total_comments, ms.total_articles, ms.total_comments, pa.total_articles, pa.total_comments, pc.total_articles, pc.total_comments
FROM cte_top_articles ta
LEFT JOIN cte_avg_rating ar ON ta.article_id = ar.article_id
LEFT JOIN cte_author_stats au ON ta.author = au.author
LEFT JOIN cte_category_stats cs ON ta.category_name = cs.category_name
LEFT JOIN cte_monthly_stats ms ON DATE_FORMAT(ta.publish_date, '%Y-%m') = ms.month
LEFT JOIN cte_popular_authors pa ON ta.author = pa.author
LEFT JOIN cte_popular_categories pc ON ta.category_name = pc.category_name
ORDER BY ta.publish_date DESC;",319,717,1036,"['articles', 'categories', 'comments', 'ratings']","['articles', 'categories', 'comments', 'ratings']","['articles', 'categories', 'comments', 'ratings']","['articles', 'categories', 'comments', 'ratings']"
174,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH 
    cte_orders AS (
        SELECT 
            o.order_id,
            o.order_date,
            o.customer_id,
            o.total_price
        FROM 
            orders o
        WHERE 
            o.order_date >= '2021-01-01'
    ),
    cte_customers AS (
        SELECT 
            c.customer_id,
            c.customer_name,
            c.city,
            c.state
        FROM 
            customers c
        WHERE 
            c.state = 'California'
    ),
    cte_products AS (
        SELECT 
            p.product_id,
            p.product_name,
            p.category,
            p.unit_price
        FROM 
            products p
        WHERE 
            p.category = 'Electronics'
    ),
    cte_order_items AS (
        SELECT 
            oi.order_id,
            oi.product_id,
            oi.quantity,
            oi.unit_price
        FROM 
            order_items oi
        WHERE 
            oi.quantity >= 5
    )
SELECT 
    c.customer_name,
    c.city,
    c.state,
    COUNT(DISTINCT o.order_id) AS TotalOrders,
    SUM(oi.quantity) AS TotalQuantity,
    SUM(oi.unit_price * oi.quantity) AS TotalRevenue
FROM 
    cte_customers c
JOIN 
    cte_orders o ON c.customer_id = o.customer_id
JOIN 
    cte_order_items oi ON o.order_id = oi.order_id
JOIN 
    cte_products p ON oi.product_id = p.product_id
GROUP BY 
    c.customer_name,
    c.city,
    c.state
HAVING 
    COUNT(DISTINCT o.order_id) > 2
ORDER BY 
    TotalRevenue DESC
LIMIT 10
CROSS JOIN 
    (SELECT 
        MAX(order_date) AS max_order_date
    FROM 
        cte_orders) md;",317,382,699,"['orders', 'customers', 'products', 'order_items']","['orders', 'customers', 'products', 'order_items']","['orders', 'customers', 'products', 'order_items']","['orders', 'customers', 'products', 'order_items']"
175,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.order_total_price) AS total_spent
  FROM
    travel_agency.customers c
  INNER JOIN
    travel_agency.orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'United States'
  GROUP BY
    c.customer_id
  HAVING
    total_spent > 1000
),
subquery1 AS (
  SELECT
    p.package_id,
    p.package_name,
    COUNT(DISTINCT b.booking_id) AS total_bookings
  FROM
    travel_agency.packages p
  LEFT JOIN
    travel_agency.bookings b ON p.package_id = b.package_id
  WHERE
    p.package_price > 500
  GROUP BY
    p.package_id
),
subquery2 AS (
  SELECT
    p.package_id,
    COUNT(DISTINCT b.booking_id) AS total_bookings
  FROM
    travel_agency.packages p
  LEFT JOIN
    travel_agency.bookings b ON p.package_id = b.package_id
  GROUP BY
    p.package_id
),
subquery3 AS (
  SELECT
    p.package_id,
    COUNT(DISTINCT b.booking_id) AS total_bookings
  FROM
    travel_agency.packages p
  LEFT JOIN
    travel_agency.bookings b ON p.package_id = b.package_id
  GROUP BY
    p.package_id
),
subquery4 AS (
  SELECT
    p.package_id,
    COUNT(DISTINCT b.booking_id) AS total_bookings
  FROM
    travel_agency.packages p
  LEFT JOIN
    travel_agency.bookings b ON p.package_id = b.package_id
  GROUP BY
    p.package_id
)
SELECT
  cte.customer_name,
  cte.total_orders,
  cte.total_spent,
  subquery1.package_name,
  subquery1.total_bookings,
  subquery2.total_bookings,
  subquery3.total_bookings,
  subquery4.total_bookings
FROM
  cte
LEFT JOIN
  subquery1 ON cte.total_orders = subquery1.total_bookings
LEFT JOIN
  subquery2 ON cte.total_orders = subquery2.total_bookings
LEFT JOIN
  subquery3 ON cte.total_orders = subquery3.total_bookings
LEFT JOIN
  subquery4 ON cte.total_orders = subquery4.total_bookings
ORDER BY
  cte.total_spent DESC, subquery1.total_bookings ASC
LIMIT
  10;",316,575,891,"['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages', 'travel_agency.bookings']","['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages', 'travel_agency.bookings']","['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages', 'travel_agency.bookings']","['travel_agency.customers', 'travel_agency.orders', 'travel_agency.packages', 'travel_agency.bookings']"
176,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity) AS total_quantity_sold
    FROM
        pharmacy.sales s
    INNER JOIN
        pharmacy.products p ON s.product_id = p.product_id
    WHERE
        s.sale_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_quantity_sold > 100
),
cte2 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity) AS total_quantity_sold,
        AVG(s.unit_price) AS average_unit_price
    FROM
        pharmacy.sales s
    INNER JOIN
        pharmacy.products p ON s.product_id = p.product_id
    WHERE
        s.sale_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_quantity_sold > 100
),
cte3 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity) AS total_quantity_sold,
        AVG(s.unit_price) AS average_unit_price,
        COUNT(DISTINCT s.customer_id) AS unique_customers
    FROM
        pharmacy.sales s
    INNER JOIN
        pharmacy.products p ON s.product_id = p.product_id
    WHERE
        s.sale_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_quantity_sold > 100
),
cte4 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity) AS total_quantity_sold,
        AVG(s.unit_price) AS average_unit_price,
        COUNT(DISTINCT s.customer_id) AS unique_customers,
        CONCAT(p.product_name, ' - ', p.product_category) AS product_description
    FROM
        pharmacy.sales s
    INNER JOIN
        pharmacy.products p ON s.product_id = p.product_id
    WHERE
        s.sale_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_quantity_sold > 100
),
cte5 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity) AS total_quantity_sold,
        AVG(s.unit_price) AS average_unit_price,
        COUNT(DISTINCT s.customer_id) AS unique_customers,
        CONCAT(p.product_name, ' - ', p.product_category) AS product_description,
        UPPER(p.product_category) AS uppercase_category
    FROM
        pharmacy.sales s
    INNER JOIN
        pharmacy.products p ON s.product_id = p.product_id
    WHERE
        s.sale_date >= '2021-01-01'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_quantity_sold > 100
)
SELECT 
    cte1.product_id,
    cte1.product_name,
    cte1.product_category,
    cte1.total_quantity_sold,
    cte2.average_unit_price,
    cte3.unique_customers,
    cte4.product_description,
    cte5.uppercase_category
FROM
    cte1
INNER JOIN
    cte2 ON cte1.product_id = cte2.product_id
INNER JOIN
    cte3 ON cte1.product_id = cte3.product_id
INNER JOIN
    cte4 ON cte1.product_id = cte4.product_id
INNER JOIN
    cte5 ON cte1.product_id = cte5.product_id
ORDER BY
    cte1.total_quantity_sold DESC;",322,822,1144,"['pharmacy.sales', 'pharmacy.products']","['pharmacy.sales', 'pharmacy.products']","['pharmacy.sales', 'pharmacy.products']","['pharmacy.sales', 'pharmacy.products']"
177,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a marketing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price
  FROM
    marketing_db.orders o
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

cte_customers AS (
  SELECT
    c.customer_id,
    c.customer_name,
    c.email,
    c.phone_number,
    c.city,
    c.state
  FROM
    marketing_db.customers c
),

cte_products AS (
  SELECT
    p.product_id,
    p.product_name,
    p.category,
    p.unit_price
  FROM
    marketing_db.products p
),

cte_order_details AS (
  SELECT
    od.order_id,
    od.product_id,
    od.quantity,
    od.unit_price
  FROM
    marketing_db.order_details od
),

cte_sales AS (
  SELECT
    o.order_id,
    o.order_date,
    c.customer_name,
    c.email,
    c.phone_number,
    p.product_name,
    p.category,
    od.quantity,
    od.unit_price,
    (od.quantity * od.unit_price) AS total_amount
  FROM
    cte_orders o
    JOIN cte_customers c ON o.customer_id = c.customer_id
    JOIN cte_order_details od ON o.order_id = od.order_id
    JOIN cte_products p ON od.product_id = p.product_id
),

cte_monthly_sales AS (
  SELECT
    DATE_FORMAT(s.order_date, '%Y-%m') AS month,
    SUM(s.total_amount) AS total_sales
  FROM
    cte_sales s
  GROUP BY
    DATE_FORMAT(s.order_date, '%Y-%m')
),

cte_top_customers AS (
  SELECT
    s.customer_name,
    COUNT(DISTINCT s.order_id) AS total_orders,
    SUM(s.total_amount) AS total_spent
  FROM
    cte_sales s
  GROUP BY
    s.customer_name
  HAVING
    COUNT(DISTINCT s.order_id) >= 5
),

cte_category_stats AS (
  SELECT
    s.category,
    COUNT(DISTINCT s.order_id) AS total_orders,
    AVG(s.quantity) AS avg_quantity,
    AVG(s.unit_price) AS avg_unit_price
  FROM
    cte_sales s
  GROUP BY
    s.category
),

cte_monthly_category_sales AS (
  SELECT
    DATE_FORMAT(s.order_date, '%Y-%m') AS month,
    s.category,
    SUM(s.total_amount) AS total_sales
  FROM
    cte_sales s
  GROUP BY
    DATE_FORMAT(s.order_date, '%Y-%m'),
    s.category
),

cte_monthly_category_sales_ranked AS (
  SELECT
    mcs.month,
    mcs.category,
    mcs.total_sales,
    RANK() OVER (PARTITION BY mcs.month ORDER BY mcs.total_sales DESC) AS sales_rank
  FROM
    cte_monthly_category_sales mcs
),

cte_monthly_top_category AS (
  SELECT
    mcsr.month,
    mcsr.category,
    mcsr.total_sales
  FROM
    cte_monthly_category_sales_ranked mcsr
  WHERE
    mcsr.sales_rank = 1
),

cte_monthly_top_category_sales AS (
  SELECT
    mtc.month,
    mtc.category,
    mtc.total_sales,
    cs.total_orders,
    cs.avg_quantity,
    cs.avg_unit_price
  FROM
    cte_monthly_top_category mtc
    JOIN cte_category_stats cs ON mtc.category = cs.category
),

cte_final_report AS (
  SELECT
    mts.month,
    mts.category,
    mts.total_sales,
    mts.total_orders,
    mts.avg_quantity,
    mts.avg_unit_price,
    tc.customer_name,
    tc.total_orders AS customer_total_orders,
    tc.total_spent
  FROM
    cte_monthly_top_category_sales mts
    JOIN cte_top_customers tc ON mts.month = tc.month
)

SELECT
  fr.month,
  fr.category,
  fr.total_sales,
  fr.total_orders,
  fr.avg_quantity,
  fr.avg_unit_price,
  fr.customer_name,
  fr.customer_total_orders,
  fr.total_spent
FROM
  cte_final_report fr
ORDER BY
  fr.month,
  fr.total_sales DESC;",318,942,1260,"['marketing_db.orders', 'marketing_db.customers', 'marketing_db.products', 'marketing_db.order_details', 'cte_sales', 'cte_monthly_sales', 'cte_top_customers', 'cte_category_stats', 'cte_monthly_category_sales', 'cte_monthly_category_sales_ranked', 'cte_monthly_top_category', 'cte_monthly_top_category_sales', 'cte_final_report']","['marketing_db.orders', 'marketing_db.customers', 'marketing_db.products', 'marketing_db.order_details', 'cte_sales', 'cte_monthly_sales', 'cte_top_customers', 'cte_category_stats', 'cte_monthly_category_sales', 'cte_monthly_category_sales_ranked', 'cte_monthly_top_category', 'cte_monthly_top_category_sales', 'cte_final_report']","['marketing_db.orders', 'marketing_db.customers', 'marketing_db.products', 'marketing_db.order_details', 'cte_sales', 'cte_monthly_sales', 'cte_top_customers', 'cte_category_stats', 'cte_monthly_category_sales', 'cte_monthly_category_sales_ranked', 'cte_monthly_top_category', 'cte_monthly_top_category_sales', 'cte_final_report']","['marketing_db.orders', 'marketing_db.customers', 'marketing_db.products', 'marketing_db.order_details', 'cte_sales', 'cte_monthly_sales', 'cte_top_customers', 'cte_category_stats', 'cte_monthly_category_sales', 'cte_monthly_category_sales_ranked', 'cte_monthly_top_category', 'cte_monthly_top_category_sales', 'cte_final_report']"
178,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH sales AS (
  SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.product_id,
    o.quantity,
    o.unit_price,
    o.total_price
  FROM
    orders o
  JOIN
    customers c ON o.customer_id = c.customer_id
  WHERE
    c.country = 'USA'
),
revenue AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    SUM(total_price) AS monthly_revenue
  FROM
    sales
  GROUP BY
    DATE_FORMAT(order_date, '%Y-%m')
),
top_products AS (
  SELECT
    p.product_id,
    p.product_name,
    SUM(s.quantity) AS total_quantity
  FROM
    products p
  JOIN
    sales s ON p.product_id = s.product_id
  GROUP BY
    p.product_id,
    p.product_name
  HAVING
    total_quantity > 100
),
customer_stats AS (
  SELECT
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) AS full_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_price) AS total_spent
  FROM
    customers c
  JOIN
    orders o ON c.customer_id = o.customer_id
  GROUP BY
    c.customer_id,
    full_name
  HAVING
    total_orders > 5
),
final_query AS (
  SELECT
    c.customer_id,
    c.full_name,
    c.total_orders,
    c.total_spent,
    r.month,
    r.monthly_revenue,
    tp.product_name,
    tp.total_quantity
  FROM
    customer_stats c
  JOIN
    revenue r ON c.customer_id = r.customer_id
  JOIN
    top_products tp ON c.customer_id = tp.customer_id
)
SELECT
  customer_id,
  full_name,
  total_orders,
  total_spent,
  month,
  monthly_revenue,
  product_name,
  total_quantity
FROM
  final_query
ORDER BY
  total_spent DESC,
  total_quantity DESC,
  month ASC
LIMIT
  100;",315,454,769,"['orders', 'customers', 'products']","['orders', 'customers', 'products']","['orders', 'customers', 'products']","['orders', 'customers', 'products']"
179,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
         CONCAT(p.first_name, ' ', p.last_name) AS full_name,
         CASE WHEN p.gender = 'M' THEN 'Male' ELSE 'Female' END AS gender_description
  FROM patients p
  WHERE p.date_of_birth >= '1980-01-01'
),
cte2 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(d.first_name, ' ', d.last_name) AS doctor_name,
         CONCAT(p.first_name, ' ', p.last_name) AS patient_name
  FROM appointments a
  INNER JOIN doctors d ON a.doctor_id = d.doctor_id
  INNER JOIN patients p ON a.patient_id = p.patient_id
  WHERE a.appointment_date >= CURDATE()
),
cte3 AS (
  SELECT a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
         CONCAT(d.first_name, ' ', d.last_name) AS doctor_name,
         CONCAT(p.first_name, ' ', p.last_name) AS patient_name,
         COUNT(*) AS total_prescriptions
  FROM appointments a
  INNER JOIN doctors d ON a.doctor_id = d.doctor_id
  INNER JOIN patients p ON a.patient_id = p.patient_id
  INNER JOIN prescriptions pr ON a.appointment_id = pr.appointment_id
  WHERE a.appointment_date >= CURDATE()
  GROUP BY a.appointment_id, a.patient_id, a.appointment_date, a.appointment_time, a.doctor_id, 
           CONCAT(d.first_name, ' ', d.last_name), CONCAT(p.first_name, ' ', p.last_name)
),
cte4 AS (
  SELECT p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
         CONCAT(p.first_name, ' ', p.last_name) AS full_name,
         CASE WHEN p.gender = 'M' THEN 'Male' ELSE 'Female' END AS gender_description,
         COUNT(*) AS total_appointments
  FROM patients p
  INNER JOIN appointments a ON p.patient_id = a.patient_id
  WHERE a.appointment_date >= CURDATE()
  GROUP BY p.patient_id, p.patient_name, p.date_of_birth, p.gender, p.address, p.phone_number, 
           CONCAT(p.first_name, ' ', p.last_name), CASE WHEN p.gender = 'M' THEN 'Male' ELSE 'Female' END
)
SELECT cte1.patient_id, cte1.patient_name, cte1.date_of_birth, cte1.gender, cte1.address, cte1.phone_number, 
       cte1.full_name, cte1.gender_description, cte4.total_appointments, cte3.total_prescriptions
FROM cte1
LEFT JOIN cte4 ON cte1.patient_id = cte4.patient_id
LEFT JOIN cte3 ON cte1.patient_id = cte3.patient_id
WHERE cte1.gender = 'F'
HAVING cte4.total_appointments > 5
ORDER BY cte1.patient_name ASC;",315,685,1000,"['patients', 'appointments', 'doctors', 'prescriptions']","['patients', 'appointments', 'doctors', 'prescriptions']","['patients', 'appointments', 'doctors', 'prescriptions']","['patients', 'appointments', 'doctors', 'prescriptions']"
180,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_sales AS (
  SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    p.product_name,
    p.category,
    p.unit_price,
    od.quantity
  FROM
    sales.orders o
  INNER JOIN
    sales.customers c ON o.customer_id = c.customer_id
  LEFT JOIN
    sales.order_details od ON o.order_id = od.order_id
  LEFT JOIN
    inventory.products p ON od.product_id = p.product_id
  WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
    AND p.category IN ('Electronics', 'Clothing')
),
cte_category_sales AS (
  SELECT
    category,
    SUM(total_price) AS total_sales
  FROM
    cte_sales
  GROUP BY
    category
),
cte_top_customers AS (
  SELECT
    customer_id,
    customer_name,
    SUM(total_price) AS total_spent
  FROM
    cte_sales
  GROUP BY
    customer_id,
    customer_name
  HAVING
    total_spent > (
      SELECT
        AVG(total_spent)
      FROM
        cte_top_customers
    )
),
cte_monthly_sales AS (
  SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    SUM(total_price) AS monthly_revenue
  FROM
    cte_sales
  GROUP BY
    month
),
cte_product_sales AS (
  SELECT
    product_name,
    COUNT(DISTINCT order_id) AS unique_orders,
    SUM(quantity) AS total_quantity
  FROM
    cte_sales
  GROUP BY
    product_name
  HAVING
    total_quantity > (
      SELECT
        AVG(total_quantity)
      FROM
        cte_product_sales
    )
)
SELECT
  c.category,
  c.total_sales,
  tc.customer_name,
  tc.total_spent,
  ms.month,
  ms.monthly_revenue,
  ps.product_name,
  ps.unique_orders,
  ps.total_quantity
FROM
  cte_category_sales c
INNER JOIN
  cte_top_customers tc ON c.category = tc.category
INNER JOIN
  cte_monthly_sales ms ON tc.customer_id = ms.customer_id
LEFT JOIN
  cte_product_sales ps ON ms.month = ps.month
ORDER BY
  c.total_sales DESC,
  tc.total_spent DESC,
  ms.monthly_revenue DESC,
  ps.total_quantity DESC
LIMIT 100;",318,545,863,"['sales.orders', 'sales.customers', 'sales.order_details', 'inventory.products']","['sales.orders', 'sales.customers', 'sales.order_details', 'inventory.products']","['sales.orders', 'sales.customers', 'sales.order_details', 'inventory.products']","['sales.orders', 'sales.customers', 'sales.order_details', 'inventory.products']"
181,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(o.order_id) AS total_orders
  FROM
    customers c
  INNER JOIN
    orders o ON c.customer_id = o.customer_id
  WHERE
    c.customer_country = 'USA'
  GROUP BY
    c.customer_id
  HAVING
    total_orders > 5
),
subquery1 AS (
  SELECT
    p.product_name,
    SUM(op.quantity) AS total_quantity
  FROM
    products p
  INNER JOIN
    order_products op ON p.product_id = op.product_id
  WHERE
    p.product_category = 'Flights'
  GROUP BY
    p.product_id
),
subquery2 AS (
  SELECT
    a.airline_name,
    COUNT(DISTINCT f.flight_id) AS total_flights
  FROM
    airlines a
  INNER JOIN
    flights f ON a.airline_id = f.airline_id
  WHERE
    f.flight_status = 'On Time'
  GROUP BY
    a.airline_id
),
subquery3 AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(DISTINCT b.booking_id) AS total_bookings
  FROM
    customers c
  INNER JOIN
    bookings b ON c.customer_id = b.customer_id
  WHERE
    b.booking_status = 'Confirmed'
  GROUP BY
    c.customer_id
),
subquery4 AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(DISTINCT h.hotel_id) AS total_hotels
  FROM
    customers c
  INNER JOIN
    hotel_bookings hb ON c.customer_id = hb.customer_id
  INNER JOIN
    hotels h ON hb.hotel_id = h.hotel_id
  WHERE
    hb.booking_status = 'Confirmed'
  GROUP BY
    c.customer_id
)
SELECT
  cte.customer_name,
  cte.total_orders,
  subquery1.total_quantity,
  subquery2.total_flights,
  subquery3.total_bookings,
  subquery4.total_hotels
FROM
  cte
CROSS JOIN
  subquery1
CROSS JOIN
  subquery2
CROSS JOIN
  subquery3
CROSS JOIN
  subquery4;",316,513,829,"['customers', 'orders', 'products', 'order_products', 'airlines', 'flights', 'bookings', 'hotel_bookings', 'hotels']","['customers', 'orders', 'products', 'order_products', 'airlines', 'flights', 'bookings', 'hotel_bookings', 'hotels']","['customers', 'orders', 'products', 'order_products', 'airlines', 'flights', 'bookings', 'hotel_bookings', 'hotels']","['customers', 'orders', 'products', 'order_products', 'airlines', 'flights', 'bookings', 'hotel_bookings', 'hotels']"
182,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity) AS total_quantity_sold
    FROM
        products p
    INNER JOIN
        sales s ON p.product_id = s.product_id
    WHERE
        p.product_category = 'Medicine'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_quantity_sold > 100
),
cte2 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity) AS total_quantity_sold
    FROM
        products p
    INNER JOIN
        sales s ON p.product_id = s.product_id
    WHERE
        p.product_category = 'Vitamins'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_quantity_sold > 50
),
cte3 AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        SUM(s.quantity) AS total_quantity_sold
    FROM
        products p
    INNER JOIN
        sales s ON p.product_id = s.product_id
    WHERE
        p.product_category = 'Supplements'
    GROUP BY
        p.product_id,
        p.product_name,
        p.product_category
    HAVING
        total_quantity_sold > 30
)
SELECT 
    cte1.product_id,
    cte1.product_name,
    cte1.product_category,
    cte1.total_quantity_sold AS total_quantity_sold_medicine,
    cte2.total_quantity_sold AS total_quantity_sold_vitamins,
    cte3.total_quantity_sold AS total_quantity_sold_supplements
FROM
    cte1
LEFT JOIN
    cte2 ON cte1.product_id = cte2.product_id
LEFT JOIN
    cte3 ON cte1.product_id = cte3.product_id
ORDER BY
    cte1.product_id;",313,425,738,"['products', 'sales']","['products', 'sales']","['products', 'sales']","['products', 'sales']"
183,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT order_id) AS total_orders
    FROM 
        customers
    WHERE 
        registration_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
    HAVING 
        total_orders >= 5
),
cte2 AS (
    SELECT 
        customer_id,
        SUM(total_price) AS total_spent
    FROM 
        orders
    WHERE 
        order_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
),
cte3 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT call_id) AS total_calls
    FROM 
        calls
    WHERE 
        call_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
),
cte4 AS (
    SELECT 
        customer_id,
        AVG(data_usage) AS avg_data_usage
    FROM 
        data_usage
    WHERE 
        usage_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
),
cte5 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT sms_id) AS total_sms
    FROM 
        sms
    WHERE 
        sms_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
),
cte6 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT complaint_id) AS total_complaints
    FROM 
        complaints
    WHERE 
        complaint_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
),
cte7 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT payment_id) AS total_payments
    FROM 
        payments
    WHERE 
        payment_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
),
cte8 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT device_id) AS total_devices
    FROM 
        devices
    WHERE 
        purchase_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
),
cte9 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT subscription_id) AS total_subscriptions
    FROM 
        subscriptions
    WHERE 
        subscription_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
),
cte10 AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT network_id) AS total_networks
    FROM 
        networks
    WHERE 
        network_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
    GROUP BY 
        customer_id
)
SELECT 
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    c.phone_number,
    c.address,
    c.city,
    c.state,
    c.country,
    cte1.total_orders,
    cte2.total_spent,
    cte3.total_calls,
    cte4.avg_data_usage,
    cte5.total_sms,
    cte6.total_complaints,
    cte7.total_payments,
    cte8.total_devices,
    cte9.total_subscriptions,
    cte10.total_networks
FROM 
    customers c
LEFT JOIN 
    cte1 ON c.customer_id = cte1.customer_id
LEFT JOIN 
    cte2 ON c.customer_id = cte2.customer_id
LEFT JOIN 
    cte3 ON c.customer_id = cte3.customer_id
LEFT JOIN 
    cte4 ON c.customer_id = cte4.customer_id
LEFT JOIN 
    cte5 ON c.customer_id = cte5.customer_id
LEFT JOIN 
    cte6 ON c.customer_id = cte6.customer_id
LEFT JOIN 
    cte7 ON c.customer_id = cte7.customer_id
LEFT JOIN 
    cte8 ON c.customer_id = cte8.customer_id
LEFT JOIN 
    cte9 ON c.customer_id = cte9.customer_id
LEFT JOIN 
    cte10 ON c.customer_id = cte10.customer_id
WHERE 
    c.registration_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
ORDER BY 
    c.customer_id;",316,913,1229,"['customers', 'orders', 'calls', 'data_usage', 'sms', 'complaints', 'payments', 'devices', 'subscriptions', 'networks']","['customers', 'orders', 'calls', 'data_usage', 'sms', 'complaints', 'payments', 'devices', 'subscriptions', 'networks']","['customers', 'orders', 'calls', 'data_usage', 'sms', 'complaints', 'payments', 'devices', 'subscriptions', 'networks']","['customers', 'orders', 'calls', 'data_usage', 'sms', 'complaints', 'payments', 'devices', 'subscriptions', 'networks']"
184,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an entertainment company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    entertainment.company.customers c
  INNER JOIN 
    entertainment.company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY 
    c.customer_id
  HAVING 
    total_orders >= 5
),
cte2 AS (
  SELECT 
    p.product_name,
    COUNT(DISTINCT op.order_id) AS total_orders
  FROM 
    entertainment.company.products p
  INNER JOIN 
    entertainment.company.order_products op ON p.product_id = op.product_id
  INNER JOIN 
    entertainment.company.orders o ON op.order_id = o.order_id
  WHERE 
    o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY 
    p.product_id
  HAVING 
    total_orders >= 10
),
cte3 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    entertainment.company.customers c
  INNER JOIN 
    entertainment.company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY 
    c.customer_id
  HAVING 
    total_orders >= 5
),
cte4 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    entertainment.company.customers c
  INNER JOIN 
    entertainment.company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY 
    c.customer_id
  HAVING 
    total_orders >= 5
),
cte5 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    entertainment.company.customers c
  INNER JOIN 
    entertainment.company.orders o ON c.customer_id = o.customer_id
  WHERE 
    o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
  GROUP BY 
    c.customer_id
  HAVING 
    total_orders >= 5
)
SELECT 
  cte1.customer_name,
  cte2.product_name,
  cte3.total_orders,
  cte4.total_orders,
  cte5.total_orders
FROM 
  cte1
INNER JOIN 
  cte2 ON cte1.customer_name = cte2.product_name
INNER JOIN 
  cte3 ON cte1.customer_name = cte3.customer_id
INNER JOIN 
  cte4 ON cte1.customer_name = cte4.customer_id
INNER JOIN 
  cte5 ON cte1.customer_name = cte5.customer_id
WHERE 
  cte1.total_orders >= 5
  AND cte2.total_orders >= 10
  AND cte3.total_orders >= 5
  AND cte4.total_orders >= 5
  AND cte5.total_orders >= 5
GROUP BY 
  cte1.customer_name,
  cte2.product_name,
  cte3.total_orders,
  cte4.total_orders,
  cte5.total_orders
HAVING 
  SUM(cte3.total_orders) > 20
  AND AVG(cte4.total_orders) < 10
  AND COUNT(cte5.total_orders) = 5
ORDER BY 
  cte1.customer_name ASC,
  cte2.product_name DESC,
  cte3.total_orders ASC,
  cte4.total_orders DESC,
  cte5.total_orders ASC
LIMIT 100;",315,808,1123,"['entertainment.company.customers', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.order_products']","['entertainment.company.customers', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.order_products']","['entertainment.company.customers', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.order_products']","['entertainment.company.customers', 'entertainment.company.orders', 'entertainment.company.products', 'entertainment.company.order_products']"
185,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.unit_price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.unit_price) AS total_price
FROM
    shop.customers c
JOIN
    shop.orders o ON c.customer_id = o.customer_id
JOIN
    shop.order_products op ON o.order_id = op.order_id
JOIN
    shop.products p ON op.product_id = p.product_id
WHERE
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
    AND p.category = 'Electronics'
GROUP BY
    c.customer_id,
    o.order_id,
    p.product_id
HAVING
    total_price > 1000
ORDER BY
    total_price DESC;",323,203,526,"['shop.customers', 'shop.orders', 'shop.order_products', 'shop.products']","['shop.customers', 'shop.orders', 'shop.order_products', 'shop.products']","['shop.customers', 'shop.orders', 'shop.order_products', 'shop.products']","['shop.customers', 'shop.orders', 'shop.order_products', 'shop.products']"
186,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an education institution.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(students.first_name, ' ', students.last_name) AS full_name,
    courses.course_name,
    COUNT(enrollments.student_id) AS total_enrollments,
    AVG(grades.grade) AS average_grade,
    CONCAT(teachers.first_name, ' ', teachers.last_name) AS teacher_name,
    departments.department_name,
    SUM(payments.amount) AS total_payments
FROM 
    education_db.students
INNER JOIN 
    education_db.enrollments ON students.student_id = enrollments.student_id
LEFT JOIN 
    education_db.courses ON enrollments.course_id = courses.course_id
LEFT JOIN 
    education_db.grades ON enrollments.enrollment_id = grades.enrollment_id
LEFT JOIN 
    education_db.teachers ON courses.teacher_id = teachers.teacher_id
LEFT JOIN 
    education_db.departments ON courses.department_id = departments.department_id
LEFT JOIN 
    education_db.payments ON students.student_id = payments.student_id
WHERE 
    students.graduation_year = 2022
    AND courses.course_level = 'Advanced'
    AND grades.grade >= 80
    AND departments.department_name = 'Computer Science'
GROUP BY 
    students.student_id,
    courses.course_id,
    teachers.teacher_id,
    departments.department_id
HAVING 
    total_enrollments > 5
ORDER BY 
    total_payments DESC;",322,278,600,"['education_db.students', 'education_db.enrollments', 'education_db.courses', 'education_db.grades', 'education_db.teachers', 'education_db.departments', 'education_db.payments']","['education_db.students', 'education_db.enrollments', 'education_db.courses', 'education_db.grades', 'education_db.teachers', 'education_db.departments', 'education_db.payments']","['education_db.students', 'education_db.enrollments', 'education_db.courses', 'education_db.grades', 'education_db.teachers', 'education_db.departments', 'education_db.payments']","['education_db.students', 'education_db.enrollments', 'education_db.courses', 'education_db.grades', 'education_db.teachers', 'education_db.departments', 'education_db.payments']"
187,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a marketing company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    o.order_id,
    o.order_date,
    o.total_price
  FROM
    marketing.customers c
  INNER JOIN
    marketing.orders o ON c.customer_id = o.customer_id
  WHERE
    o.order_status = 'completed'
    AND o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
),

cte2 AS (
  SELECT
    cte1.customer_name,
    COUNT(DISTINCT cte1.order_id) AS total_orders,
    SUM(cte1.total_price) AS total_sales
  FROM
    cte1
  GROUP BY
    cte1.customer_name
  HAVING
    total_sales > 10000
),

cte3 AS (
  SELECT
    cte2.customer_name,
    COUNT(DISTINCT p.product_id) AS total_products
  FROM
    cte2
  LEFT JOIN
    marketing.order_items oi ON cte2.order_id = oi.order_id
  LEFT JOIN
    marketing.products p ON oi.product_id = p.product_id
  GROUP BY
    cte2.customer_name
),

cte4 AS (
  SELECT
    cte3.customer_name,
    AVG(cte3.total_products) AS avg_products
  FROM
    cte3
  GROUP BY
    cte3.customer_name
),

cte5 AS (
  SELECT
    cte4.customer_name,
    CASE
      WHEN cte4.avg_products > 5 THEN 'High'
      WHEN cte4.avg_products > 3 THEN 'Medium'
      ELSE 'Low'
    END AS customer_segment
  FROM
    cte4
),

cte6 AS (
  SELECT
    cte5.customer_name,
    cte5.customer_segment,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_price) AS total_sales
  FROM
    cte5
  LEFT JOIN
    marketing.orders o ON cte5.customer_name = CONCAT(o.customer_first_name, ' ', o.customer_last_name)
  GROUP BY
    cte5.customer_name,
    cte5.customer_segment
),

cte7 AS (
  SELECT
    cte6.customer_segment,
    COUNT(DISTINCT cte6.customer_name) AS total_customers,
    SUM(cte6.total_orders) AS total_orders,
    SUM(cte6.total_sales) AS total_sales
  FROM
    cte6
  GROUP BY
    cte6.customer_segment
),

cte8 AS (
  SELECT
    cte7.customer_segment,
    cte7.total_customers,
    cte7.total_orders,
    cte7.total_sales,
    ROW_NUMBER() OVER (ORDER BY cte7.total_sales DESC) AS segment_rank
  FROM
    cte7
),

cte9 AS (
  SELECT
    cte8.customer_segment,
    cte8.total_customers,
    cte8.total_orders,
    cte8.total_sales,
    CASE
      WHEN cte8.segment_rank <= 3 THEN 'Top'
      ELSE 'Other'
    END AS segment_category
  FROM
    cte8
),

cte10 AS (
  SELECT
    cte9.segment_category,
    COUNT(DISTINCT cte9.customer_segment) AS total_segments,
    SUM(cte9.total_customers) AS total_customers,
    SUM(cte9.total_orders) AS total_orders,
    SUM(cte9.total_sales) AS total_sales
  FROM
    cte9
  GROUP BY
    cte9.segment_category
),

cte11 AS (
  SELECT
    cte10.segment_category,
    cte10.total_segments,
    cte10.total_customers,
    cte10.total_orders,
    cte10.total_sales,
    CASE
      WHEN cte10.segment_category = 'Top' THEN 'High'
      ELSE 'Low'
    END AS category_priority
  FROM
    cte10
),

cte12 AS (
  SELECT
    cte11.segment_category,
    cte11.total_segments,
    cte11.total_customers,
    cte11.total_orders,
    cte11.total_sales,
    cte11.category_priority,
    ROW_NUMBER() OVER (ORDER BY cte11.total_sales DESC) AS category_rank
  FROM
    cte11
),

cte13 AS (
  SELECT
    cte12.segment_category,
    cte12.total_segments,
    cte12.total_customers,
    cte12.total_orders,
    cte12.total_sales,
    cte12.category_priority
  FROM
    cte12
  WHERE
    cte12.category_rank <= 2
),

cte14 AS (
  SELECT
    cte13.segment_category,
    cte13.total_segments,
    cte13.total_customers,
    cte13.total_orders,
    cte13.total_sales,
    cte13.category_priority
  FROM
    cte13
  UNION ALL
  SELECT
    'Other' AS segment_category,
    COUNT(DISTINCT cte13.segment_category) AS total_segments,
    SUM(cte13.total_customers) AS total_customers,
    SUM(cte13.total_orders) AS total_orders,
    SUM(cte13.total_sales) AS total_sales,
    'Low' AS category_priority
  FROM
    cte13
),

cte15 AS (
  SELECT
    cte14.segment_category,
    cte14.total_segments,
    cte14.total_customers,
    cte14.total_orders,
    cte14.total_sales,
    cte14.category_priority,
    ROW_NUMBER() OVER (ORDER BY cte14.total_sales DESC) AS category_rank
  FROM
    cte14
),

cte16 AS (
  SELECT
    cte15.segment_category,
    cte15.total_segments,
    cte15.total_customers,
    cte15.total_orders,
    cte15.total_sales,
    cte15.category_priority
  FROM
    cte15
  WHERE
    cte15.category_rank <= 3
)

SELECT
  cte16.segment_category,
  cte16.total_segments,
  cte16.total_customers,
  cte16.total_orders,
  cte16.total_sales,
  cte16.category_priority
FROM
  cte16;",321,1353,1674,"['marketing.customers', 'marketing.orders', 'marketing.order_items', 'marketing.products']","['marketing.customers', 'marketing.orders', 'marketing.order_items', 'marketing.products']","['marketing.customers', 'marketing.orders', 'marketing.order_items', 'marketing.products']","['marketing.customers', 'marketing.orders', 'marketing.order_items', 'marketing.products']"
188,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.price) AS total_price
FROM 
    kusto_ecommerce.orders o
JOIN 
    kusto_ecommerce.customers c ON o.customer_id = c.customer_id
JOIN 
    kusto_ecommerce.order_products op ON o.order_id = op.order_id
JOIN 
    kusto_ecommerce.products p ON op.product_id = p.product_id
WHERE 
    o.order_status = 'completed'
    AND YEAR(o.order_date) = 2022
    AND p.category = 'Electronics'
GROUP BY 
    c.first_name,
    c.last_name,
    o.order_id,
    o.order_date,
    p.product_name,
    p.price
HAVING 
    total_quantity > 5
ORDER BY 
    total_price DESC;",320,223,543,"['kusto_ecommerce.orders', 'kusto_ecommerce.customers', 'kusto_ecommerce.order_products', 'kusto_ecommerce.products']","['kusto_ecommerce.orders', 'kusto_ecommerce.customers', 'kusto_ecommerce.order_products', 'kusto_ecommerce.products']","['kusto_ecommerce.orders', 'kusto_ecommerce.customers', 'kusto_ecommerce.order_products', 'kusto_ecommerce.products']","['kusto_ecommerce.orders', 'kusto_ecommerce.customers', 'kusto_ecommerce.order_products', 'kusto_ecommerce.products']"
189,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a logistics company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte_orders AS (
  SELECT 
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_price,
    c.customer_name,
    c.customer_address
  FROM 
    logistics.orders o
  JOIN 
    logistics.customers c ON o.customer_id = c.customer_id
  WHERE 
    o.order_date >= '2021-01-01'
    AND o.order_date <= '2021-12-31'
),

cte_shipments AS (
  SELECT 
    s.shipment_id,
    s.order_id,
    s.shipment_date,
    s.shipment_status,
    s.carrier_id,
    c.carrier_name,
    c.carrier_address
  FROM 
    logistics.shipments s
  JOIN 
    logistics.carriers c ON s.carrier_id = c.carrier_id
),

cte_products AS (
  SELECT 
    p.product_id,
    p.product_name,
    p.product_category,
    p.product_price,
    p.product_weight
  FROM 
    logistics.products p
),

cte_order_items AS (
  SELECT 
    oi.order_id,
    oi.product_id,
    oi.quantity,
    oi.unit_price,
    oi.discount
  FROM 
    logistics.order_items oi
),

cte_shipment_items AS (
  SELECT 
    si.shipment_id,
    si.product_id,
    si.quantity
  FROM 
    logistics.shipment_items si
),

cte_total_sales AS (
  SELECT 
    o.customer_id,
    SUM(o.total_price) AS total_sales
  FROM 
    cte_orders o
  GROUP BY 
    o.customer_id
),

cte_average_weight AS (
  SELECT 
    p.product_category,
    AVG(p.product_weight) AS average_weight
  FROM 
    cte_products p
  GROUP BY 
    p.product_category
),

cte_shipment_status_count AS (
  SELECT 
    s.shipment_status,
    COUNT(s.shipment_id) AS shipment_count
  FROM 
    cte_shipments s
  GROUP BY 
    s.shipment_status
),

cte_customer_orders AS (
  SELECT 
    o.customer_id,
    COUNT(o.order_id) AS order_count
  FROM 
    cte_orders o
  GROUP BY 
    o.customer_id
),

cte_top_customers AS (
  SELECT 
    ts.customer_id,
    ts.total_sales,
    co.order_count
  FROM 
    cte_total_sales ts
  JOIN 
    cte_customer_orders co ON ts.customer_id = co.customer_id
  WHERE 
    co.order_count > 5
),

cte_shipment_summary AS (
  SELECT 
    s.carrier_id,
    cs.shipment_status,
    COUNT(s.shipment_id) AS shipment_count
  FROM 
    cte_shipments s
  JOIN 
    cte_shipment_status_count cs ON s.shipment_status = cs.shipment_status
  GROUP BY 
    s.carrier_id,
    cs.shipment_status
),

cte_product_summary AS (
  SELECT 
    p.product_category,
    COUNT(DISTINCT p.product_id) AS product_count,
    SUM(oi.quantity) AS total_quantity
  FROM 
    cte_products p
  JOIN 
    cte_order_items oi ON p.product_id = oi.product_id
  GROUP BY 
    p.product_category
),

cte_shipment_product_summary AS (
  SELECT 
    sps.carrier_id,
    ps.product_category,
    sps.shipment_status,
    SUM(si.quantity) AS total_quantity
  FROM 
    cte_shipment_summary sps
  JOIN 
    cte_shipment_items si ON sps.shipment_id = si.shipment_id
  JOIN 
    cte_products p ON si.product_id = p.product_id
  JOIN 
    cte_product_summary ps ON p.product_category = ps.product_category
  GROUP BY 
    sps.carrier_id,
    ps.product_category,
    sps.shipment_status
)

SELECT 
  c.customer_name,
  c.customer_address,
  o.order_date,
  o.total_price,
  s.shipment_date,
  s.shipment_status,
  p.product_name,
  p.product_category,
  p.product_price,
  p.product_weight,
  oi.quantity,
  oi.unit_price,
  oi.discount,
  ts.total_sales,
  aw.average_weight,
  cs.shipment_count,
  co.order_count,
  tcs.total_sales,
  ss.shipment_count,
  ps.product_count,
  ps.total_quantity,
  sps.total_quantity
FROM 
  cte_orders o
JOIN 
  cte_customers c ON o.customer_id = c.customer_id
JOIN 
  cte_shipments s ON o.order_id = s.order_id
JOIN 
  cte_products p ON s.product_id = p.product_id
JOIN 
  cte_order_items oi ON o.order_id = oi.order_id
JOIN 
  cte_total_sales ts ON o.customer_id = ts.customer_id
JOIN 
  cte_average_weight aw ON p.product_category = aw.product_category
JOIN 
  cte_shipment_status_count cs ON s.shipment_status = cs.shipment_status
JOIN 
  cte_customer_orders co ON o.customer_id = co.customer_id
JOIN 
  cte_top_customers tcs ON ts.customer_id = tcs.customer_id
JOIN 
  cte_shipment_summary ss ON s.carrier_id = ss.carrier_id
JOIN 
  cte_product_summary ps ON p.product_category = ps.product_category
JOIN 
  cte_shipment_product_summary sps ON s.carrier_id = sps.carrier_id
    AND p.product_category = sps.product_category
    AND s.shipment_status = sps.shipment_status;",315,1192,1507,"['logistics.orders', 'logistics.customers', 'logistics.shipments', 'logistics.carriers', 'logistics.products', 'logistics.order_items', 'logistics.shipment_items']","['logistics.orders', 'logistics.customers', 'logistics.shipments', 'logistics.carriers', 'logistics.products', 'logistics.order_items', 'logistics.shipment_items']","['logistics.orders', 'logistics.customers', 'logistics.shipments', 'logistics.carriers', 'logistics.products', 'logistics.order_items', 'logistics.shipment_items']","['logistics.orders', 'logistics.customers', 'logistics.shipments', 'logistics.carriers', 'logistics.products', 'logistics.order_items', 'logistics.shipment_items']"
190,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte1 AS (
  SELECT 
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    customers c
  INNER JOIN 
    orders o ON c.customer_id = o.customer_id
  WHERE 
    c.customer_city = 'New York'
  GROUP BY 
    c.customer_id, c.customer_first_name, c.customer_last_name
  HAVING 
    total_orders > 5
),
cte2 AS (
  SELECT 
    p.product_name,
    SUM(op.quantity) AS total_quantity
  FROM 
    products p
  INNER JOIN 
    order_products op ON p.product_id = op.product_id
  WHERE 
    p.product_category = 'Electronics'
  GROUP BY 
    p.product_id, p.product_name
  HAVING 
    total_quantity > 100
),
cte3 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    customers c
  INNER JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
),
cte4 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    customers c
  INNER JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
),
cte5 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    customers c
  INNER JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
),
cte6 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    customers c
  INNER JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
),
cte7 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    customers c
  INNER JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
),
cte8 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    customers c
  INNER JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
),
cte9 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    customers c
  INNER JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
),
cte10 AS (
  SELECT 
    c.customer_id,
    COUNT(DISTINCT o.order_id) AS total_orders
  FROM 
    customers c
  INNER JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
)
SELECT 
  cte1.customer_name,
  cte2.product_name,
  cte3.total_orders,
  cte4.total_orders,
  cte5.total_orders,
  cte6.total_orders,
  cte7.total_orders,
  cte8.total_orders,
  cte9.total_orders,
  cte10.total_orders
FROM 
  cte1
INNER JOIN 
  cte2 ON cte1.total_orders = cte2.total_quantity
CROSS JOIN 
  cte3
CROSS JOIN 
  cte4
CROSS JOIN 
  cte5
CROSS JOIN 
  cte6
CROSS JOIN 
  cte7
CROSS JOIN 
  cte8
CROSS JOIN 
  cte9
CROSS JOIN 
  cte10;",321,832,1153,"['customers', 'orders', 'products', 'order_products']","['customers', 'orders', 'products', 'order_products']","['customers', 'orders', 'products', 'order_products']","['customers', 'orders', 'products', 'order_products']"
191,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like kusto's <database>['|'].<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of a long list of JOIN operations on the tables. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query and include a Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a travel agency.

The resulting output should strictly be the SQL query without any surrounding text.","WITH cte AS (
  SELECT
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
    COUNT(o.order_id) AS total_orders
  FROM
    kusto.travel['|'].customers c
  JOIN
    kusto.travel['|'].orders o ON c.customer_id = o.customer_id
  WHERE
    o.order_date >= DATE_FORMAT(CURRENT_DATE(), '%Y-%m-01')
  GROUP BY
    c.customer_id
  HAVING
    COUNT(o.order_id) > 5
),
subquery1 AS (
  SELECT
    t.ticket_id,
    t.ticket_price,
    t.ticket_type,
    t.ticket_date,
    t.ticket_status,
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name
  FROM
    kusto.travel['|'].tickets t
  JOIN
    kusto.travel['|'].customers c ON t.customer_id = c.customer_id
  WHERE
    t.ticket_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
),
subquery2 AS (
  SELECT
    t.ticket_id,
    t.ticket_price,
    t.ticket_type,
    t.ticket_date,
    t.ticket_status,
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name
  FROM
    kusto.travel['|'].tickets t
  JOIN
    kusto.travel['|'].customers c ON t.customer_id = c.customer_id
  WHERE
    t.ticket_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 60 DAY)
),
subquery3 AS (
  SELECT
    t.ticket_id,
    t.ticket_price,
    t.ticket_type,
    t.ticket_date,
    t.ticket_status,
    CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name
  FROM
    kusto.travel['|'].tickets t
  JOIN
    kusto.travel['|'].customers c ON t.customer_id = c.customer_id
  WHERE
    t.ticket_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 90 DAY)
)
SELECT
  cte.customer_name,
  cte.total_orders,
  COUNT(DISTINCT s1.ticket_id) AS tickets_last_30_days,
  COUNT(DISTINCT s2.ticket_id) AS tickets_last_60_days,
  COUNT(DISTINCT s3.ticket_id) AS tickets_last_90_days,
  SUM(s1.ticket_price) AS total_sales_last_30_days,
  SUM(s2.ticket_price) AS total_sales_last_60_days,
  SUM(s3.ticket_price) AS total_sales_last_90_days
FROM
  cte
JOIN
  subquery1 s1 ON cte.customer_name = s1.customer_name
JOIN
  subquery2 s2 ON cte.customer_name = s2.customer_name
JOIN
  subquery3 s3 ON cte.customer_name = s3.customer_name
GROUP BY
  cte.customer_name,
  cte.total_orders
HAVING
  COUNT(DISTINCT s1.ticket_id) > 10
ORDER BY
  total_sales_last_30_days DESC
LIMIT
  10;",323,653,976,"[""kusto.travel['|'].customers"", ""kusto.travel['|'].orders"", ""kusto.travel['|'].tickets""]","[""kusto.travel['|'].customers"", ""kusto.travel['|'].orders"", ""kusto.travel['|'].tickets""]","[""kusto.travel['|'].customers"", ""kusto.travel['|'].orders"", ""kusto.travel['|'].tickets""]","[""kusto.travel['|'].customers"", ""kusto.travel['|'].orders"", ""kusto.travel['|'].tickets""]"
192,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of INNER, LEFT and OUTER JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a healthcare company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    p.patient_id,
    p.patient_name,
    p.date_of_birth,
    p.gender,
    p.address,
    p.phone_number,
    CONCAT(d.doctor_first_name, ' ', d.doctor_last_name) AS primary_doctor,
    d.specialty,
    CONCAT(pn.pharmacy_name, ', ', pn.pharmacy_address) AS preferred_pharmacy,
    COUNT(DISTINCT a.appointment_id) AS total_appointments,
    SUM(CASE WHEN a.appointment_status = 'Completed' THEN 1 ELSE 0 END) AS completed_appointments,
    SUM(CASE WHEN a.appointment_status = 'Cancelled' THEN 1 ELSE 0 END) AS cancelled_appointments,
    SUM(CASE WHEN a.appointment_status = 'No Show' THEN 1 ELSE 0 END) AS no_show_appointments,
    SUM(CASE WHEN a.appointment_status = 'Rescheduled' THEN 1 ELSE 0 END) AS rescheduled_appointments,
    SUM(CASE WHEN a.appointment_status = 'Pending' THEN 1 ELSE 0 END) AS pending_appointments,
    COUNT(DISTINCT m.medication_id) AS total_medications,
    COUNT(DISTINCT l.lab_test_id) AS total_lab_tests,
    SUM(CASE WHEN l.lab_test_status = 'Completed' THEN 1 ELSE 0 END) AS completed_lab_tests,
    SUM(CASE WHEN l.lab_test_status = 'Pending' THEN 1 ELSE 0 END) AS pending_lab_tests,
    SUM(CASE WHEN l.lab_test_status = 'Cancelled' THEN 1 ELSE 0 END) AS cancelled_lab_tests,
    SUM(CASE WHEN l.lab_test_status = 'Abnormal' THEN 1 ELSE 0 END) AS abnormal_lab_tests,
    SUM(CASE WHEN l.lab_test_status = 'Normal' THEN 1 ELSE 0 END) AS normal_lab_tests,
    AVG(DATEDIFF(l.lab_test_completed_date, l.lab_test_ordered_date)) AS avg_lab_test_turnaround,
    SUM(CASE WHEN v.visit_type = 'Inpatient' THEN 1 ELSE 0 END) AS total_inpatient_visits,
    SUM(CASE WHEN v.visit_type = 'Outpatient' THEN 1 ELSE 0 END) AS total_outpatient_visits,
    SUM(CASE WHEN v.visit_type = 'Emergency' THEN 1 ELSE 0 END) AS total_emergency_visits,
    SUM(CASE WHEN v.visit_type = 'Telemedicine' THEN 1 ELSE 0 END) AS total_telemedicine_visits,
    SUM(CASE WHEN v.visit_type = 'Home Visit' THEN 1 ELSE 0 END) AS total_home_visits,
    SUM(CASE WHEN v.visit_type = 'Urgent Care' THEN 1 ELSE 0 END) AS total_urgent_care_visits,
    SUM(CASE WHEN v.visit_type = 'Walk-in Clinic' THEN 1 ELSE 0 END) AS total_walk_in_clinic_visits,
    SUM(CASE WHEN v.visit_type = 'Specialist' THEN 1 ELSE 0 END) AS total_specialist_visits,
    SUM(CASE WHEN v.visit_type = 'Primary Care' THEN 1 ELSE 0 END) AS total_primary_care_visits,
    SUM(CASE WHEN v.visit_type = 'Preventive Care' THEN 1 ELSE 0 END) AS total_preventive_care_visits,
    SUM(CASE WHEN v.visit_type = 'Follow-up' THEN 1 ELSE 0 END) AS total_follow_up_visits,
    SUM(CASE WHEN v.visit_type = 'Diagnostic' THEN 1 ELSE 0 END) AS total_diagnostic_visits,
    SUM(CASE WHEN v.visit_type = 'Surgery' THEN 1 ELSE 0 END) AS total_surgery_visits,
    SUM(CASE WHEN v.visit_type = 'Rehabilitation' THEN 1 ELSE 0 END) AS total_rehabilitation_visits,
    SUM(CASE WHEN v.visit_type = 'Maternity' THEN 1 ELSE 0 END) AS total_maternity_visits,
    SUM(CASE WHEN v.visit_type = 'Pediatric' THEN 1 ELSE 0 END) AS total_pediatric_visits,
    SUM(CASE WHEN v.visit_type = 'Geriatric' THEN 1 ELSE 0 END) AS total_geriatric_visits,
    SUM(CASE WHEN v.visit_type = 'Mental Health' THEN 1 ELSE 0 END) AS total_mental_health_visits,
    SUM(CASE WHEN v.visit_type = 'Chronic Care' THEN 1 ELSE 0 END) AS total_chronic_care_visits,
    SUM(CASE WHEN v.visit_type = 'Acute Care' THEN 1 ELSE 0 END) AS total_acute_care_visits,
    SUM(CASE WHEN v.visit_type = 'Palliative Care' THEN 1 ELSE 0 END) AS total_palliative_care_visits,
    SUM(CASE WHEN v.visit_type = 'Hospice' THEN 1 ELSE 0 END) AS total_hospice_visits,
    SUM(CASE WHEN v.visit_type = 'Wellness' THEN 1 ELSE 0 END) AS total_wellness_visits,
    SUM(CASE WHEN v.visit_type = 'Occupational Health' THEN 1 ELSE 0 END) AS total_occupational_health_visits,
    SUM(CASE WHEN v.visit_type = 'Sports Medicine' THEN 1 ELSE 0 END) AS total_sports_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Travel Medicine' THEN 1 ELSE 0 END) AS total_travel_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Alternative Medicine' THEN 1 ELSE 0 END) AS total_alternative_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Nutrition' THEN 1 ELSE 0 END) AS total_nutrition_visits,
    SUM(CASE WHEN v.visit_type = 'Weight Management' THEN 1 ELSE 0 END) AS total_weight_management_visits,
    SUM(CASE WHEN v.visit_type = 'Physical Therapy' THEN 1 ELSE 0 END) AS total_physical_therapy_visits,
    SUM(CASE WHEN v.visit_type = 'Speech Therapy' THEN 1 ELSE 0 END) AS total_speech_therapy_visits,
    SUM(CASE WHEN v.visit_type = 'Occupational Therapy' THEN 1 ELSE 0 END) AS total_occupational_therapy_visits,
    SUM(CASE WHEN v.visit_type = 'Cardiology' THEN 1 ELSE 0 END) AS total_cardiology_visits,
    SUM(CASE WHEN v.visit_type = 'Dermatology' THEN 1 ELSE 0 END) AS total_dermatology_visits,
    SUM(CASE WHEN v.visit_type = 'Endocrinology' THEN 1 ELSE 0 END) AS total_endocrinology_visits,
    SUM(CASE WHEN v.visit_type = 'Gastroenterology' THEN 1 ELSE 0 END) AS total_gastroenterology_visits,
    SUM(CASE WHEN v.visit_type = 'Hematology' THEN 1 ELSE 0 END) AS total_hematology_visits,
    SUM(CASE WHEN v.visit_type = 'Nephrology' THEN 1 ELSE 0 END) AS total_nephrology_visits,
    SUM(CASE WHEN v.visit_type = 'Neurology' THEN 1 ELSE 0 END) AS total_neurology_visits,
    SUM(CASE WHEN v.visit_type = 'Oncology' THEN 1 ELSE 0 END) AS total_oncology_visits,
    SUM(CASE WHEN v.visit_type = 'Ophthalmology' THEN 1 ELSE 0 END) AS total_ophthalmology_visits,
    SUM(CASE WHEN v.visit_type = 'Orthopedics' THEN 1 ELSE 0 END) AS total_orthopedics_visits,
    SUM(CASE WHEN v.visit_type = 'Otolaryngology' THEN 1 ELSE 0 END) AS total_otolaryngology_visits,
    SUM(CASE WHEN v.visit_type = 'Pulmonology' THEN 1 ELSE 0 END) AS total_pulmonology_visits,
    SUM(CASE WHEN v.visit_type = 'Rheumatology' THEN 1 ELSE 0 END) AS total_rheumatology_visits,
    SUM(CASE WHEN v.visit_type = 'Urology' THEN 1 ELSE 0 END) AS total_urology_visits,
    SUM(CASE WHEN v.visit_type = 'Allergy' THEN 1 ELSE 0 END) AS total_allergy_visits,
    SUM(CASE WHEN v.visit_type = 'Immunology' THEN 1 ELSE 0 END) AS total_immunology_visits,
    SUM(CASE WHEN v.visit_type = 'Infectious Disease' THEN 1 ELSE 0 END) AS total_infectious_disease_visits,
    SUM(CASE WHEN v.visit_type = 'Psychiatry' THEN 1 ELSE 0 END) AS total_psychiatry_visits,
    SUM(CASE WHEN v.visit_type = 'Radiology' THEN 1 ELSE 0 END) AS total_radiology_visits,
    SUM(CASE WHEN v.visit_type = 'Nuclear Medicine' THEN 1 ELSE 0 END) AS total_nuclear_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Anesthesiology' THEN 1 ELSE 0 END) AS total_anesthesiology_visits,
    SUM(CASE WHEN v.visit_type = 'Emergency Medicine' THEN 1 ELSE 0 END) AS total_emergency_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Family Medicine' THEN 1 ELSE 0 END) AS total_family_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Internal Medicine' THEN 1 ELSE 0 END) AS total_internal_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Obstetrics' THEN 1 ELSE 0 END) AS total_obstetrics_visits,
    SUM(CASE WHEN v.visit_type = 'Pain Management' THEN 1 ELSE 0 END) AS total_pain_management_visits,
    SUM(CASE WHEN v.visit_type = 'Pathology' THEN 1 ELSE 0 END) AS total_pathology_visits,
    SUM(CASE WHEN v.visit_type = 'Physical Medicine' THEN 1 ELSE 0 END) AS total_physical_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Podiatry' THEN 1 ELSE 0 END) AS total_podiatry_visits,
    SUM(CASE WHEN v.visit_type = 'Preventive Medicine' THEN 1 ELSE 0 END) AS total_preventive_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Sleep Medicine' THEN 1 ELSE 0 END) AS total_sleep_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Sports Medicine' THEN 1 ELSE 0 END) AS total_sports_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Surgery' THEN 1 ELSE 0 END) AS total_surgery_visits,
    SUM(CASE WHEN v.visit_type = 'Toxicology' THEN 1 ELSE 0 END) AS total_toxicology_visits,
    SUM(CASE WHEN v.visit_type = 'Vascular Medicine' THEN 1 ELSE 0 END) AS total_vascular_medicine_visits,
    SUM(CASE WHEN v.visit_type = 'Other' THEN 1 ELSE 0 END) AS total_other_visits
FROM
    patients p
    LEFT JOIN doctors d ON p.primary_doctor_id = d.doctor_id
    LEFT JOIN pharmacies pn ON p.preferred_pharmacy_id = pn.pharmacy_id
    LEFT JOIN appointments a ON p.patient_id = a.patient_id
    LEFT JOIN medications m ON p.patient_id = m.patient_id
    LEFT JOIN lab_tests l ON p.patient_id = l.patient_id
    LEFT JOIN visits v ON p.patient_id = v.patient_id
GROUP BY
    p.patient_id,
    p.patient_name,
    p.date_of_birth,
    p.gender,
    p.address,
    p.phone_number,
    primary_doctor,
    d.specialty,
    preferred_pharmacy;",317,2583,2900,"['patients', 'doctors', 'pharmacies', 'appointments', 'medications', 'lab_tests', 'visits']","['patients', 'doctors', 'pharmacies', 'appointments', 'medications', 'lab_tests', 'visits']","['patients', 'doctors', 'pharmacies', 'appointments', 'medications', 'lab_tests', 'visits']","['patients', 'doctors', 'pharmacies', 'appointments', 'medications', 'lab_tests', 'visits']"
193,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an entertainment company.

The resulting output should strictly be the SQL query without any surrounding text.","WITH 
  cte1 AS (
    SELECT 
      CONCAT(c.customer_first_name, ' ', c.customer_last_name) AS customer_name,
      COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
      entertainment_company.customers c
    INNER JOIN 
      entertainment_company.orders o ON c.customer_id = o.customer_id
    WHERE 
      o.order_date >= '2021-01-01'
    GROUP BY 
      c.customer_id
    HAVING 
      COUNT(DISTINCT o.order_id) > 5
  ),
  cte2 AS (
    SELECT 
      p.product_name,
      SUM(op.quantity) AS total_quantity
    FROM 
      entertainment_company.products p
    INNER JOIN 
      entertainment_company.order_products op ON p.product_id = op.product_id
    INNER JOIN 
      entertainment_company.orders o ON op.order_id = o.order_id
    WHERE 
      o.order_date >= '2021-01-01'
    GROUP BY 
      p.product_id
    HAVING 
      SUM(op.quantity) > 100
  ),
  cte3 AS (
    SELECT 
      c.customer_id,
      COUNT(DISTINCT o.order_id) AS total_orders
    FROM 
      entertainment_company.customers c
    INNER JOIN 
      entertainment_company.orders o ON c.customer_id = o.customer_id
    WHERE 
      o.order_date >= '2021-01-01'
    GROUP BY 
      c.customer_id
    HAVING 
      COUNT(DISTINCT o.order_id) > 5
  )
SELECT 
  cte1.customer_name,
  cte1.total_orders,
  cte2.product_name,
  cte2.total_quantity,
  DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
  UPPER(p.product_category) AS upper_product_category
FROM 
  cte1
INNER JOIN 
  cte2 ON cte1.total_orders = cte2.total_quantity
INNER JOIN 
  entertainment_company.orders o ON cte1.customer_name = o.customer_name
INNER JOIN 
  entertainment_company.products p ON cte2.product_name = p.product_name
WHERE 
  o.order_date >= '2021-01-01'
  AND p.product_category IN ('Movies', 'Music')
ORDER BY 
  cte1.total_orders DESC,
  cte2.total_quantity DESC
LIMIT 100;",315,497,812,"['entertainment_company.customers', 'entertainment_company.orders', 'entertainment_company.products', 'entertainment_company.order_products']","['entertainment_company.customers', 'entertainment_company.orders', 'entertainment_company.products', 'entertainment_company.order_products']","['entertainment_company.customers', 'entertainment_company.orders', 'entertainment_company.products', 'entertainment_company.order_products']","['entertainment_company.customers', 'entertainment_company.orders', 'entertainment_company.products', 'entertainment_company.order_products']"
194,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <table>, <schema>.<table> or <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a telecommunications company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    c.phone_number,
    CONCAT(a.street, ', ', a.city, ', ', a.state, ' ', a.zip_code) AS customer_address,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_price) AS total_sales,
    AVG(DATEDIFF(o.order_date, c.date_of_birth)) AS avg_age_at_purchase,
    CONCAT(DATE_FORMAT(o.order_date, '%M %Y'), ' - ', DATE_FORMAT(o.order_date, '%W')) AS order_month_week,
    CASE
        WHEN o.total_price > 100 THEN 'High Value'
        WHEN o.total_price > 50 THEN 'Medium Value'
        ELSE 'Low Value'
    END AS order_value_category
FROM
    customers c
JOIN
    addresses a ON c.address_id = a.address_id
JOIN
    orders o ON c.customer_id = o.customer_id
JOIN
    products p ON o.product_id = p.product_id
JOIN
    categories cat ON p.category_id = cat.category_id
LEFT JOIN
    payments pay ON o.order_id = pay.order_id
WHERE
    c.date_of_birth <= DATE_SUB(CURDATE(), INTERVAL 30 YEAR)
    AND a.state = 'California'
    AND cat.category_name = 'Telecommunications'
    AND pay.payment_status = 'Paid'
GROUP BY
    c.customer_id,
    order_month_week
HAVING
    total_orders > 2
ORDER BY
    total_sales DESC,
    customer_name ASC
LIMIT 100;",314,327,641,"['customers', 'addresses', 'orders', 'products', 'categories', 'payments']","['customers', 'addresses', 'orders', 'products', 'categories', 'payments']","['customers', 'addresses', 'orders', 'products', 'categories', 'payments']","['customers', 'addresses', 'orders', 'products', 'categories', 'payments']"
195,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <project>.<dataset>.<table>, <table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of regular joins and a final CROSS JOIN. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a manufacturing company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(manufacturing.orders.order_id, '-', manufacturing.orders.order_date) AS OrderNumber,
    manufacturing.products.product_name AS ProductName,
    manufacturing.products.product_category AS Category,
    manufacturing.customers.customer_name AS CustomerName,
    manufacturing.customers.customer_city AS CustomerCity,
    manufacturing.customers.customer_state AS CustomerState,
    SUM(manufacturing.order_items.quantity) AS TotalQuantity,
    SUM(manufacturing.order_items.quantity * manufacturing.order_items.unit_price) AS TotalRevenue
FROM 
    manufacturing.orders
JOIN 
    manufacturing.order_items ON manufacturing.orders.order_id = manufacturing.order_items.order_id
JOIN 
    manufacturing.products ON manufacturing.order_items.product_id = manufacturing.products.product_id
JOIN 
    manufacturing.customers ON manufacturing.orders.customer_id = manufacturing.customers.customer_id
WHERE 
    manufacturing.orders.order_date >= '2021-01-01' AND manufacturing.orders.order_date <= '2021-12-31'
    AND manufacturing.products.product_category IN ('Electronics', 'Furniture', 'Appliances')
GROUP BY 
    manufacturing.orders.order_id, manufacturing.products.product_name, manufacturing.products.product_category,
    manufacturing.customers.customer_name, manufacturing.customers.customer_city, manufacturing.customers.customer_state
HAVING 
    TotalQuantity >= 10
ORDER BY 
    TotalRevenue DESC
LIMIT 100
CROSS JOIN 
    (SELECT 
        manufacturing.warehouse.warehouse_name AS WarehouseName,
        COUNT(DISTINCT manufacturing.orders.order_id) AS TotalOrders
    FROM 
        manufacturing.warehouse
    JOIN 
        manufacturing.orders ON manufacturing.warehouse.warehouse_id = manufacturing.orders.warehouse_id
    WHERE 
        manufacturing.warehouse.warehouse_city = 'New York'
    GROUP BY 
        manufacturing.warehouse.warehouse_name) AS Subquery1
LEFT JOIN 
    (SELECT 
        manufacturing.suppliers.supplier_name AS SupplierName,
        COUNT(DISTINCT manufacturing.products.product_id) AS TotalProducts
    FROM 
        manufacturing.suppliers
    JOIN 
        manufacturing.products ON manufacturing.suppliers.supplier_id = manufacturing.products.supplier_id
    WHERE 
        manufacturing.suppliers.supplier_country = 'China'
    GROUP BY 
        manufacturing.suppliers.supplier_name) AS Subquery2 ON Subquery2.TotalProducts > 5
WHERE 
    Subquery1.TotalOrders > 100
ORDER BY 
    TotalRevenue DESC, Subquery1.TotalOrders DESC, Subquery2.TotalProducts ASC
LIMIT 10;",319,500,819,"['manufacturing.orders', 'manufacturing.order_items', 'manufacturing.products', 'manufacturing.customers', 'manufacturing.warehouse', 'manufacturing.suppliers']","['manufacturing.orders', 'manufacturing.order_items', 'manufacturing.products', 'manufacturing.customers', 'manufacturing.warehouse', 'manufacturing.suppliers']","['manufacturing.orders', 'manufacturing.order_items', 'manufacturing.products', 'manufacturing.customers', 'manufacturing.warehouse', 'manufacturing.suppliers']","['manufacturing.orders', 'manufacturing.order_items', 'manufacturing.products', 'manufacturing.customers', 'manufacturing.warehouse', 'manufacturing.suppliers']"
196,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a small shop.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.unit_price,
    oi.quantity,
    oi.quantity * p.unit_price AS total_price
FROM 
    sales.customers AS c
JOIN 
    sales.orders AS o ON c.customer_id = o.customer_id
JOIN 
    sales.order_items AS oi ON o.order_id = oi.order_id
JOIN 
    inventory.products AS p ON oi.product_id = p.product_id
WHERE 
    c.city = 'New York'
    AND o.order_date >= '2021-01-01'
    AND oi.quantity >= 5
GROUP BY 
    c.customer_id,
    o.order_id,
    p.product_id
HAVING 
    SUM(oi.quantity * p.unit_price) > 1000
ORDER BY 
    c.customer_id ASC,
    o.order_id ASC,
    p.product_id ASC;",316,214,530,"['sales.customers', 'sales.orders', 'sales.order_items', 'inventory.products']","['sales.customers', 'sales.orders', 'sales.order_items', 'inventory.products']","['sales.customers', 'sales.orders', 'sales.order_items', 'inventory.products']","['sales.customers', 'sales.orders', 'sales.order_items', 'inventory.products']"
197,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <database>.<schema>.<table>, <schema>.<table> or kusto's <database>['|'].<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of intricate CROSS JOINS and LATERAL JOINS. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a medium length but intricate query.

Create the query as if it was for a retail company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS formatted_order_date,
    p.product_name,
    p.unit_price,
    SUM(op.quantity) AS total_quantity,
    SUM(op.quantity * p.unit_price) AS total_price
FROM
    retail_db.customers c
    CROSS JOIN retail_db.orders o
    INNER JOIN retail_db.order_products op ON o.order_id = op.order_id
    INNER JOIN retail_db.products p ON op.product_id = p.product_id
    INNER JOIN (
        SELECT 
            o.order_id,
            COUNT(DISTINCT op.product_id) AS unique_products
        FROM
            retail_db.orders o
            INNER JOIN retail_db.order_products op ON o.order_id = op.order_id
        GROUP BY
            o.order_id
        HAVING
            unique_products > 1
    ) subq ON o.order_id = subq.order_id
WHERE
    c.customer_id = o.customer_id
    AND o.order_status = 'completed'
    AND p.category = 'electronics'
GROUP BY
    c.customer_id,
    o.order_id,
    p.product_id,
    p.product_name,
    p.unit_price
HAVING
    total_quantity > 5
ORDER BY
    total_price DESC
LIMIT 10;",329,287,616,"['retail_db.customers', 'retail_db.orders', 'retail_db.order_products', 'retail_db.products']","['retail_db.customers', 'retail_db.orders', 'retail_db.order_products', 'retail_db.products']","['retail_db.customers', 'retail_db.orders', 'retail_db.order_products', 'retail_db.products']","['retail_db.customers', 'retail_db.orders', 'retail_db.order_products', 'retail_db.products']"
198,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of the most frequent joins. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query include multiple Common Table Expressions (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for an e-commerce site.

The resulting output should strictly be the SQL query without any surrounding text.","WITH
    cte_orders AS (
        SELECT
            o.order_id,
            o.order_date,
            o.customer_id,
            o.total_price
        FROM
            ecommerce.orders o
        WHERE
            o.order_date >= '2021-01-01'
    ),
    cte_customers AS (
        SELECT
            c.customer_id,
            c.customer_name,
            c.city,
            c.state
        FROM
            ecommerce.customers c
        WHERE
            c.state IN ('CA', 'NY')
    ),
    cte_products AS (
        SELECT
            p.product_id,
            p.product_name,
            p.category,
            p.unit_price
        FROM
            ecommerce.products p
        WHERE
            p.category = 'Electronics'
    )
SELECT
    c.customer_name,
    c.city,
    c.state,
    COUNT(DISTINCT o.order_id) AS TotalOrders,
    SUM(o.total_price) AS TotalSales,
    AVG(p.unit_price) AS AvgUnitPrice
FROM
    cte_customers c
JOIN
    cte_orders o ON c.customer_id = o.customer_id
JOIN
    cte_products p ON o.order_id = p.product_id
WHERE
    YEAR(o.order_date) = 2021
GROUP BY
    c.customer_name,
    c.city,
    c.state
HAVING
    COUNT(DISTINCT o.order_id) > 2
ORDER BY
    TotalSales DESC;",316,301,617,"['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products']","['ecommerce.orders', 'ecommerce.customers', 'ecommerce.products']"
199,"Generate an intricate SQL query without any preceding or trailing explanations or comments. 
Ensure the query meets the following criteria:

Tables & Columns: Include tables with different naming schemas, like <project>.<dataset>.<table>, <table>, <database>.<schema>.<table>, substituting each for a valid and creative table name. Each table should have columns fitting its purpose.
Joins: Use a mix of some creative JOIN operations. The join conditions should represent realistic relationships between the tables.
Filtering: Use WHERE and HAVING clauses with meaningful conditions related to the provided table names and columns.
Grouping: Incorporate GROUP BY on certain columns and accompany it with aggregate functions such as SUM(), AVG(), or COUNT().
Functions: Utilize functions like DATE_FORMAT(), CONCAT(), or UPPER() where they fit naturally.
Column Renaming: Rename some of the output columns using the AS keyword, e.g., SUM(orders.total_price) AS TotalSales.
Subqueries & CTEs: Integrate multiple subqueries within the main query don't include any Common Table Expression (CTE). Names have to be relevant.
Creativity: Add any other SQL clauses or functions to enhance complexity, but ensure all table and column names remain realistic.
Length: Make it a very long and intricate query.

Create the query as if it was for a pharmaceutical company.

The resulting output should strictly be the SQL query without any surrounding text.","SELECT 
    CONCAT(p.product_name, ' - ', p.product_code) AS Product,
    c.category_name AS Category,
    s.supplier_name AS Supplier,
    SUM(o.quantity) AS TotalQuantity,
    AVG(o.unit_price) AS AveragePrice,
    COUNT(DISTINCT o.order_id) AS TotalOrders,
    DATE_FORMAT(o.order_date, '%Y-%m-%d') AS OrderDate,
    UPPER(u.username) AS UserName
FROM
    pharmaceutical_company.products p
    JOIN pharmaceutical_company.categories c ON p.category_id = c.category_id
    JOIN pharmaceutical_company.suppliers s ON p.supplier_id = s.supplier_id
    JOIN pharmaceutical_company.orders o ON p.product_id = o.product_id
    JOIN pharmaceutical_company.users u ON o.user_id = u.user_id
WHERE
    p.product_status = 'Active'
    AND c.category_name IN ('Antibiotics', 'Painkillers')
    AND s.supplier_country = 'United States'
    AND o.order_date BETWEEN '2021-01-01' AND '2021-12-31'
GROUP BY
    p.product_name,
    c.category_name,
    s.supplier_name,
    DATE_FORMAT(o.order_date, '%Y-%m-%d'),
    UPPER(u.username)
HAVING
    TotalQuantity > 100
    AND AveragePrice < 50
ORDER BY
    TotalOrders DESC,
    Product ASC;",316,291,607,"['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']","['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']","['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']","['pharmaceutical_company.products', 'pharmaceutical_company.categories', 'pharmaceutical_company.suppliers', 'pharmaceutical_company.orders', 'pharmaceutical_company.users']"
